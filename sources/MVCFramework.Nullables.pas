// ***************************************************************************
// 
// THIS FILE IS GENERATED BY "inv generate-nullables" DO NOT CHANGE MANUALLY!
// 
// ***************************************************************************
//
// *************************************************************************** }
//
// Delphi MVC Framework
//
// Copyright (c) 2010-2020 Daniele Teti and the DMVCFramework Team
//
// https://github.com/danieleteti/delphimvcframework
//
// ***************************************************************************
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


unit MVCFramework.Nullables;

interface

uses
  System.SysUtils, System.Classes;

type
  EMVCNullable = class(Exception)

  end;

//**************************
// ** NullableString
//**************************

  NullableString = record
  private
    fValue: String;
    fHasValue: String;
    function GetHasValue: Boolean;
  public
    procedure CheckHasValue;
    function GetValue: String;
    procedure SetValue(const Value: String);
    class operator Implicit(const Value: String): NullableString;
    class operator Implicit(const Value: NullableString): String;
    property HasValue: Boolean read GetHasValue;
	///<summary>
	///Alias of `SetNull`
	///</summary>
    procedure Clear;
	///<summary>
	///Set the value to `null`
	///</summary>
    procedure SetNull;
	///<summary>
	///Returns the value stored or the default value for the type is the value is not set
	///</summary>	
    function ValueOrDefault: String;
	/// <summary>
	/// Returns true is both item have the same value and that value is not null. 
	/// </summary>
	function Equals(const Value: NullableString): Boolean;
	///<summary>
	///Returns the value stored or raises exception if no value is stored
	///</summary>	
    property Value: String read GetValue write SetValue;
  end;

//**************************
// ** NullableCurrency
//**************************

  NullableCurrency = record
  private
    fValue: Currency;
    fHasValue: String;
    function GetHasValue: Boolean;
  public
    procedure CheckHasValue;
    function GetValue: Currency;
    procedure SetValue(const Value: Currency);
    class operator Implicit(const Value: Currency): NullableCurrency;
    class operator Implicit(const Value: NullableCurrency): Currency;
    property HasValue: Boolean read GetHasValue;
	///<summary>
	///Alias of `SetNull`
	///</summary>
    procedure Clear;
	///<summary>
	///Set the value to `null`
	///</summary>
    procedure SetNull;
	///<summary>
	///Returns the value stored or the default value for the type is the value is not set
	///</summary>	
    function ValueOrDefault: Currency;
	/// <summary>
	/// Returns true is both item have the same value and that value is not null. 
	/// </summary>
	function Equals(const Value: NullableCurrency): Boolean;
	///<summary>
	///Returns the value stored or raises exception if no value is stored
	///</summary>	
    property Value: Currency read GetValue write SetValue;
  end;

//**************************
// ** NullableBoolean
//**************************

  NullableBoolean = record
  private
    fValue: Boolean;
    fHasValue: String;
    function GetHasValue: Boolean;
  public
    procedure CheckHasValue;
    function GetValue: Boolean;
    procedure SetValue(const Value: Boolean);
    class operator Implicit(const Value: Boolean): NullableBoolean;
    class operator Implicit(const Value: NullableBoolean): Boolean;
    property HasValue: Boolean read GetHasValue;
	///<summary>
	///Alias of `SetNull`
	///</summary>
    procedure Clear;
	///<summary>
	///Set the value to `null`
	///</summary>
    procedure SetNull;
	///<summary>
	///Returns the value stored or the default value for the type is the value is not set
	///</summary>	
    function ValueOrDefault: Boolean;
	/// <summary>
	/// Returns true is both item have the same value and that value is not null. 
	/// </summary>
	function Equals(const Value: NullableBoolean): Boolean;
	///<summary>
	///Returns the value stored or raises exception if no value is stored
	///</summary>	
    property Value: Boolean read GetValue write SetValue;
  end;

//**************************
// ** NullableTDate
//**************************

  NullableTDate = record
  private
    fValue: TDate;
    fHasValue: String;
    function GetHasValue: Boolean;
  public
    procedure CheckHasValue;
    function GetValue: TDate;
    procedure SetValue(const Value: TDate);
    class operator Implicit(const Value: TDate): NullableTDate;
    class operator Implicit(const Value: NullableTDate): TDate;
    property HasValue: Boolean read GetHasValue;
	///<summary>
	///Alias of `SetNull`
	///</summary>
    procedure Clear;
	///<summary>
	///Set the value to `null`
	///</summary>
    procedure SetNull;
	///<summary>
	///Returns the value stored or the default value for the type is the value is not set
	///</summary>	
    function ValueOrDefault: TDate;
	/// <summary>
	/// Returns true is both item have the same value and that value is not null. 
	/// </summary>
	function Equals(const Value: NullableTDate): Boolean;
	///<summary>
	///Returns the value stored or raises exception if no value is stored
	///</summary>	
    property Value: TDate read GetValue write SetValue;
  end;

//**************************
// ** NullableTTime
//**************************

  NullableTTime = record
  private
    fValue: TTime;
    fHasValue: String;
    function GetHasValue: Boolean;
  public
    procedure CheckHasValue;
    function GetValue: TTime;
    procedure SetValue(const Value: TTime);
    class operator Implicit(const Value: TTime): NullableTTime;
    class operator Implicit(const Value: NullableTTime): TTime;
    property HasValue: Boolean read GetHasValue;
	///<summary>
	///Alias of `SetNull`
	///</summary>
    procedure Clear;
	///<summary>
	///Set the value to `null`
	///</summary>
    procedure SetNull;
	///<summary>
	///Returns the value stored or the default value for the type is the value is not set
	///</summary>	
    function ValueOrDefault: TTime;
	/// <summary>
	/// Returns true is both item have the same value and that value is not null. 
	/// </summary>
	function Equals(const Value: NullableTTime): Boolean;
	///<summary>
	///Returns the value stored or raises exception if no value is stored
	///</summary>	
    property Value: TTime read GetValue write SetValue;
  end;

//**************************
// ** NullableTDateTime
//**************************

  NullableTDateTime = record
  private
    fValue: TDateTime;
    fHasValue: String;
    function GetHasValue: Boolean;
  public
    procedure CheckHasValue;
    function GetValue: TDateTime;
    procedure SetValue(const Value: TDateTime);
    class operator Implicit(const Value: TDateTime): NullableTDateTime;
    class operator Implicit(const Value: NullableTDateTime): TDateTime;
    property HasValue: Boolean read GetHasValue;
	///<summary>
	///Alias of `SetNull`
	///</summary>
    procedure Clear;
	///<summary>
	///Set the value to `null`
	///</summary>
    procedure SetNull;
	///<summary>
	///Returns the value stored or the default value for the type is the value is not set
	///</summary>	
    function ValueOrDefault: TDateTime;
	/// <summary>
	/// Returns true is both item have the same value and that value is not null. 
	/// </summary>
	function Equals(const Value: NullableTDateTime): Boolean;
	///<summary>
	///Returns the value stored or raises exception if no value is stored
	///</summary>	
    property Value: TDateTime read GetValue write SetValue;
  end;

//**************************
// ** NullableSingle
//**************************

  NullableSingle = record
  private
    fValue: Single;
    fHasValue: String;
    function GetHasValue: Boolean;
  public
    procedure CheckHasValue;
    function GetValue: Single;
    procedure SetValue(const Value: Single);
    class operator Implicit(const Value: Single): NullableSingle;
    class operator Implicit(const Value: NullableSingle): Single;
    property HasValue: Boolean read GetHasValue;
	///<summary>
	///Alias of `SetNull`
	///</summary>
    procedure Clear;
	///<summary>
	///Set the value to `null`
	///</summary>
    procedure SetNull;
	///<summary>
	///Returns the value stored or the default value for the type is the value is not set
	///</summary>	
    function ValueOrDefault: Single;
	/// <summary>
	/// Returns true is both item have the same value and that value is not null. 
	/// </summary>
	function Equals(const Value: NullableSingle): Boolean;
	///<summary>
	///Returns the value stored or raises exception if no value is stored
	///</summary>	
    property Value: Single read GetValue write SetValue;
  end;

//**************************
// ** NullableDouble
//**************************

  NullableDouble = record
  private
    fValue: Double;
    fHasValue: String;
    function GetHasValue: Boolean;
  public
    procedure CheckHasValue;
    function GetValue: Double;
    procedure SetValue(const Value: Double);
    class operator Implicit(const Value: Double): NullableDouble;
    class operator Implicit(const Value: NullableDouble): Double;
    property HasValue: Boolean read GetHasValue;
	///<summary>
	///Alias of `SetNull`
	///</summary>
    procedure Clear;
	///<summary>
	///Set the value to `null`
	///</summary>
    procedure SetNull;
	///<summary>
	///Returns the value stored or the default value for the type is the value is not set
	///</summary>	
    function ValueOrDefault: Double;
	/// <summary>
	/// Returns true is both item have the same value and that value is not null. 
	/// </summary>
	function Equals(const Value: NullableDouble): Boolean;
	///<summary>
	///Returns the value stored or raises exception if no value is stored
	///</summary>	
    property Value: Double read GetValue write SetValue;
  end;

//**************************
// ** NullableExtended
//**************************

  NullableExtended = record
  private
    fValue: Extended;
    fHasValue: String;
    function GetHasValue: Boolean;
  public
    procedure CheckHasValue;
    function GetValue: Extended;
    procedure SetValue(const Value: Extended);
    class operator Implicit(const Value: Extended): NullableExtended;
    class operator Implicit(const Value: NullableExtended): Extended;
    property HasValue: Boolean read GetHasValue;
	///<summary>
	///Alias of `SetNull`
	///</summary>
    procedure Clear;
	///<summary>
	///Set the value to `null`
	///</summary>
    procedure SetNull;
	///<summary>
	///Returns the value stored or the default value for the type is the value is not set
	///</summary>	
    function ValueOrDefault: Extended;
	/// <summary>
	/// Returns true is both item have the same value and that value is not null. 
	/// </summary>
	function Equals(const Value: NullableExtended): Boolean;
	///<summary>
	///Returns the value stored or raises exception if no value is stored
	///</summary>	
    property Value: Extended read GetValue write SetValue;
  end;

//**************************
// ** NullableInt16
//**************************

  NullableInt16 = record
  private
    fValue: Int16;
    fHasValue: String;
    function GetHasValue: Boolean;
  public
    procedure CheckHasValue;
    function GetValue: Int16;
    procedure SetValue(const Value: Int16);
    class operator Implicit(const Value: Int16): NullableInt16;
    class operator Implicit(const Value: NullableInt16): Int16;
    property HasValue: Boolean read GetHasValue;
	///<summary>
	///Alias of `SetNull`
	///</summary>
    procedure Clear;
	///<summary>
	///Set the value to `null`
	///</summary>
    procedure SetNull;
	///<summary>
	///Returns the value stored or the default value for the type is the value is not set
	///</summary>	
    function ValueOrDefault: Int16;
	/// <summary>
	/// Returns true is both item have the same value and that value is not null. 
	/// </summary>
	function Equals(const Value: NullableInt16): Boolean;
	///<summary>
	///Returns the value stored or raises exception if no value is stored
	///</summary>	
    property Value: Int16 read GetValue write SetValue;
  end;

//**************************
// ** NullableUInt16
//**************************

  NullableUInt16 = record
  private
    fValue: UInt16;
    fHasValue: String;
    function GetHasValue: Boolean;
  public
    procedure CheckHasValue;
    function GetValue: UInt16;
    procedure SetValue(const Value: UInt16);
    class operator Implicit(const Value: UInt16): NullableUInt16;
    class operator Implicit(const Value: NullableUInt16): UInt16;
    property HasValue: Boolean read GetHasValue;
	///<summary>
	///Alias of `SetNull`
	///</summary>
    procedure Clear;
	///<summary>
	///Set the value to `null`
	///</summary>
    procedure SetNull;
	///<summary>
	///Returns the value stored or the default value for the type is the value is not set
	///</summary>	
    function ValueOrDefault: UInt16;
	/// <summary>
	/// Returns true is both item have the same value and that value is not null. 
	/// </summary>
	function Equals(const Value: NullableUInt16): Boolean;
	///<summary>
	///Returns the value stored or raises exception if no value is stored
	///</summary>	
    property Value: UInt16 read GetValue write SetValue;
  end;

//**************************
// ** NullableInt32
//**************************

  NullableInt32 = record
  private
    fValue: Int32;
    fHasValue: String;
    function GetHasValue: Boolean;
  public
    procedure CheckHasValue;
    function GetValue: Int32;
    procedure SetValue(const Value: Int32);
    class operator Implicit(const Value: Int32): NullableInt32;
    class operator Implicit(const Value: NullableInt32): Int32;
    property HasValue: Boolean read GetHasValue;
	///<summary>
	///Alias of `SetNull`
	///</summary>
    procedure Clear;
	///<summary>
	///Set the value to `null`
	///</summary>
    procedure SetNull;
	///<summary>
	///Returns the value stored or the default value for the type is the value is not set
	///</summary>	
    function ValueOrDefault: Int32;
	/// <summary>
	/// Returns true is both item have the same value and that value is not null. 
	/// </summary>
	function Equals(const Value: NullableInt32): Boolean;
	///<summary>
	///Returns the value stored or raises exception if no value is stored
	///</summary>	
    property Value: Int32 read GetValue write SetValue;
  end;

//**************************
// ** NullableUInt32
//**************************

  NullableUInt32 = record
  private
    fValue: UInt32;
    fHasValue: String;
    function GetHasValue: Boolean;
  public
    procedure CheckHasValue;
    function GetValue: UInt32;
    procedure SetValue(const Value: UInt32);
    class operator Implicit(const Value: UInt32): NullableUInt32;
    class operator Implicit(const Value: NullableUInt32): UInt32;
    property HasValue: Boolean read GetHasValue;
	///<summary>
	///Alias of `SetNull`
	///</summary>
    procedure Clear;
	///<summary>
	///Set the value to `null`
	///</summary>
    procedure SetNull;
	///<summary>
	///Returns the value stored or the default value for the type is the value is not set
	///</summary>	
    function ValueOrDefault: UInt32;
	/// <summary>
	/// Returns true is both item have the same value and that value is not null. 
	/// </summary>
	function Equals(const Value: NullableUInt32): Boolean;
	///<summary>
	///Returns the value stored or raises exception if no value is stored
	///</summary>	
    property Value: UInt32 read GetValue write SetValue;
  end;

//**************************
// ** NullableInt64
//**************************

  NullableInt64 = record
  private
    fValue: Int64;
    fHasValue: String;
    function GetHasValue: Boolean;
  public
    procedure CheckHasValue;
    function GetValue: Int64;
    procedure SetValue(const Value: Int64);
    class operator Implicit(const Value: Int64): NullableInt64;
    class operator Implicit(const Value: NullableInt64): Int64;
    property HasValue: Boolean read GetHasValue;
	///<summary>
	///Alias of `SetNull`
	///</summary>
    procedure Clear;
	///<summary>
	///Set the value to `null`
	///</summary>
    procedure SetNull;
	///<summary>
	///Returns the value stored or the default value for the type is the value is not set
	///</summary>	
    function ValueOrDefault: Int64;
	/// <summary>
	/// Returns true is both item have the same value and that value is not null. 
	/// </summary>
	function Equals(const Value: NullableInt64): Boolean;
	///<summary>
	///Returns the value stored or raises exception if no value is stored
	///</summary>	
    property Value: Int64 read GetValue write SetValue;
  end;

//**************************
// ** NullableUInt64
//**************************

  NullableUInt64 = record
  private
    fValue: UInt64;
    fHasValue: String;
    function GetHasValue: Boolean;
  public
    procedure CheckHasValue;
    function GetValue: UInt64;
    procedure SetValue(const Value: UInt64);
    class operator Implicit(const Value: UInt64): NullableUInt64;
    class operator Implicit(const Value: NullableUInt64): UInt64;
    property HasValue: Boolean read GetHasValue;
	///<summary>
	///Alias of `SetNull`
	///</summary>
    procedure Clear;
	///<summary>
	///Set the value to `null`
	///</summary>
    procedure SetNull;
	///<summary>
	///Returns the value stored or the default value for the type is the value is not set
	///</summary>	
    function ValueOrDefault: UInt64;
	/// <summary>
	/// Returns true is both item have the same value and that value is not null. 
	/// </summary>
	function Equals(const Value: NullableUInt64): Boolean;
	///<summary>
	///Returns the value stored or raises exception if no value is stored
	///</summary>	
    property Value: UInt64 read GetValue write SetValue;
  end;


implementation


{ NullableString }

procedure NullableString.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('Value is null');
  end;
end;

procedure NullableString.Clear;
begin
  SetNull;
end;

function NullableString.Equals(const Value: NullableString): Boolean;
begin
  Result := (Self.HasValue and Value.HasValue) and (Self.Value = Value.Value);
end;

function NullableString.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableString.GetValue: String;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableString.Implicit(const Value: NullableString): String;
begin
  Result := Value.Value;
end;

class operator NullableString.Implicit(const Value: String): NullableString;
begin
  Result.Value := Value;
end;

procedure NullableString.SetNull;
begin
  fValue := Default (String);
  fHasValue := '';
end;

procedure NullableString.SetValue(const Value: String);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableString.ValueOrDefault: String;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (String);
  end;
end;



{ NullableCurrency }

procedure NullableCurrency.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('Value is null');
  end;
end;

procedure NullableCurrency.Clear;
begin
  SetNull;
end;

function NullableCurrency.Equals(const Value: NullableCurrency): Boolean;
begin
  Result := (Self.HasValue and Value.HasValue) and (Self.Value = Value.Value);
end;

function NullableCurrency.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableCurrency.GetValue: Currency;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableCurrency.Implicit(const Value: NullableCurrency): Currency;
begin
  Result := Value.Value;
end;

class operator NullableCurrency.Implicit(const Value: Currency): NullableCurrency;
begin
  Result.Value := Value;
end;

procedure NullableCurrency.SetNull;
begin
  fValue := Default (Currency);
  fHasValue := '';
end;

procedure NullableCurrency.SetValue(const Value: Currency);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableCurrency.ValueOrDefault: Currency;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (Currency);
  end;
end;



{ NullableBoolean }

procedure NullableBoolean.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('Value is null');
  end;
end;

procedure NullableBoolean.Clear;
begin
  SetNull;
end;

function NullableBoolean.Equals(const Value: NullableBoolean): Boolean;
begin
  Result := (Self.HasValue and Value.HasValue) and (Self.Value = Value.Value);
end;

function NullableBoolean.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableBoolean.GetValue: Boolean;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableBoolean.Implicit(const Value: NullableBoolean): Boolean;
begin
  Result := Value.Value;
end;

class operator NullableBoolean.Implicit(const Value: Boolean): NullableBoolean;
begin
  Result.Value := Value;
end;

procedure NullableBoolean.SetNull;
begin
  fValue := Default (Boolean);
  fHasValue := '';
end;

procedure NullableBoolean.SetValue(const Value: Boolean);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableBoolean.ValueOrDefault: Boolean;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (Boolean);
  end;
end;



{ NullableTDate }

procedure NullableTDate.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('Value is null');
  end;
end;

procedure NullableTDate.Clear;
begin
  SetNull;
end;

function NullableTDate.Equals(const Value: NullableTDate): Boolean;
begin
  Result := (Self.HasValue and Value.HasValue) and (Self.Value = Value.Value);
end;

function NullableTDate.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableTDate.GetValue: TDate;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableTDate.Implicit(const Value: NullableTDate): TDate;
begin
  Result := Value.Value;
end;

class operator NullableTDate.Implicit(const Value: TDate): NullableTDate;
begin
  Result.Value := Value;
end;

procedure NullableTDate.SetNull;
begin
  fValue := Default (TDate);
  fHasValue := '';
end;

procedure NullableTDate.SetValue(const Value: TDate);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableTDate.ValueOrDefault: TDate;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (TDate);
  end;
end;



{ NullableTTime }

procedure NullableTTime.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('Value is null');
  end;
end;

procedure NullableTTime.Clear;
begin
  SetNull;
end;

function NullableTTime.Equals(const Value: NullableTTime): Boolean;
begin
  Result := (Self.HasValue and Value.HasValue) and (Self.Value = Value.Value);
end;

function NullableTTime.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableTTime.GetValue: TTime;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableTTime.Implicit(const Value: NullableTTime): TTime;
begin
  Result := Value.Value;
end;

class operator NullableTTime.Implicit(const Value: TTime): NullableTTime;
begin
  Result.Value := Value;
end;

procedure NullableTTime.SetNull;
begin
  fValue := Default (TTime);
  fHasValue := '';
end;

procedure NullableTTime.SetValue(const Value: TTime);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableTTime.ValueOrDefault: TTime;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (TTime);
  end;
end;



{ NullableTDateTime }

procedure NullableTDateTime.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('Value is null');
  end;
end;

procedure NullableTDateTime.Clear;
begin
  SetNull;
end;

function NullableTDateTime.Equals(const Value: NullableTDateTime): Boolean;
begin
  Result := (Self.HasValue and Value.HasValue) and (Self.Value = Value.Value);
end;

function NullableTDateTime.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableTDateTime.GetValue: TDateTime;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableTDateTime.Implicit(const Value: NullableTDateTime): TDateTime;
begin
  Result := Value.Value;
end;

class operator NullableTDateTime.Implicit(const Value: TDateTime): NullableTDateTime;
begin
  Result.Value := Value;
end;

procedure NullableTDateTime.SetNull;
begin
  fValue := Default (TDateTime);
  fHasValue := '';
end;

procedure NullableTDateTime.SetValue(const Value: TDateTime);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableTDateTime.ValueOrDefault: TDateTime;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (TDateTime);
  end;
end;



{ NullableSingle }

procedure NullableSingle.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('Value is null');
  end;
end;

procedure NullableSingle.Clear;
begin
  SetNull;
end;

function NullableSingle.Equals(const Value: NullableSingle): Boolean;
begin
  Result := (Self.HasValue and Value.HasValue) and (Self.Value = Value.Value);
end;

function NullableSingle.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableSingle.GetValue: Single;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableSingle.Implicit(const Value: NullableSingle): Single;
begin
  Result := Value.Value;
end;

class operator NullableSingle.Implicit(const Value: Single): NullableSingle;
begin
  Result.Value := Value;
end;

procedure NullableSingle.SetNull;
begin
  fValue := Default (Single);
  fHasValue := '';
end;

procedure NullableSingle.SetValue(const Value: Single);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableSingle.ValueOrDefault: Single;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (Single);
  end;
end;



{ NullableDouble }

procedure NullableDouble.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('Value is null');
  end;
end;

procedure NullableDouble.Clear;
begin
  SetNull;
end;

function NullableDouble.Equals(const Value: NullableDouble): Boolean;
begin
  Result := (Self.HasValue and Value.HasValue) and (Self.Value = Value.Value);
end;

function NullableDouble.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableDouble.GetValue: Double;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableDouble.Implicit(const Value: NullableDouble): Double;
begin
  Result := Value.Value;
end;

class operator NullableDouble.Implicit(const Value: Double): NullableDouble;
begin
  Result.Value := Value;
end;

procedure NullableDouble.SetNull;
begin
  fValue := Default (Double);
  fHasValue := '';
end;

procedure NullableDouble.SetValue(const Value: Double);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableDouble.ValueOrDefault: Double;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (Double);
  end;
end;



{ NullableExtended }

procedure NullableExtended.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('Value is null');
  end;
end;

procedure NullableExtended.Clear;
begin
  SetNull;
end;

function NullableExtended.Equals(const Value: NullableExtended): Boolean;
begin
  Result := (Self.HasValue and Value.HasValue) and (Self.Value = Value.Value);
end;

function NullableExtended.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableExtended.GetValue: Extended;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableExtended.Implicit(const Value: NullableExtended): Extended;
begin
  Result := Value.Value;
end;

class operator NullableExtended.Implicit(const Value: Extended): NullableExtended;
begin
  Result.Value := Value;
end;

procedure NullableExtended.SetNull;
begin
  fValue := Default (Extended);
  fHasValue := '';
end;

procedure NullableExtended.SetValue(const Value: Extended);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableExtended.ValueOrDefault: Extended;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (Extended);
  end;
end;



{ NullableInt16 }

procedure NullableInt16.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('Value is null');
  end;
end;

procedure NullableInt16.Clear;
begin
  SetNull;
end;

function NullableInt16.Equals(const Value: NullableInt16): Boolean;
begin
  Result := (Self.HasValue and Value.HasValue) and (Self.Value = Value.Value);
end;

function NullableInt16.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableInt16.GetValue: Int16;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableInt16.Implicit(const Value: NullableInt16): Int16;
begin
  Result := Value.Value;
end;

class operator NullableInt16.Implicit(const Value: Int16): NullableInt16;
begin
  Result.Value := Value;
end;

procedure NullableInt16.SetNull;
begin
  fValue := Default (Int16);
  fHasValue := '';
end;

procedure NullableInt16.SetValue(const Value: Int16);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableInt16.ValueOrDefault: Int16;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (Int16);
  end;
end;



{ NullableUInt16 }

procedure NullableUInt16.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('Value is null');
  end;
end;

procedure NullableUInt16.Clear;
begin
  SetNull;
end;

function NullableUInt16.Equals(const Value: NullableUInt16): Boolean;
begin
  Result := (Self.HasValue and Value.HasValue) and (Self.Value = Value.Value);
end;

function NullableUInt16.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableUInt16.GetValue: UInt16;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableUInt16.Implicit(const Value: NullableUInt16): UInt16;
begin
  Result := Value.Value;
end;

class operator NullableUInt16.Implicit(const Value: UInt16): NullableUInt16;
begin
  Result.Value := Value;
end;

procedure NullableUInt16.SetNull;
begin
  fValue := Default (UInt16);
  fHasValue := '';
end;

procedure NullableUInt16.SetValue(const Value: UInt16);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableUInt16.ValueOrDefault: UInt16;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (UInt16);
  end;
end;



{ NullableInt32 }

procedure NullableInt32.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('Value is null');
  end;
end;

procedure NullableInt32.Clear;
begin
  SetNull;
end;

function NullableInt32.Equals(const Value: NullableInt32): Boolean;
begin
  Result := (Self.HasValue and Value.HasValue) and (Self.Value = Value.Value);
end;

function NullableInt32.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableInt32.GetValue: Int32;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableInt32.Implicit(const Value: NullableInt32): Int32;
begin
  Result := Value.Value;
end;

class operator NullableInt32.Implicit(const Value: Int32): NullableInt32;
begin
  Result.Value := Value;
end;

procedure NullableInt32.SetNull;
begin
  fValue := Default (Int32);
  fHasValue := '';
end;

procedure NullableInt32.SetValue(const Value: Int32);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableInt32.ValueOrDefault: Int32;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (Int32);
  end;
end;



{ NullableUInt32 }

procedure NullableUInt32.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('Value is null');
  end;
end;

procedure NullableUInt32.Clear;
begin
  SetNull;
end;

function NullableUInt32.Equals(const Value: NullableUInt32): Boolean;
begin
  Result := (Self.HasValue and Value.HasValue) and (Self.Value = Value.Value);
end;

function NullableUInt32.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableUInt32.GetValue: UInt32;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableUInt32.Implicit(const Value: NullableUInt32): UInt32;
begin
  Result := Value.Value;
end;

class operator NullableUInt32.Implicit(const Value: UInt32): NullableUInt32;
begin
  Result.Value := Value;
end;

procedure NullableUInt32.SetNull;
begin
  fValue := Default (UInt32);
  fHasValue := '';
end;

procedure NullableUInt32.SetValue(const Value: UInt32);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableUInt32.ValueOrDefault: UInt32;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (UInt32);
  end;
end;



{ NullableInt64 }

procedure NullableInt64.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('Value is null');
  end;
end;

procedure NullableInt64.Clear;
begin
  SetNull;
end;

function NullableInt64.Equals(const Value: NullableInt64): Boolean;
begin
  Result := (Self.HasValue and Value.HasValue) and (Self.Value = Value.Value);
end;

function NullableInt64.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableInt64.GetValue: Int64;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableInt64.Implicit(const Value: NullableInt64): Int64;
begin
  Result := Value.Value;
end;

class operator NullableInt64.Implicit(const Value: Int64): NullableInt64;
begin
  Result.Value := Value;
end;

procedure NullableInt64.SetNull;
begin
  fValue := Default (Int64);
  fHasValue := '';
end;

procedure NullableInt64.SetValue(const Value: Int64);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableInt64.ValueOrDefault: Int64;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (Int64);
  end;
end;



{ NullableUInt64 }

procedure NullableUInt64.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('Value is null');
  end;
end;

procedure NullableUInt64.Clear;
begin
  SetNull;
end;

function NullableUInt64.Equals(const Value: NullableUInt64): Boolean;
begin
  Result := (Self.HasValue and Value.HasValue) and (Self.Value = Value.Value);
end;

function NullableUInt64.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableUInt64.GetValue: UInt64;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableUInt64.Implicit(const Value: NullableUInt64): UInt64;
begin
  Result := Value.Value;
end;

class operator NullableUInt64.Implicit(const Value: UInt64): NullableUInt64;
begin
  Result.Value := Value;
end;

procedure NullableUInt64.SetNull;
begin
  fValue := Default (UInt64);
  fHasValue := '';
end;

procedure NullableUInt64.SetValue(const Value: UInt64);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableUInt64.ValueOrDefault: UInt64;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (UInt64);
  end;
end;



end.
