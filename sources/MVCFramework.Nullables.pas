// ***************************************************************************
// 
// THIS FILE IS GENERATED BY "inv generate-nullables" DO NOT CHANGE MANUALLY!
// 
// ***************************************************************************
//
// *************************************************************************** }
//
// Delphi MVC Framework
//
// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team
//
// https://github.com/danieleteti/delphimvcframework
//
// ***************************************************************************
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


unit MVCFramework.Nullables;

{$IF CompilerVersion >= 35} // 11 Alexandria
{$DEFINE USE_EQUALS}
{$ENDIF}

interface

uses
  System.SysUtils, System.Classes, System.TypInfo, System.RTTI;

type
  EMVCNullable = class(Exception)

  end;

{$IF CompilerVersion <= 32} // 10.2 Tokyo
  Float32 = Single;
  Float64 = Double;
{$IFEND}

//**************************************************************************************************************
//** Nullable<T> -- In case of generic-types Delphi compiler generates different RTTI information for each BPL
//**                To de/serialize a Nullable<T> is required a CustomTypeSerializer
//**************************************************************************************************************

  Nullable<T> = record
  private
    fValue: T;
    fHasValue: String;
    function GetHasValue: Boolean;
	function GetIsNull: Boolean;	
  public
    procedure CheckHasValue;
    function GetValue: T;
    procedure SetValue(const Value: T);
    class operator Implicit(const Value: T): Nullable<T>; overload;
    class operator Implicit(const Value: Nullable<T>): T; overload;
    class operator Implicit(const Value: Pointer): Nullable<T>; overload;
	  class operator Equal(LeftValue: Nullable<T>; RightValue: Nullable<T>) : Boolean;	
    ///<summary>
    ///Returns `True` if the Nullable<T> contains a value
    ///</summary>	
    property HasValue: Boolean read GetHasValue;
    ///<summary>
    ///Returns `True` if the Nullable<T> contains a null
    ///</summary>	
    property IsNull: Boolean read GetIsNull;	
    ///<summary>
    ///Alias of `SetNull`
    ///</summary>
    procedure Clear;
    ///<summary>
    ///Set the value to `null`
    ///</summary>
    procedure SetNull;
    ///<summary>
    ///Returns the value stored or the default value for the type if the value is not set
    ///</summary>	
    function ValueOrDefault: T;
    ///<summary>
    ///Returns the value stored or else the value passed as parameter if the value is not set
    ///</summary>	
    function ValueOrElse(const ElseValue: T): T;
    /// <summary>
    /// Returns true is both item have the same value and that value is not null. 
    /// </summary>
    function Equals(const Value: Nullable<T>): Boolean;    
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: T): Boolean; overload;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: TValue): Boolean; overload;
    ///<summary>
    ///Returns the value stored or raises exception if no value is stored
    ///</summary>	
    property Value: T read GetValue write SetValue;
  end;

//**************************
// ** NullableAnsiString
//**************************

  NullableAnsiString = record
  private
    fValue: AnsiString;
    fHasValue: String;
    function GetHasValue: Boolean;
	  function GetIsNull: Boolean;	
  public
    procedure CheckHasValue;
    function GetValue: AnsiString;
    procedure SetValue(const Value: AnsiString);
    class operator Implicit(const Value: AnsiString): NullableAnsiString;
    class operator Implicit(const Value: NullableAnsiString): AnsiString;
    class operator Implicit(const Value: Pointer): NullableAnsiString;	
	  class operator Equal(LeftValue: NullableAnsiString; RightValue: NullableAnsiString) : Boolean;	
    ///<summary>
    ///Returns `True` if the NullableAnsiString contains a value
    ///</summary>	
    property HasValue: Boolean read GetHasValue;
    ///<summary>
    ///Returns `True` if the NullableAnsiString contains a null
    ///</summary>	
    property IsNull: Boolean read GetIsNull;	
    ///<summary>
    ///Alias of `SetNull`
    ///</summary>
    procedure Clear;
    ///<summary>
    ///Set the value to `null`
    ///</summary>
    procedure SetNull;
    ///<summary>
    ///Returns the value stored or the default value for the type if the value is not set
    ///</summary>	
    function ValueOrDefault: AnsiString;
    ///<summary>
    ///Returns the value stored or else the value passed as parameter if the value is not set
    ///</summary>	
    function ValueOrElse(const ElseValue: AnsiString): AnsiString;    
    /// <summary>
    /// Returns true is both item have the same value and that value is not null. 
    /// </summary>
    function Equals(const Value: NullableAnsiString): Boolean;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: AnsiString): Boolean; overload;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: TValue): Boolean; overload;
    ///<summary>
    ///Returns the value stored or raises exception if no value is stored
    ///</summary>	
    property Value: AnsiString read GetValue write SetValue;
  end;

//**************************
// ** NullableString
//**************************

  NullableString = record
  private
    fValue: String;
    fHasValue: String;
    function GetHasValue: Boolean;
	  function GetIsNull: Boolean;	
  public
    procedure CheckHasValue;
    function GetValue: String;
    procedure SetValue(const Value: String);
    class operator Implicit(const Value: String): NullableString;
    class operator Implicit(const Value: NullableString): String;
    class operator Implicit(const Value: Pointer): NullableString;	
	  class operator Equal(LeftValue: NullableString; RightValue: NullableString) : Boolean;	
    ///<summary>
    ///Returns `True` if the NullableString contains a value
    ///</summary>	
    property HasValue: Boolean read GetHasValue;
    ///<summary>
    ///Returns `True` if the NullableString contains a null
    ///</summary>	
    property IsNull: Boolean read GetIsNull;	
    ///<summary>
    ///Alias of `SetNull`
    ///</summary>
    procedure Clear;
    ///<summary>
    ///Set the value to `null`
    ///</summary>
    procedure SetNull;
    ///<summary>
    ///Returns the value stored or the default value for the type if the value is not set
    ///</summary>	
    function ValueOrDefault: String;
    ///<summary>
    ///Returns the value stored or else the value passed as parameter if the value is not set
    ///</summary>	
    function ValueOrElse(const ElseValue: String): String;    
    /// <summary>
    /// Returns true is both item have the same value and that value is not null. 
    /// </summary>
    function Equals(const Value: NullableString): Boolean;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: String): Boolean; overload;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: TValue): Boolean; overload;
    ///<summary>
    ///Returns the value stored or raises exception if no value is stored
    ///</summary>	
    property Value: String read GetValue write SetValue;
  end;

//**************************
// ** NullableCurrency
//**************************

  NullableCurrency = record
  private
    fValue: Currency;
    fHasValue: String;
    function GetHasValue: Boolean;
	  function GetIsNull: Boolean;	
  public
    procedure CheckHasValue;
    function GetValue: Currency;
    procedure SetValue(const Value: Currency);
    class operator Implicit(const Value: Currency): NullableCurrency;
    class operator Implicit(const Value: NullableCurrency): Currency;
    class operator Implicit(const Value: Pointer): NullableCurrency;	
	  class operator Equal(LeftValue: NullableCurrency; RightValue: NullableCurrency) : Boolean;	
    ///<summary>
    ///Returns `True` if the NullableCurrency contains a value
    ///</summary>	
    property HasValue: Boolean read GetHasValue;
    ///<summary>
    ///Returns `True` if the NullableCurrency contains a null
    ///</summary>	
    property IsNull: Boolean read GetIsNull;	
    ///<summary>
    ///Alias of `SetNull`
    ///</summary>
    procedure Clear;
    ///<summary>
    ///Set the value to `null`
    ///</summary>
    procedure SetNull;
    ///<summary>
    ///Returns the value stored or the default value for the type if the value is not set
    ///</summary>	
    function ValueOrDefault: Currency;
    ///<summary>
    ///Returns the value stored or else the value passed as parameter if the value is not set
    ///</summary>	
    function ValueOrElse(const ElseValue: Currency): Currency;    
    /// <summary>
    /// Returns true is both item have the same value and that value is not null. 
    /// </summary>
    function Equals(const Value: NullableCurrency): Boolean;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: Currency): Boolean; overload;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: TValue): Boolean; overload;
    ///<summary>
    ///Returns the value stored or raises exception if no value is stored
    ///</summary>	
    property Value: Currency read GetValue write SetValue;
  end;

//**************************
// ** NullableBoolean
//**************************

  NullableBoolean = record
  private
    fValue: Boolean;
    fHasValue: String;
    function GetHasValue: Boolean;
	  function GetIsNull: Boolean;	
  public
    procedure CheckHasValue;
    function GetValue: Boolean;
    procedure SetValue(const Value: Boolean);
    class operator Implicit(const Value: Boolean): NullableBoolean;
    class operator Implicit(const Value: NullableBoolean): Boolean;
    class operator Implicit(const Value: Pointer): NullableBoolean;	
	  class operator Equal(LeftValue: NullableBoolean; RightValue: NullableBoolean) : Boolean;	
    ///<summary>
    ///Returns `True` if the NullableBoolean contains a value
    ///</summary>	
    property HasValue: Boolean read GetHasValue;
    ///<summary>
    ///Returns `True` if the NullableBoolean contains a null
    ///</summary>	
    property IsNull: Boolean read GetIsNull;	
    ///<summary>
    ///Alias of `SetNull`
    ///</summary>
    procedure Clear;
    ///<summary>
    ///Set the value to `null`
    ///</summary>
    procedure SetNull;
    ///<summary>
    ///Returns the value stored or the default value for the type if the value is not set
    ///</summary>	
    function ValueOrDefault: Boolean;
    ///<summary>
    ///Returns the value stored or else the value passed as parameter if the value is not set
    ///</summary>	
    function ValueOrElse(const ElseValue: Boolean): Boolean;    
    /// <summary>
    /// Returns true is both item have the same value and that value is not null. 
    /// </summary>
    function Equals(const Value: NullableBoolean): Boolean;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: Boolean): Boolean; overload;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: TValue): Boolean; overload;
    ///<summary>
    ///Returns the value stored or raises exception if no value is stored
    ///</summary>	
    property Value: Boolean read GetValue write SetValue;
  end;

//**************************
// ** NullableTDate
//**************************

  NullableTDate = record
  private
    fValue: TDate;
    fHasValue: String;
    function GetHasValue: Boolean;
	  function GetIsNull: Boolean;	
  public
    procedure CheckHasValue;
    function GetValue: TDate;
    procedure SetValue(const Value: TDate);
    class operator Implicit(const Value: TDate): NullableTDate;
    class operator Implicit(const Value: NullableTDate): TDate;
    class operator Implicit(const Value: Pointer): NullableTDate;	
	  class operator Equal(LeftValue: NullableTDate; RightValue: NullableTDate) : Boolean;	
    ///<summary>
    ///Returns `True` if the NullableTDate contains a value
    ///</summary>	
    property HasValue: Boolean read GetHasValue;
    ///<summary>
    ///Returns `True` if the NullableTDate contains a null
    ///</summary>	
    property IsNull: Boolean read GetIsNull;	
    ///<summary>
    ///Alias of `SetNull`
    ///</summary>
    procedure Clear;
    ///<summary>
    ///Set the value to `null`
    ///</summary>
    procedure SetNull;
    ///<summary>
    ///Returns the value stored or the default value for the type if the value is not set
    ///</summary>	
    function ValueOrDefault: TDate;
    ///<summary>
    ///Returns the value stored or else the value passed as parameter if the value is not set
    ///</summary>	
    function ValueOrElse(const ElseValue: TDate): TDate;    
    /// <summary>
    /// Returns true is both item have the same value and that value is not null. 
    /// </summary>
    function Equals(const Value: NullableTDate): Boolean;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: TDate): Boolean; overload;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: TValue): Boolean; overload;
    ///<summary>
    ///Returns the value stored or raises exception if no value is stored
    ///</summary>	
    property Value: TDate read GetValue write SetValue;
  end;

//**************************
// ** NullableTTime
//**************************

  NullableTTime = record
  private
    fValue: TTime;
    fHasValue: String;
    function GetHasValue: Boolean;
	  function GetIsNull: Boolean;	
  public
    procedure CheckHasValue;
    function GetValue: TTime;
    procedure SetValue(const Value: TTime);
    class operator Implicit(const Value: TTime): NullableTTime;
    class operator Implicit(const Value: NullableTTime): TTime;
    class operator Implicit(const Value: Pointer): NullableTTime;	
	  class operator Equal(LeftValue: NullableTTime; RightValue: NullableTTime) : Boolean;	
    ///<summary>
    ///Returns `True` if the NullableTTime contains a value
    ///</summary>	
    property HasValue: Boolean read GetHasValue;
    ///<summary>
    ///Returns `True` if the NullableTTime contains a null
    ///</summary>	
    property IsNull: Boolean read GetIsNull;	
    ///<summary>
    ///Alias of `SetNull`
    ///</summary>
    procedure Clear;
    ///<summary>
    ///Set the value to `null`
    ///</summary>
    procedure SetNull;
    ///<summary>
    ///Returns the value stored or the default value for the type if the value is not set
    ///</summary>	
    function ValueOrDefault: TTime;
    ///<summary>
    ///Returns the value stored or else the value passed as parameter if the value is not set
    ///</summary>	
    function ValueOrElse(const ElseValue: TTime): TTime;    
    /// <summary>
    /// Returns true is both item have the same value and that value is not null. 
    /// </summary>
    function Equals(const Value: NullableTTime): Boolean;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: TTime): Boolean; overload;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: TValue): Boolean; overload;
    ///<summary>
    ///Returns the value stored or raises exception if no value is stored
    ///</summary>	
    property Value: TTime read GetValue write SetValue;
  end;

//**************************
// ** NullableTDateTime
//**************************

  NullableTDateTime = record
  private
    fValue: TDateTime;
    fHasValue: String;
    function GetHasValue: Boolean;
	  function GetIsNull: Boolean;	
  public
    procedure CheckHasValue;
    function GetValue: TDateTime;
    procedure SetValue(const Value: TDateTime);
    class operator Implicit(const Value: TDateTime): NullableTDateTime;
    class operator Implicit(const Value: NullableTDateTime): TDateTime;
    class operator Implicit(const Value: Pointer): NullableTDateTime;	
	  class operator Equal(LeftValue: NullableTDateTime; RightValue: NullableTDateTime) : Boolean;	
    ///<summary>
    ///Returns `True` if the NullableTDateTime contains a value
    ///</summary>	
    property HasValue: Boolean read GetHasValue;
    ///<summary>
    ///Returns `True` if the NullableTDateTime contains a null
    ///</summary>	
    property IsNull: Boolean read GetIsNull;	
    ///<summary>
    ///Alias of `SetNull`
    ///</summary>
    procedure Clear;
    ///<summary>
    ///Set the value to `null`
    ///</summary>
    procedure SetNull;
    ///<summary>
    ///Returns the value stored or the default value for the type if the value is not set
    ///</summary>	
    function ValueOrDefault: TDateTime;
    ///<summary>
    ///Returns the value stored or else the value passed as parameter if the value is not set
    ///</summary>	
    function ValueOrElse(const ElseValue: TDateTime): TDateTime;    
    /// <summary>
    /// Returns true is both item have the same value and that value is not null. 
    /// </summary>
    function Equals(const Value: NullableTDateTime): Boolean;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: TDateTime): Boolean; overload;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: TValue): Boolean; overload;
    ///<summary>
    ///Returns the value stored or raises exception if no value is stored
    ///</summary>	
    property Value: TDateTime read GetValue write SetValue;
  end;

//**************************
// ** NullableSingle
//**************************

  NullableSingle = record
  private
    fValue: Single;
    fHasValue: String;
    function GetHasValue: Boolean;
	  function GetIsNull: Boolean;	
  public
    procedure CheckHasValue;
    function GetValue: Single;
    procedure SetValue(const Value: Single);
    class operator Implicit(const Value: Single): NullableSingle;
    class operator Implicit(const Value: NullableSingle): Single;
    class operator Implicit(const Value: Pointer): NullableSingle;	
	  class operator Equal(LeftValue: NullableSingle; RightValue: NullableSingle) : Boolean;	
    ///<summary>
    ///Returns `True` if the NullableSingle contains a value
    ///</summary>	
    property HasValue: Boolean read GetHasValue;
    ///<summary>
    ///Returns `True` if the NullableSingle contains a null
    ///</summary>	
    property IsNull: Boolean read GetIsNull;	
    ///<summary>
    ///Alias of `SetNull`
    ///</summary>
    procedure Clear;
    ///<summary>
    ///Set the value to `null`
    ///</summary>
    procedure SetNull;
    ///<summary>
    ///Returns the value stored or the default value for the type if the value is not set
    ///</summary>	
    function ValueOrDefault: Single;
    ///<summary>
    ///Returns the value stored or else the value passed as parameter if the value is not set
    ///</summary>	
    function ValueOrElse(const ElseValue: Single): Single;    
    /// <summary>
    /// Returns true is both item have the same value and that value is not null. 
    /// </summary>
    function Equals(const Value: NullableSingle): Boolean;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: Single): Boolean; overload;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: TValue): Boolean; overload;
    ///<summary>
    ///Returns the value stored or raises exception if no value is stored
    ///</summary>	
    property Value: Single read GetValue write SetValue;
  end;

//**************************
// ** NullableDouble
//**************************

  NullableDouble = record
  private
    fValue: Double;
    fHasValue: String;
    function GetHasValue: Boolean;
	  function GetIsNull: Boolean;	
  public
    procedure CheckHasValue;
    function GetValue: Double;
    procedure SetValue(const Value: Double);
    class operator Implicit(const Value: Double): NullableDouble;
    class operator Implicit(const Value: NullableDouble): Double;
    class operator Implicit(const Value: Pointer): NullableDouble;	
	  class operator Equal(LeftValue: NullableDouble; RightValue: NullableDouble) : Boolean;	
    ///<summary>
    ///Returns `True` if the NullableDouble contains a value
    ///</summary>	
    property HasValue: Boolean read GetHasValue;
    ///<summary>
    ///Returns `True` if the NullableDouble contains a null
    ///</summary>	
    property IsNull: Boolean read GetIsNull;	
    ///<summary>
    ///Alias of `SetNull`
    ///</summary>
    procedure Clear;
    ///<summary>
    ///Set the value to `null`
    ///</summary>
    procedure SetNull;
    ///<summary>
    ///Returns the value stored or the default value for the type if the value is not set
    ///</summary>	
    function ValueOrDefault: Double;
    ///<summary>
    ///Returns the value stored or else the value passed as parameter if the value is not set
    ///</summary>	
    function ValueOrElse(const ElseValue: Double): Double;    
    /// <summary>
    /// Returns true is both item have the same value and that value is not null. 
    /// </summary>
    function Equals(const Value: NullableDouble): Boolean;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: Double): Boolean; overload;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: TValue): Boolean; overload;
    ///<summary>
    ///Returns the value stored or raises exception if no value is stored
    ///</summary>	
    property Value: Double read GetValue write SetValue;
  end;

//**************************
// ** NullableFloat32
//**************************

  NullableFloat32 = record
  private
    fValue: Float32;
    fHasValue: String;
    function GetHasValue: Boolean;
	  function GetIsNull: Boolean;	
  public
    procedure CheckHasValue;
    function GetValue: Float32;
    procedure SetValue(const Value: Float32);
    class operator Implicit(const Value: Float32): NullableFloat32;
    class operator Implicit(const Value: NullableFloat32): Float32;
    class operator Implicit(const Value: Pointer): NullableFloat32;	
	  class operator Equal(LeftValue: NullableFloat32; RightValue: NullableFloat32) : Boolean;	
    ///<summary>
    ///Returns `True` if the NullableFloat32 contains a value
    ///</summary>	
    property HasValue: Boolean read GetHasValue;
    ///<summary>
    ///Returns `True` if the NullableFloat32 contains a null
    ///</summary>	
    property IsNull: Boolean read GetIsNull;	
    ///<summary>
    ///Alias of `SetNull`
    ///</summary>
    procedure Clear;
    ///<summary>
    ///Set the value to `null`
    ///</summary>
    procedure SetNull;
    ///<summary>
    ///Returns the value stored or the default value for the type if the value is not set
    ///</summary>	
    function ValueOrDefault: Float32;
    ///<summary>
    ///Returns the value stored or else the value passed as parameter if the value is not set
    ///</summary>	
    function ValueOrElse(const ElseValue: Float32): Float32;    
    /// <summary>
    /// Returns true is both item have the same value and that value is not null. 
    /// </summary>
    function Equals(const Value: NullableFloat32): Boolean;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: Float32): Boolean; overload;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: TValue): Boolean; overload;
    ///<summary>
    ///Returns the value stored or raises exception if no value is stored
    ///</summary>	
    property Value: Float32 read GetValue write SetValue;
  end;

//**************************
// ** NullableFloat64
//**************************

  NullableFloat64 = record
  private
    fValue: Float64;
    fHasValue: String;
    function GetHasValue: Boolean;
	  function GetIsNull: Boolean;	
  public
    procedure CheckHasValue;
    function GetValue: Float64;
    procedure SetValue(const Value: Float64);
    class operator Implicit(const Value: Float64): NullableFloat64;
    class operator Implicit(const Value: NullableFloat64): Float64;
    class operator Implicit(const Value: Pointer): NullableFloat64;	
	  class operator Equal(LeftValue: NullableFloat64; RightValue: NullableFloat64) : Boolean;	
    ///<summary>
    ///Returns `True` if the NullableFloat64 contains a value
    ///</summary>	
    property HasValue: Boolean read GetHasValue;
    ///<summary>
    ///Returns `True` if the NullableFloat64 contains a null
    ///</summary>	
    property IsNull: Boolean read GetIsNull;	
    ///<summary>
    ///Alias of `SetNull`
    ///</summary>
    procedure Clear;
    ///<summary>
    ///Set the value to `null`
    ///</summary>
    procedure SetNull;
    ///<summary>
    ///Returns the value stored or the default value for the type if the value is not set
    ///</summary>	
    function ValueOrDefault: Float64;
    ///<summary>
    ///Returns the value stored or else the value passed as parameter if the value is not set
    ///</summary>	
    function ValueOrElse(const ElseValue: Float64): Float64;    
    /// <summary>
    /// Returns true is both item have the same value and that value is not null. 
    /// </summary>
    function Equals(const Value: NullableFloat64): Boolean;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: Float64): Boolean; overload;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: TValue): Boolean; overload;
    ///<summary>
    ///Returns the value stored or raises exception if no value is stored
    ///</summary>	
    property Value: Float64 read GetValue write SetValue;
  end;

//**************************
// ** NullableExtended
//**************************

  NullableExtended = record
  private
    fValue: Extended;
    fHasValue: String;
    function GetHasValue: Boolean;
	  function GetIsNull: Boolean;	
  public
    procedure CheckHasValue;
    function GetValue: Extended;
    procedure SetValue(const Value: Extended);
    class operator Implicit(const Value: Extended): NullableExtended;
    class operator Implicit(const Value: NullableExtended): Extended;
    class operator Implicit(const Value: Pointer): NullableExtended;	
	  class operator Equal(LeftValue: NullableExtended; RightValue: NullableExtended) : Boolean;	
    ///<summary>
    ///Returns `True` if the NullableExtended contains a value
    ///</summary>	
    property HasValue: Boolean read GetHasValue;
    ///<summary>
    ///Returns `True` if the NullableExtended contains a null
    ///</summary>	
    property IsNull: Boolean read GetIsNull;	
    ///<summary>
    ///Alias of `SetNull`
    ///</summary>
    procedure Clear;
    ///<summary>
    ///Set the value to `null`
    ///</summary>
    procedure SetNull;
    ///<summary>
    ///Returns the value stored or the default value for the type if the value is not set
    ///</summary>	
    function ValueOrDefault: Extended;
    ///<summary>
    ///Returns the value stored or else the value passed as parameter if the value is not set
    ///</summary>	
    function ValueOrElse(const ElseValue: Extended): Extended;    
    /// <summary>
    /// Returns true is both item have the same value and that value is not null. 
    /// </summary>
    function Equals(const Value: NullableExtended): Boolean;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: Extended): Boolean; overload;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: TValue): Boolean; overload;
    ///<summary>
    ///Returns the value stored or raises exception if no value is stored
    ///</summary>	
    property Value: Extended read GetValue write SetValue;
  end;

//**************************
// ** NullableInt8
//**************************

  NullableInt8 = record
  private
    fValue: Int8;
    fHasValue: String;
    function GetHasValue: Boolean;
	  function GetIsNull: Boolean;	
  public
    procedure CheckHasValue;
    function GetValue: Int8;
    procedure SetValue(const Value: Int8);
    class operator Implicit(const Value: Int8): NullableInt8;
    class operator Implicit(const Value: NullableInt8): Int8;
    class operator Implicit(const Value: Pointer): NullableInt8;	
	  class operator Equal(LeftValue: NullableInt8; RightValue: NullableInt8) : Boolean;	
    ///<summary>
    ///Returns `True` if the NullableInt8 contains a value
    ///</summary>	
    property HasValue: Boolean read GetHasValue;
    ///<summary>
    ///Returns `True` if the NullableInt8 contains a null
    ///</summary>	
    property IsNull: Boolean read GetIsNull;	
    ///<summary>
    ///Alias of `SetNull`
    ///</summary>
    procedure Clear;
    ///<summary>
    ///Set the value to `null`
    ///</summary>
    procedure SetNull;
    ///<summary>
    ///Returns the value stored or the default value for the type if the value is not set
    ///</summary>	
    function ValueOrDefault: Int8;
    ///<summary>
    ///Returns the value stored or else the value passed as parameter if the value is not set
    ///</summary>	
    function ValueOrElse(const ElseValue: Int8): Int8;    
    /// <summary>
    /// Returns true is both item have the same value and that value is not null. 
    /// </summary>
    function Equals(const Value: NullableInt8): Boolean;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: Int8): Boolean; overload;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: TValue): Boolean; overload;
    ///<summary>
    ///Returns the value stored or raises exception if no value is stored
    ///</summary>	
    property Value: Int8 read GetValue write SetValue;
  end;

//**************************
// ** NullableUInt8
//**************************

  NullableUInt8 = record
  private
    fValue: UInt8;
    fHasValue: String;
    function GetHasValue: Boolean;
	  function GetIsNull: Boolean;	
  public
    procedure CheckHasValue;
    function GetValue: UInt8;
    procedure SetValue(const Value: UInt8);
    class operator Implicit(const Value: UInt8): NullableUInt8;
    class operator Implicit(const Value: NullableUInt8): UInt8;
    class operator Implicit(const Value: Pointer): NullableUInt8;	
	  class operator Equal(LeftValue: NullableUInt8; RightValue: NullableUInt8) : Boolean;	
    ///<summary>
    ///Returns `True` if the NullableUInt8 contains a value
    ///</summary>	
    property HasValue: Boolean read GetHasValue;
    ///<summary>
    ///Returns `True` if the NullableUInt8 contains a null
    ///</summary>	
    property IsNull: Boolean read GetIsNull;	
    ///<summary>
    ///Alias of `SetNull`
    ///</summary>
    procedure Clear;
    ///<summary>
    ///Set the value to `null`
    ///</summary>
    procedure SetNull;
    ///<summary>
    ///Returns the value stored or the default value for the type if the value is not set
    ///</summary>	
    function ValueOrDefault: UInt8;
    ///<summary>
    ///Returns the value stored or else the value passed as parameter if the value is not set
    ///</summary>	
    function ValueOrElse(const ElseValue: UInt8): UInt8;    
    /// <summary>
    /// Returns true is both item have the same value and that value is not null. 
    /// </summary>
    function Equals(const Value: NullableUInt8): Boolean;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: UInt8): Boolean; overload;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: TValue): Boolean; overload;
    ///<summary>
    ///Returns the value stored or raises exception if no value is stored
    ///</summary>	
    property Value: UInt8 read GetValue write SetValue;
  end;

//**************************
// ** NullableByte
//**************************

  NullableByte = record
  private
    fValue: Byte;
    fHasValue: String;
    function GetHasValue: Boolean;
	  function GetIsNull: Boolean;	
  public
    procedure CheckHasValue;
    function GetValue: Byte;
    procedure SetValue(const Value: Byte);
    class operator Implicit(const Value: Byte): NullableByte;
    class operator Implicit(const Value: NullableByte): Byte;
    class operator Implicit(const Value: Pointer): NullableByte;	
	  class operator Equal(LeftValue: NullableByte; RightValue: NullableByte) : Boolean;	
    ///<summary>
    ///Returns `True` if the NullableByte contains a value
    ///</summary>	
    property HasValue: Boolean read GetHasValue;
    ///<summary>
    ///Returns `True` if the NullableByte contains a null
    ///</summary>	
    property IsNull: Boolean read GetIsNull;	
    ///<summary>
    ///Alias of `SetNull`
    ///</summary>
    procedure Clear;
    ///<summary>
    ///Set the value to `null`
    ///</summary>
    procedure SetNull;
    ///<summary>
    ///Returns the value stored or the default value for the type if the value is not set
    ///</summary>	
    function ValueOrDefault: Byte;
    ///<summary>
    ///Returns the value stored or else the value passed as parameter if the value is not set
    ///</summary>	
    function ValueOrElse(const ElseValue: Byte): Byte;    
    /// <summary>
    /// Returns true is both item have the same value and that value is not null. 
    /// </summary>
    function Equals(const Value: NullableByte): Boolean;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: Byte): Boolean; overload;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: TValue): Boolean; overload;
    ///<summary>
    ///Returns the value stored or raises exception if no value is stored
    ///</summary>	
    property Value: Byte read GetValue write SetValue;
  end;

//**************************
// ** NullableInt16
//**************************

  NullableInt16 = record
  private
    fValue: Int16;
    fHasValue: String;
    function GetHasValue: Boolean;
	  function GetIsNull: Boolean;	
  public
    procedure CheckHasValue;
    function GetValue: Int16;
    procedure SetValue(const Value: Int16);
    class operator Implicit(const Value: Int16): NullableInt16;
    class operator Implicit(const Value: NullableInt16): Int16;
    class operator Implicit(const Value: Pointer): NullableInt16;	
	  class operator Equal(LeftValue: NullableInt16; RightValue: NullableInt16) : Boolean;	
    ///<summary>
    ///Returns `True` if the NullableInt16 contains a value
    ///</summary>	
    property HasValue: Boolean read GetHasValue;
    ///<summary>
    ///Returns `True` if the NullableInt16 contains a null
    ///</summary>	
    property IsNull: Boolean read GetIsNull;	
    ///<summary>
    ///Alias of `SetNull`
    ///</summary>
    procedure Clear;
    ///<summary>
    ///Set the value to `null`
    ///</summary>
    procedure SetNull;
    ///<summary>
    ///Returns the value stored or the default value for the type if the value is not set
    ///</summary>	
    function ValueOrDefault: Int16;
    ///<summary>
    ///Returns the value stored or else the value passed as parameter if the value is not set
    ///</summary>	
    function ValueOrElse(const ElseValue: Int16): Int16;    
    /// <summary>
    /// Returns true is both item have the same value and that value is not null. 
    /// </summary>
    function Equals(const Value: NullableInt16): Boolean;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: Int16): Boolean; overload;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: TValue): Boolean; overload;
    ///<summary>
    ///Returns the value stored or raises exception if no value is stored
    ///</summary>	
    property Value: Int16 read GetValue write SetValue;
  end;

//**************************
// ** NullableUInt16
//**************************

  NullableUInt16 = record
  private
    fValue: UInt16;
    fHasValue: String;
    function GetHasValue: Boolean;
	  function GetIsNull: Boolean;	
  public
    procedure CheckHasValue;
    function GetValue: UInt16;
    procedure SetValue(const Value: UInt16);
    class operator Implicit(const Value: UInt16): NullableUInt16;
    class operator Implicit(const Value: NullableUInt16): UInt16;
    class operator Implicit(const Value: Pointer): NullableUInt16;	
	  class operator Equal(LeftValue: NullableUInt16; RightValue: NullableUInt16) : Boolean;	
    ///<summary>
    ///Returns `True` if the NullableUInt16 contains a value
    ///</summary>	
    property HasValue: Boolean read GetHasValue;
    ///<summary>
    ///Returns `True` if the NullableUInt16 contains a null
    ///</summary>	
    property IsNull: Boolean read GetIsNull;	
    ///<summary>
    ///Alias of `SetNull`
    ///</summary>
    procedure Clear;
    ///<summary>
    ///Set the value to `null`
    ///</summary>
    procedure SetNull;
    ///<summary>
    ///Returns the value stored or the default value for the type if the value is not set
    ///</summary>	
    function ValueOrDefault: UInt16;
    ///<summary>
    ///Returns the value stored or else the value passed as parameter if the value is not set
    ///</summary>	
    function ValueOrElse(const ElseValue: UInt16): UInt16;    
    /// <summary>
    /// Returns true is both item have the same value and that value is not null. 
    /// </summary>
    function Equals(const Value: NullableUInt16): Boolean;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: UInt16): Boolean; overload;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: TValue): Boolean; overload;
    ///<summary>
    ///Returns the value stored or raises exception if no value is stored
    ///</summary>	
    property Value: UInt16 read GetValue write SetValue;
  end;

//**************************
// ** NullableInt32
//**************************

  NullableInt32 = record
  private
    fValue: Int32;
    fHasValue: String;
    function GetHasValue: Boolean;
	  function GetIsNull: Boolean;	
  public
    procedure CheckHasValue;
    function GetValue: Int32;
    procedure SetValue(const Value: Int32);
    class operator Implicit(const Value: Int32): NullableInt32;
    class operator Implicit(const Value: NullableInt32): Int32;
    class operator Implicit(const Value: Pointer): NullableInt32;	
	  class operator Equal(LeftValue: NullableInt32; RightValue: NullableInt32) : Boolean;	
    ///<summary>
    ///Returns `True` if the NullableInt32 contains a value
    ///</summary>	
    property HasValue: Boolean read GetHasValue;
    ///<summary>
    ///Returns `True` if the NullableInt32 contains a null
    ///</summary>	
    property IsNull: Boolean read GetIsNull;	
    ///<summary>
    ///Alias of `SetNull`
    ///</summary>
    procedure Clear;
    ///<summary>
    ///Set the value to `null`
    ///</summary>
    procedure SetNull;
    ///<summary>
    ///Returns the value stored or the default value for the type if the value is not set
    ///</summary>	
    function ValueOrDefault: Int32;
    ///<summary>
    ///Returns the value stored or else the value passed as parameter if the value is not set
    ///</summary>	
    function ValueOrElse(const ElseValue: Int32): Int32;    
    /// <summary>
    /// Returns true is both item have the same value and that value is not null. 
    /// </summary>
    function Equals(const Value: NullableInt32): Boolean;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: Int32): Boolean; overload;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: TValue): Boolean; overload;
    ///<summary>
    ///Returns the value stored or raises exception if no value is stored
    ///</summary>	
    property Value: Int32 read GetValue write SetValue;
  end;

//**************************
// ** NullableInteger
//**************************

  NullableInteger = record
  private
    fValue: Integer;
    fHasValue: String;
    function GetHasValue: Boolean;
	  function GetIsNull: Boolean;	
  public
    procedure CheckHasValue;
    function GetValue: Integer;
    procedure SetValue(const Value: Integer);
    class operator Implicit(const Value: Integer): NullableInteger;
    class operator Implicit(const Value: NullableInteger): Integer;
    class operator Implicit(const Value: Pointer): NullableInteger;	
	  class operator Equal(LeftValue: NullableInteger; RightValue: NullableInteger) : Boolean;	
    ///<summary>
    ///Returns `True` if the NullableInteger contains a value
    ///</summary>	
    property HasValue: Boolean read GetHasValue;
    ///<summary>
    ///Returns `True` if the NullableInteger contains a null
    ///</summary>	
    property IsNull: Boolean read GetIsNull;	
    ///<summary>
    ///Alias of `SetNull`
    ///</summary>
    procedure Clear;
    ///<summary>
    ///Set the value to `null`
    ///</summary>
    procedure SetNull;
    ///<summary>
    ///Returns the value stored or the default value for the type if the value is not set
    ///</summary>	
    function ValueOrDefault: Integer;
    ///<summary>
    ///Returns the value stored or else the value passed as parameter if the value is not set
    ///</summary>	
    function ValueOrElse(const ElseValue: Integer): Integer;    
    /// <summary>
    /// Returns true is both item have the same value and that value is not null. 
    /// </summary>
    function Equals(const Value: NullableInteger): Boolean;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: Integer): Boolean; overload;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: TValue): Boolean; overload;
    ///<summary>
    ///Returns the value stored or raises exception if no value is stored
    ///</summary>	
    property Value: Integer read GetValue write SetValue;
  end;

//**************************
// ** NullableUInt32
//**************************

  NullableUInt32 = record
  private
    fValue: UInt32;
    fHasValue: String;
    function GetHasValue: Boolean;
	  function GetIsNull: Boolean;	
  public
    procedure CheckHasValue;
    function GetValue: UInt32;
    procedure SetValue(const Value: UInt32);
    class operator Implicit(const Value: UInt32): NullableUInt32;
    class operator Implicit(const Value: NullableUInt32): UInt32;
    class operator Implicit(const Value: Pointer): NullableUInt32;	
	  class operator Equal(LeftValue: NullableUInt32; RightValue: NullableUInt32) : Boolean;	
    ///<summary>
    ///Returns `True` if the NullableUInt32 contains a value
    ///</summary>	
    property HasValue: Boolean read GetHasValue;
    ///<summary>
    ///Returns `True` if the NullableUInt32 contains a null
    ///</summary>	
    property IsNull: Boolean read GetIsNull;	
    ///<summary>
    ///Alias of `SetNull`
    ///</summary>
    procedure Clear;
    ///<summary>
    ///Set the value to `null`
    ///</summary>
    procedure SetNull;
    ///<summary>
    ///Returns the value stored or the default value for the type if the value is not set
    ///</summary>	
    function ValueOrDefault: UInt32;
    ///<summary>
    ///Returns the value stored or else the value passed as parameter if the value is not set
    ///</summary>	
    function ValueOrElse(const ElseValue: UInt32): UInt32;    
    /// <summary>
    /// Returns true is both item have the same value and that value is not null. 
    /// </summary>
    function Equals(const Value: NullableUInt32): Boolean;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: UInt32): Boolean; overload;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: TValue): Boolean; overload;
    ///<summary>
    ///Returns the value stored or raises exception if no value is stored
    ///</summary>	
    property Value: UInt32 read GetValue write SetValue;
  end;

//**************************
// ** NullableInt64
//**************************

  NullableInt64 = record
  private
    fValue: Int64;
    fHasValue: String;
    function GetHasValue: Boolean;
	  function GetIsNull: Boolean;	
  public
    procedure CheckHasValue;
    function GetValue: Int64;
    procedure SetValue(const Value: Int64);
    class operator Implicit(const Value: Int64): NullableInt64;
    class operator Implicit(const Value: NullableInt64): Int64;
    class operator Implicit(const Value: Pointer): NullableInt64;	
	  class operator Equal(LeftValue: NullableInt64; RightValue: NullableInt64) : Boolean;	
    ///<summary>
    ///Returns `True` if the NullableInt64 contains a value
    ///</summary>	
    property HasValue: Boolean read GetHasValue;
    ///<summary>
    ///Returns `True` if the NullableInt64 contains a null
    ///</summary>	
    property IsNull: Boolean read GetIsNull;	
    ///<summary>
    ///Alias of `SetNull`
    ///</summary>
    procedure Clear;
    ///<summary>
    ///Set the value to `null`
    ///</summary>
    procedure SetNull;
    ///<summary>
    ///Returns the value stored or the default value for the type if the value is not set
    ///</summary>	
    function ValueOrDefault: Int64;
    ///<summary>
    ///Returns the value stored or else the value passed as parameter if the value is not set
    ///</summary>	
    function ValueOrElse(const ElseValue: Int64): Int64;    
    /// <summary>
    /// Returns true is both item have the same value and that value is not null. 
    /// </summary>
    function Equals(const Value: NullableInt64): Boolean;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: Int64): Boolean; overload;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: TValue): Boolean; overload;
    ///<summary>
    ///Returns the value stored or raises exception if no value is stored
    ///</summary>	
    property Value: Int64 read GetValue write SetValue;
  end;

//**************************
// ** NullableUInt64
//**************************

  NullableUInt64 = record
  private
    fValue: UInt64;
    fHasValue: String;
    function GetHasValue: Boolean;
	  function GetIsNull: Boolean;	
  public
    procedure CheckHasValue;
    function GetValue: UInt64;
    procedure SetValue(const Value: UInt64);
    class operator Implicit(const Value: UInt64): NullableUInt64;
    class operator Implicit(const Value: NullableUInt64): UInt64;
    class operator Implicit(const Value: Pointer): NullableUInt64;	
	  class operator Equal(LeftValue: NullableUInt64; RightValue: NullableUInt64) : Boolean;	
    ///<summary>
    ///Returns `True` if the NullableUInt64 contains a value
    ///</summary>	
    property HasValue: Boolean read GetHasValue;
    ///<summary>
    ///Returns `True` if the NullableUInt64 contains a null
    ///</summary>	
    property IsNull: Boolean read GetIsNull;	
    ///<summary>
    ///Alias of `SetNull`
    ///</summary>
    procedure Clear;
    ///<summary>
    ///Set the value to `null`
    ///</summary>
    procedure SetNull;
    ///<summary>
    ///Returns the value stored or the default value for the type if the value is not set
    ///</summary>	
    function ValueOrDefault: UInt64;
    ///<summary>
    ///Returns the value stored or else the value passed as parameter if the value is not set
    ///</summary>	
    function ValueOrElse(const ElseValue: UInt64): UInt64;    
    /// <summary>
    /// Returns true is both item have the same value and that value is not null. 
    /// </summary>
    function Equals(const Value: NullableUInt64): Boolean;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: UInt64): Boolean; overload;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: TValue): Boolean; overload;
    ///<summary>
    ///Returns the value stored or raises exception if no value is stored
    ///</summary>	
    property Value: UInt64 read GetValue write SetValue;
  end;

//**************************
// ** NullableTGUID
//**************************

  NullableTGUID = record
  private
    fValue: TGUID;
    fHasValue: String;
    function GetHasValue: Boolean;
	  function GetIsNull: Boolean;	
  public
    procedure CheckHasValue;
    function GetValue: TGUID;
    procedure SetValue(const Value: TGUID);
    class operator Implicit(const Value: TGUID): NullableTGUID;
    class operator Implicit(const Value: NullableTGUID): TGUID;
    class operator Implicit(const Value: Pointer): NullableTGUID;	
	  class operator Equal(LeftValue: NullableTGUID; RightValue: NullableTGUID) : Boolean;	
    ///<summary>
    ///Returns `True` if the NullableTGUID contains a value
    ///</summary>	
    property HasValue: Boolean read GetHasValue;
    ///<summary>
    ///Returns `True` if the NullableTGUID contains a null
    ///</summary>	
    property IsNull: Boolean read GetIsNull;	
    ///<summary>
    ///Alias of `SetNull`
    ///</summary>
    procedure Clear;
    ///<summary>
    ///Set the value to `null`
    ///</summary>
    procedure SetNull;
    ///<summary>
    ///Returns the value stored or the default value for the type if the value is not set
    ///</summary>	
    function ValueOrDefault: TGUID;
    ///<summary>
    ///Returns the value stored or else the value passed as parameter if the value is not set
    ///</summary>	
    function ValueOrElse(const ElseValue: TGUID): TGUID;    
    /// <summary>
    /// Returns true is both item have the same value and that value is not null. 
    /// </summary>
    function Equals(const Value: NullableTGUID): Boolean;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: TGUID): Boolean; overload;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: TValue): Boolean; overload;
    ///<summary>
    ///Returns the value stored or raises exception if no value is stored
    ///</summary>	
    property Value: TGUID read GetValue write SetValue;
  end;

//**************************
// ** NullableNativeInt
//**************************

  NullableNativeInt = record
  private
    fValue: NativeInt;
    fHasValue: String;
    function GetHasValue: Boolean;
	  function GetIsNull: Boolean;	
  public
    procedure CheckHasValue;
    function GetValue: NativeInt;
    procedure SetValue(const Value: NativeInt);
    class operator Implicit(const Value: NativeInt): NullableNativeInt;
    class operator Implicit(const Value: NullableNativeInt): NativeInt;
    class operator Implicit(const Value: Pointer): NullableNativeInt;	
	  class operator Equal(LeftValue: NullableNativeInt; RightValue: NullableNativeInt) : Boolean;	
    ///<summary>
    ///Returns `True` if the NullableNativeInt contains a value
    ///</summary>	
    property HasValue: Boolean read GetHasValue;
    ///<summary>
    ///Returns `True` if the NullableNativeInt contains a null
    ///</summary>	
    property IsNull: Boolean read GetIsNull;	
    ///<summary>
    ///Alias of `SetNull`
    ///</summary>
    procedure Clear;
    ///<summary>
    ///Set the value to `null`
    ///</summary>
    procedure SetNull;
    ///<summary>
    ///Returns the value stored or the default value for the type if the value is not set
    ///</summary>	
    function ValueOrDefault: NativeInt;
    ///<summary>
    ///Returns the value stored or else the value passed as parameter if the value is not set
    ///</summary>	
    function ValueOrElse(const ElseValue: NativeInt): NativeInt;    
    /// <summary>
    /// Returns true is both item have the same value and that value is not null. 
    /// </summary>
    function Equals(const Value: NullableNativeInt): Boolean;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: NativeInt): Boolean; overload;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: TValue): Boolean; overload;
    ///<summary>
    ///Returns the value stored or raises exception if no value is stored
    ///</summary>	
    property Value: NativeInt read GetValue write SetValue;
  end;

//**************************
// ** NullableNativeUInt
//**************************

  NullableNativeUInt = record
  private
    fValue: NativeUInt;
    fHasValue: String;
    function GetHasValue: Boolean;
	  function GetIsNull: Boolean;	
  public
    procedure CheckHasValue;
    function GetValue: NativeUInt;
    procedure SetValue(const Value: NativeUInt);
    class operator Implicit(const Value: NativeUInt): NullableNativeUInt;
    class operator Implicit(const Value: NullableNativeUInt): NativeUInt;
    class operator Implicit(const Value: Pointer): NullableNativeUInt;	
	  class operator Equal(LeftValue: NullableNativeUInt; RightValue: NullableNativeUInt) : Boolean;	
    ///<summary>
    ///Returns `True` if the NullableNativeUInt contains a value
    ///</summary>	
    property HasValue: Boolean read GetHasValue;
    ///<summary>
    ///Returns `True` if the NullableNativeUInt contains a null
    ///</summary>	
    property IsNull: Boolean read GetIsNull;	
    ///<summary>
    ///Alias of `SetNull`
    ///</summary>
    procedure Clear;
    ///<summary>
    ///Set the value to `null`
    ///</summary>
    procedure SetNull;
    ///<summary>
    ///Returns the value stored or the default value for the type if the value is not set
    ///</summary>	
    function ValueOrDefault: NativeUInt;
    ///<summary>
    ///Returns the value stored or else the value passed as parameter if the value is not set
    ///</summary>	
    function ValueOrElse(const ElseValue: NativeUInt): NativeUInt;    
    /// <summary>
    /// Returns true is both item have the same value and that value is not null. 
    /// </summary>
    function Equals(const Value: NullableNativeUInt): Boolean;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: NativeUInt): Boolean; overload;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: TValue): Boolean; overload;
    ///<summary>
    ///Returns the value stored or raises exception if no value is stored
    ///</summary>	
    property Value: NativeUInt read GetValue write SetValue;
  end;

  TNullableType = (
     ntInvalidNullableType
   , ntNullableAnsiString
   , ntNullableString
   , ntNullableCurrency
   , ntNullableBoolean
   , ntNullableTDate
   , ntNullableTTime
   , ntNullableTDateTime
   , ntNullableSingle
   , ntNullableDouble
   , ntNullableFloat32
   , ntNullableFloat64
   , ntNullableExtended
   , ntNullableInt8
   , ntNullableUInt8
   , ntNullableByte
   , ntNullableInt16
   , ntNullableUInt16
   , ntNullableInt32
   , ntNullableInteger
   , ntNullableUInt32
   , ntNullableInt64
   , ntNullableUInt64
   , ntNullableTGUID
   , ntNullableNativeInt
   , ntNullableNativeUInt);


function GetNullableType(const aTypeInfo: PTypeInfo): TNullableType;


implementation

uses
  System.Math, System.DateUtils, System.Types, System.Generics.Defaults;

function DateAreEquals(const DateA, DateB: TDate): Boolean;
begin
  Result := CompareDate(DateA, DateB) = 0;
end;

function TimeAreEquals(const TimeA, TimeB: TTime): Boolean;
begin
  Result := CompareValue(TimeA,TimeB, 0.000001) = 0;
end;


{ NullableAnsiString }

procedure NullableAnsiString.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('NullableAnsiString value is null');
  end;
end;

function NullableAnsiString.TryHasValue(out Value: AnsiString): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := fValue;
  end;
end;

function NullableAnsiString.TryHasValue(out Value: TValue): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := TValue.From<AnsiString>(fValue);    
  end;
end;


procedure NullableAnsiString.Clear;
begin
  SetNull;
end;

function NullableAnsiString.Equals(const Value: NullableAnsiString): Boolean;
begin
  Result := Self = Value;
end;

function NullableAnsiString.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableAnsiString.GetIsNull: Boolean;
begin
  Result := not HasValue;
end;

function NullableAnsiString.GetValue: AnsiString;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableAnsiString.Implicit(const Value: NullableAnsiString): AnsiString;
begin
  Result := Value.Value;
end;

class operator NullableAnsiString.Implicit(const Value: AnsiString): NullableAnsiString;
begin
  Result.Value := Value;
end;

class operator NullableAnsiString.Implicit(const Value: Pointer): NullableAnsiString;
begin
  if Value = nil then
  begin
    Result.SetNull;
  end
  else
  begin
    raise EInvalidPointer.Create('Pointer value can only be "nil"');
  end;
end;

class operator NullableAnsiString.Equal(LeftValue: NullableAnsiString; RightValue: NullableAnsiString) : Boolean;
begin
  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and 
	 (LeftValue.Value = RightValue.Value));
end;

procedure NullableAnsiString.SetNull;
begin
  fValue := Default (AnsiString);
  fHasValue := '';
end;

procedure NullableAnsiString.SetValue(const Value: AnsiString);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableAnsiString.ValueOrDefault: AnsiString;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (AnsiString);
  end;
end;

function NullableAnsiString.ValueOrElse(const ElseValue: AnsiString): AnsiString;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := ElseValue;
  end;
end;




{ NullableString }

procedure NullableString.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('NullableString value is null');
  end;
end;

function NullableString.TryHasValue(out Value: String): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := fValue;
  end;
end;

function NullableString.TryHasValue(out Value: TValue): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := TValue.From<String>(fValue);    
  end;
end;


procedure NullableString.Clear;
begin
  SetNull;
end;

function NullableString.Equals(const Value: NullableString): Boolean;
begin
  Result := Self = Value;
end;

function NullableString.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableString.GetIsNull: Boolean;
begin
  Result := not HasValue;
end;

function NullableString.GetValue: String;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableString.Implicit(const Value: NullableString): String;
begin
  Result := Value.Value;
end;

class operator NullableString.Implicit(const Value: String): NullableString;
begin
  Result.Value := Value;
end;

class operator NullableString.Implicit(const Value: Pointer): NullableString;
begin
  if Value = nil then
  begin
    Result.SetNull;
  end
  else
  begin
    raise EInvalidPointer.Create('Pointer value can only be "nil"');
  end;
end;

class operator NullableString.Equal(LeftValue: NullableString; RightValue: NullableString) : Boolean;
begin
  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and 
	 (LeftValue.Value = RightValue.Value));
end;

procedure NullableString.SetNull;
begin
  fValue := Default (String);
  fHasValue := '';
end;

procedure NullableString.SetValue(const Value: String);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableString.ValueOrDefault: String;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (String);
  end;
end;

function NullableString.ValueOrElse(const ElseValue: String): String;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := ElseValue;
  end;
end;




{ NullableCurrency }

procedure NullableCurrency.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('NullableCurrency value is null');
  end;
end;

function NullableCurrency.TryHasValue(out Value: Currency): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := fValue;
  end;
end;

function NullableCurrency.TryHasValue(out Value: TValue): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := TValue.From<Currency>(fValue);    
  end;
end;


procedure NullableCurrency.Clear;
begin
  SetNull;
end;

function NullableCurrency.Equals(const Value: NullableCurrency): Boolean;
begin
  Result := Self = Value;
end;

function NullableCurrency.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableCurrency.GetIsNull: Boolean;
begin
  Result := not HasValue;
end;

function NullableCurrency.GetValue: Currency;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableCurrency.Implicit(const Value: NullableCurrency): Currency;
begin
  Result := Value.Value;
end;

class operator NullableCurrency.Implicit(const Value: Currency): NullableCurrency;
begin
  Result.Value := Value;
end;

class operator NullableCurrency.Implicit(const Value: Pointer): NullableCurrency;
begin
  if Value = nil then
  begin
    Result.SetNull;
  end
  else
  begin
    raise EInvalidPointer.Create('Pointer value can only be "nil"');
  end;
end;

class operator NullableCurrency.Equal(LeftValue: NullableCurrency; RightValue: NullableCurrency) : Boolean;
begin
  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and 
	 (LeftValue.Value = RightValue.Value));
end;

procedure NullableCurrency.SetNull;
begin
  fValue := Default (Currency);
  fHasValue := '';
end;

procedure NullableCurrency.SetValue(const Value: Currency);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableCurrency.ValueOrDefault: Currency;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (Currency);
  end;
end;

function NullableCurrency.ValueOrElse(const ElseValue: Currency): Currency;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := ElseValue;
  end;
end;




{ NullableBoolean }

procedure NullableBoolean.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('NullableBoolean value is null');
  end;
end;

function NullableBoolean.TryHasValue(out Value: Boolean): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := fValue;
  end;
end;

function NullableBoolean.TryHasValue(out Value: TValue): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := TValue.From<Boolean>(fValue);    
  end;
end;


procedure NullableBoolean.Clear;
begin
  SetNull;
end;

function NullableBoolean.Equals(const Value: NullableBoolean): Boolean;
begin
  Result := Self = Value;
end;

function NullableBoolean.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableBoolean.GetIsNull: Boolean;
begin
  Result := not HasValue;
end;

function NullableBoolean.GetValue: Boolean;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableBoolean.Implicit(const Value: NullableBoolean): Boolean;
begin
  Result := Value.Value;
end;

class operator NullableBoolean.Implicit(const Value: Boolean): NullableBoolean;
begin
  Result.Value := Value;
end;

class operator NullableBoolean.Implicit(const Value: Pointer): NullableBoolean;
begin
  if Value = nil then
  begin
    Result.SetNull;
  end
  else
  begin
    raise EInvalidPointer.Create('Pointer value can only be "nil"');
  end;
end;

class operator NullableBoolean.Equal(LeftValue: NullableBoolean; RightValue: NullableBoolean) : Boolean;
begin
  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and 
	 (LeftValue.Value = RightValue.Value));
end;

procedure NullableBoolean.SetNull;
begin
  fValue := Default (Boolean);
  fHasValue := '';
end;

procedure NullableBoolean.SetValue(const Value: Boolean);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableBoolean.ValueOrDefault: Boolean;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (Boolean);
  end;
end;

function NullableBoolean.ValueOrElse(const ElseValue: Boolean): Boolean;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := ElseValue;
  end;
end;




{ NullableTDate }

procedure NullableTDate.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('NullableTDate value is null');
  end;
end;

function NullableTDate.TryHasValue(out Value: TDate): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := fValue;
  end;
end;

function NullableTDate.TryHasValue(out Value: TValue): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := TValue.From<TDate>(fValue);    
  end;
end;


procedure NullableTDate.Clear;
begin
  SetNull;
end;

function NullableTDate.Equals(const Value: NullableTDate): Boolean;
begin
  Result := Self = Value;
end;

function NullableTDate.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableTDate.GetIsNull: Boolean;
begin
  Result := not HasValue;
end;

function NullableTDate.GetValue: TDate;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableTDate.Implicit(const Value: NullableTDate): TDate;
begin
  Result := Value.Value;
end;

class operator NullableTDate.Implicit(const Value: TDate): NullableTDate;
begin
  Result.Value := Value;
end;

class operator NullableTDate.Implicit(const Value: Pointer): NullableTDate;
begin
  if Value = nil then
  begin
    Result.SetNull;
  end
  else
  begin
    raise EInvalidPointer.Create('Pointer value can only be "nil"');
  end;
end;

class operator NullableTDate.Equal(LeftValue: NullableTDate; RightValue: NullableTDate) : Boolean;
begin
  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and 
	 (DateAreEquals(LeftValue.Value, RightValue.Value)));
end;

procedure NullableTDate.SetNull;
begin
  fValue := Default (TDate);
  fHasValue := '';
end;

procedure NullableTDate.SetValue(const Value: TDate);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableTDate.ValueOrDefault: TDate;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (TDate);
  end;
end;

function NullableTDate.ValueOrElse(const ElseValue: TDate): TDate;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := ElseValue;
  end;
end;




{ NullableTTime }

procedure NullableTTime.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('NullableTTime value is null');
  end;
end;

function NullableTTime.TryHasValue(out Value: TTime): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := fValue;
  end;
end;

function NullableTTime.TryHasValue(out Value: TValue): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := TValue.From<TTime>(fValue);    
  end;
end;


procedure NullableTTime.Clear;
begin
  SetNull;
end;

function NullableTTime.Equals(const Value: NullableTTime): Boolean;
begin
  Result := Self = Value;
end;

function NullableTTime.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableTTime.GetIsNull: Boolean;
begin
  Result := not HasValue;
end;

function NullableTTime.GetValue: TTime;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableTTime.Implicit(const Value: NullableTTime): TTime;
begin
  Result := Value.Value;
end;

class operator NullableTTime.Implicit(const Value: TTime): NullableTTime;
begin
  Result.Value := Value;
end;

class operator NullableTTime.Implicit(const Value: Pointer): NullableTTime;
begin
  if Value = nil then
  begin
    Result.SetNull;
  end
  else
  begin
    raise EInvalidPointer.Create('Pointer value can only be "nil"');
  end;
end;

class operator NullableTTime.Equal(LeftValue: NullableTTime; RightValue: NullableTTime) : Boolean;
begin
  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and 
	 (TimeAreEquals(LeftValue.Value, RightValue.Value)));
end;

procedure NullableTTime.SetNull;
begin
  fValue := Default (TTime);
  fHasValue := '';
end;

procedure NullableTTime.SetValue(const Value: TTime);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableTTime.ValueOrDefault: TTime;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (TTime);
  end;
end;

function NullableTTime.ValueOrElse(const ElseValue: TTime): TTime;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := ElseValue;
  end;
end;




{ NullableTDateTime }

procedure NullableTDateTime.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('NullableTDateTime value is null');
  end;
end;

function NullableTDateTime.TryHasValue(out Value: TDateTime): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := fValue;
  end;
end;

function NullableTDateTime.TryHasValue(out Value: TValue): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := TValue.From<TDateTime>(fValue);    
  end;
end;


procedure NullableTDateTime.Clear;
begin
  SetNull;
end;

function NullableTDateTime.Equals(const Value: NullableTDateTime): Boolean;
begin
  Result := Self = Value;
end;

function NullableTDateTime.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableTDateTime.GetIsNull: Boolean;
begin
  Result := not HasValue;
end;

function NullableTDateTime.GetValue: TDateTime;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableTDateTime.Implicit(const Value: NullableTDateTime): TDateTime;
begin
  Result := Value.Value;
end;

class operator NullableTDateTime.Implicit(const Value: TDateTime): NullableTDateTime;
begin
  Result.Value := Value;
end;

class operator NullableTDateTime.Implicit(const Value: Pointer): NullableTDateTime;
begin
  if Value = nil then
  begin
    Result.SetNull;
  end
  else
  begin
    raise EInvalidPointer.Create('Pointer value can only be "nil"');
  end;
end;

class operator NullableTDateTime.Equal(LeftValue: NullableTDateTime; RightValue: NullableTDateTime) : Boolean;
begin
  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and 
	 (DateAreEquals(LeftValue.Value, RightValue.Value) and 
	 TimeAreEquals(LeftValue.Value, RightValue.Value)));
end;

procedure NullableTDateTime.SetNull;
begin
  fValue := Default (TDateTime);
  fHasValue := '';
end;

procedure NullableTDateTime.SetValue(const Value: TDateTime);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableTDateTime.ValueOrDefault: TDateTime;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (TDateTime);
  end;
end;

function NullableTDateTime.ValueOrElse(const ElseValue: TDateTime): TDateTime;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := ElseValue;
  end;
end;




{ NullableSingle }

procedure NullableSingle.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('NullableSingle value is null');
  end;
end;

function NullableSingle.TryHasValue(out Value: Single): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := fValue;
  end;
end;

function NullableSingle.TryHasValue(out Value: TValue): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := TValue.From<Single>(fValue);    
  end;
end;


procedure NullableSingle.Clear;
begin
  SetNull;
end;

function NullableSingle.Equals(const Value: NullableSingle): Boolean;
begin
  Result := Self = Value;
end;

function NullableSingle.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableSingle.GetIsNull: Boolean;
begin
  Result := not HasValue;
end;

function NullableSingle.GetValue: Single;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableSingle.Implicit(const Value: NullableSingle): Single;
begin
  Result := Value.Value;
end;

class operator NullableSingle.Implicit(const Value: Single): NullableSingle;
begin
  Result.Value := Value;
end;

class operator NullableSingle.Implicit(const Value: Pointer): NullableSingle;
begin
  if Value = nil then
  begin
    Result.SetNull;
  end
  else
  begin
    raise EInvalidPointer.Create('Pointer value can only be "nil"');
  end;
end;

class operator NullableSingle.Equal(LeftValue: NullableSingle; RightValue: NullableSingle) : Boolean;
begin
  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and 
	 SameValue(LeftValue.Value, RightValue.Value, 0.000001));
end;

procedure NullableSingle.SetNull;
begin
  fValue := Default (Single);
  fHasValue := '';
end;

procedure NullableSingle.SetValue(const Value: Single);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableSingle.ValueOrDefault: Single;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (Single);
  end;
end;

function NullableSingle.ValueOrElse(const ElseValue: Single): Single;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := ElseValue;
  end;
end;




{ NullableDouble }

procedure NullableDouble.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('NullableDouble value is null');
  end;
end;

function NullableDouble.TryHasValue(out Value: Double): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := fValue;
  end;
end;

function NullableDouble.TryHasValue(out Value: TValue): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := TValue.From<Double>(fValue);    
  end;
end;


procedure NullableDouble.Clear;
begin
  SetNull;
end;

function NullableDouble.Equals(const Value: NullableDouble): Boolean;
begin
  Result := Self = Value;
end;

function NullableDouble.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableDouble.GetIsNull: Boolean;
begin
  Result := not HasValue;
end;

function NullableDouble.GetValue: Double;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableDouble.Implicit(const Value: NullableDouble): Double;
begin
  Result := Value.Value;
end;

class operator NullableDouble.Implicit(const Value: Double): NullableDouble;
begin
  Result.Value := Value;
end;

class operator NullableDouble.Implicit(const Value: Pointer): NullableDouble;
begin
  if Value = nil then
  begin
    Result.SetNull;
  end
  else
  begin
    raise EInvalidPointer.Create('Pointer value can only be "nil"');
  end;
end;

class operator NullableDouble.Equal(LeftValue: NullableDouble; RightValue: NullableDouble) : Boolean;
begin
  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and 
	 SameValue(LeftValue.Value, RightValue.Value, 0.000000001));
end;

procedure NullableDouble.SetNull;
begin
  fValue := Default (Double);
  fHasValue := '';
end;

procedure NullableDouble.SetValue(const Value: Double);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableDouble.ValueOrDefault: Double;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (Double);
  end;
end;

function NullableDouble.ValueOrElse(const ElseValue: Double): Double;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := ElseValue;
  end;
end;




{ NullableFloat32 }

procedure NullableFloat32.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('NullableFloat32 value is null');
  end;
end;

function NullableFloat32.TryHasValue(out Value: Float32): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := fValue;
  end;
end;

function NullableFloat32.TryHasValue(out Value: TValue): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := TValue.From<Float32>(fValue);    
  end;
end;


procedure NullableFloat32.Clear;
begin
  SetNull;
end;

function NullableFloat32.Equals(const Value: NullableFloat32): Boolean;
begin
  Result := Self = Value;
end;

function NullableFloat32.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableFloat32.GetIsNull: Boolean;
begin
  Result := not HasValue;
end;

function NullableFloat32.GetValue: Float32;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableFloat32.Implicit(const Value: NullableFloat32): Float32;
begin
  Result := Value.Value;
end;

class operator NullableFloat32.Implicit(const Value: Float32): NullableFloat32;
begin
  Result.Value := Value;
end;

class operator NullableFloat32.Implicit(const Value: Pointer): NullableFloat32;
begin
  if Value = nil then
  begin
    Result.SetNull;
  end
  else
  begin
    raise EInvalidPointer.Create('Pointer value can only be "nil"');
  end;
end;

class operator NullableFloat32.Equal(LeftValue: NullableFloat32; RightValue: NullableFloat32) : Boolean;
begin
  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and 
	 SameValue(LeftValue.Value, RightValue.Value, 0.000001));
end;

procedure NullableFloat32.SetNull;
begin
  fValue := Default (Float32);
  fHasValue := '';
end;

procedure NullableFloat32.SetValue(const Value: Float32);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableFloat32.ValueOrDefault: Float32;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (Float32);
  end;
end;

function NullableFloat32.ValueOrElse(const ElseValue: Float32): Float32;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := ElseValue;
  end;
end;




{ NullableFloat64 }

procedure NullableFloat64.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('NullableFloat64 value is null');
  end;
end;

function NullableFloat64.TryHasValue(out Value: Float64): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := fValue;
  end;
end;

function NullableFloat64.TryHasValue(out Value: TValue): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := TValue.From<Float64>(fValue);    
  end;
end;


procedure NullableFloat64.Clear;
begin
  SetNull;
end;

function NullableFloat64.Equals(const Value: NullableFloat64): Boolean;
begin
  Result := Self = Value;
end;

function NullableFloat64.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableFloat64.GetIsNull: Boolean;
begin
  Result := not HasValue;
end;

function NullableFloat64.GetValue: Float64;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableFloat64.Implicit(const Value: NullableFloat64): Float64;
begin
  Result := Value.Value;
end;

class operator NullableFloat64.Implicit(const Value: Float64): NullableFloat64;
begin
  Result.Value := Value;
end;

class operator NullableFloat64.Implicit(const Value: Pointer): NullableFloat64;
begin
  if Value = nil then
  begin
    Result.SetNull;
  end
  else
  begin
    raise EInvalidPointer.Create('Pointer value can only be "nil"');
  end;
end;

class operator NullableFloat64.Equal(LeftValue: NullableFloat64; RightValue: NullableFloat64) : Boolean;
begin
  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and 
	 SameValue(LeftValue.Value, RightValue.Value, 0.000000001));
end;

procedure NullableFloat64.SetNull;
begin
  fValue := Default (Float64);
  fHasValue := '';
end;

procedure NullableFloat64.SetValue(const Value: Float64);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableFloat64.ValueOrDefault: Float64;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (Float64);
  end;
end;

function NullableFloat64.ValueOrElse(const ElseValue: Float64): Float64;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := ElseValue;
  end;
end;




{ NullableExtended }

procedure NullableExtended.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('NullableExtended value is null');
  end;
end;

function NullableExtended.TryHasValue(out Value: Extended): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := fValue;
  end;
end;

function NullableExtended.TryHasValue(out Value: TValue): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := TValue.From<Extended>(fValue);    
  end;
end;


procedure NullableExtended.Clear;
begin
  SetNull;
end;

function NullableExtended.Equals(const Value: NullableExtended): Boolean;
begin
  Result := Self = Value;
end;

function NullableExtended.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableExtended.GetIsNull: Boolean;
begin
  Result := not HasValue;
end;

function NullableExtended.GetValue: Extended;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableExtended.Implicit(const Value: NullableExtended): Extended;
begin
  Result := Value.Value;
end;

class operator NullableExtended.Implicit(const Value: Extended): NullableExtended;
begin
  Result.Value := Value;
end;

class operator NullableExtended.Implicit(const Value: Pointer): NullableExtended;
begin
  if Value = nil then
  begin
    Result.SetNull;
  end
  else
  begin
    raise EInvalidPointer.Create('Pointer value can only be "nil"');
  end;
end;

class operator NullableExtended.Equal(LeftValue: NullableExtended; RightValue: NullableExtended) : Boolean;
begin
  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and 
	 SameValue(LeftValue.Value, RightValue.Value, 0.000000001));
end;

procedure NullableExtended.SetNull;
begin
  fValue := Default (Extended);
  fHasValue := '';
end;

procedure NullableExtended.SetValue(const Value: Extended);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableExtended.ValueOrDefault: Extended;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (Extended);
  end;
end;

function NullableExtended.ValueOrElse(const ElseValue: Extended): Extended;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := ElseValue;
  end;
end;




{ NullableInt8 }

procedure NullableInt8.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('NullableInt8 value is null');
  end;
end;

function NullableInt8.TryHasValue(out Value: Int8): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := fValue;
  end;
end;

function NullableInt8.TryHasValue(out Value: TValue): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := TValue.From<Int8>(fValue);    
  end;
end;


procedure NullableInt8.Clear;
begin
  SetNull;
end;

function NullableInt8.Equals(const Value: NullableInt8): Boolean;
begin
  Result := Self = Value;
end;

function NullableInt8.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableInt8.GetIsNull: Boolean;
begin
  Result := not HasValue;
end;

function NullableInt8.GetValue: Int8;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableInt8.Implicit(const Value: NullableInt8): Int8;
begin
  Result := Value.Value;
end;

class operator NullableInt8.Implicit(const Value: Int8): NullableInt8;
begin
  Result.Value := Value;
end;

class operator NullableInt8.Implicit(const Value: Pointer): NullableInt8;
begin
  if Value = nil then
  begin
    Result.SetNull;
  end
  else
  begin
    raise EInvalidPointer.Create('Pointer value can only be "nil"');
  end;
end;

class operator NullableInt8.Equal(LeftValue: NullableInt8; RightValue: NullableInt8) : Boolean;
begin
  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and (LeftValue.Value = RightValue.Value));
end;

procedure NullableInt8.SetNull;
begin
  fValue := Default (Int8);
  fHasValue := '';
end;

procedure NullableInt8.SetValue(const Value: Int8);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableInt8.ValueOrDefault: Int8;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (Int8);
  end;
end;

function NullableInt8.ValueOrElse(const ElseValue: Int8): Int8;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := ElseValue;
  end;
end;




{ NullableUInt8 }

procedure NullableUInt8.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('NullableUInt8 value is null');
  end;
end;

function NullableUInt8.TryHasValue(out Value: UInt8): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := fValue;
  end;
end;

function NullableUInt8.TryHasValue(out Value: TValue): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := TValue.From<UInt8>(fValue);    
  end;
end;


procedure NullableUInt8.Clear;
begin
  SetNull;
end;

function NullableUInt8.Equals(const Value: NullableUInt8): Boolean;
begin
  Result := Self = Value;
end;

function NullableUInt8.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableUInt8.GetIsNull: Boolean;
begin
  Result := not HasValue;
end;

function NullableUInt8.GetValue: UInt8;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableUInt8.Implicit(const Value: NullableUInt8): UInt8;
begin
  Result := Value.Value;
end;

class operator NullableUInt8.Implicit(const Value: UInt8): NullableUInt8;
begin
  Result.Value := Value;
end;

class operator NullableUInt8.Implicit(const Value: Pointer): NullableUInt8;
begin
  if Value = nil then
  begin
    Result.SetNull;
  end
  else
  begin
    raise EInvalidPointer.Create('Pointer value can only be "nil"');
  end;
end;

class operator NullableUInt8.Equal(LeftValue: NullableUInt8; RightValue: NullableUInt8) : Boolean;
begin
  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and (LeftValue.Value = RightValue.Value));
end;

procedure NullableUInt8.SetNull;
begin
  fValue := Default (UInt8);
  fHasValue := '';
end;

procedure NullableUInt8.SetValue(const Value: UInt8);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableUInt8.ValueOrDefault: UInt8;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (UInt8);
  end;
end;

function NullableUInt8.ValueOrElse(const ElseValue: UInt8): UInt8;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := ElseValue;
  end;
end;




{ NullableByte }

procedure NullableByte.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('NullableByte value is null');
  end;
end;

function NullableByte.TryHasValue(out Value: Byte): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := fValue;
  end;
end;

function NullableByte.TryHasValue(out Value: TValue): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := TValue.From<Byte>(fValue);    
  end;
end;


procedure NullableByte.Clear;
begin
  SetNull;
end;

function NullableByte.Equals(const Value: NullableByte): Boolean;
begin
  Result := Self = Value;
end;

function NullableByte.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableByte.GetIsNull: Boolean;
begin
  Result := not HasValue;
end;

function NullableByte.GetValue: Byte;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableByte.Implicit(const Value: NullableByte): Byte;
begin
  Result := Value.Value;
end;

class operator NullableByte.Implicit(const Value: Byte): NullableByte;
begin
  Result.Value := Value;
end;

class operator NullableByte.Implicit(const Value: Pointer): NullableByte;
begin
  if Value = nil then
  begin
    Result.SetNull;
  end
  else
  begin
    raise EInvalidPointer.Create('Pointer value can only be "nil"');
  end;
end;

class operator NullableByte.Equal(LeftValue: NullableByte; RightValue: NullableByte) : Boolean;
begin
  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and (LeftValue.Value = RightValue.Value));
end;

procedure NullableByte.SetNull;
begin
  fValue := Default (Byte);
  fHasValue := '';
end;

procedure NullableByte.SetValue(const Value: Byte);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableByte.ValueOrDefault: Byte;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (Byte);
  end;
end;

function NullableByte.ValueOrElse(const ElseValue: Byte): Byte;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := ElseValue;
  end;
end;




{ NullableInt16 }

procedure NullableInt16.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('NullableInt16 value is null');
  end;
end;

function NullableInt16.TryHasValue(out Value: Int16): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := fValue;
  end;
end;

function NullableInt16.TryHasValue(out Value: TValue): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := TValue.From<Int16>(fValue);    
  end;
end;


procedure NullableInt16.Clear;
begin
  SetNull;
end;

function NullableInt16.Equals(const Value: NullableInt16): Boolean;
begin
  Result := Self = Value;
end;

function NullableInt16.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableInt16.GetIsNull: Boolean;
begin
  Result := not HasValue;
end;

function NullableInt16.GetValue: Int16;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableInt16.Implicit(const Value: NullableInt16): Int16;
begin
  Result := Value.Value;
end;

class operator NullableInt16.Implicit(const Value: Int16): NullableInt16;
begin
  Result.Value := Value;
end;

class operator NullableInt16.Implicit(const Value: Pointer): NullableInt16;
begin
  if Value = nil then
  begin
    Result.SetNull;
  end
  else
  begin
    raise EInvalidPointer.Create('Pointer value can only be "nil"');
  end;
end;

class operator NullableInt16.Equal(LeftValue: NullableInt16; RightValue: NullableInt16) : Boolean;
begin
  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and (LeftValue.Value = RightValue.Value));
end;

procedure NullableInt16.SetNull;
begin
  fValue := Default (Int16);
  fHasValue := '';
end;

procedure NullableInt16.SetValue(const Value: Int16);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableInt16.ValueOrDefault: Int16;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (Int16);
  end;
end;

function NullableInt16.ValueOrElse(const ElseValue: Int16): Int16;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := ElseValue;
  end;
end;




{ NullableUInt16 }

procedure NullableUInt16.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('NullableUInt16 value is null');
  end;
end;

function NullableUInt16.TryHasValue(out Value: UInt16): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := fValue;
  end;
end;

function NullableUInt16.TryHasValue(out Value: TValue): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := TValue.From<UInt16>(fValue);    
  end;
end;


procedure NullableUInt16.Clear;
begin
  SetNull;
end;

function NullableUInt16.Equals(const Value: NullableUInt16): Boolean;
begin
  Result := Self = Value;
end;

function NullableUInt16.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableUInt16.GetIsNull: Boolean;
begin
  Result := not HasValue;
end;

function NullableUInt16.GetValue: UInt16;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableUInt16.Implicit(const Value: NullableUInt16): UInt16;
begin
  Result := Value.Value;
end;

class operator NullableUInt16.Implicit(const Value: UInt16): NullableUInt16;
begin
  Result.Value := Value;
end;

class operator NullableUInt16.Implicit(const Value: Pointer): NullableUInt16;
begin
  if Value = nil then
  begin
    Result.SetNull;
  end
  else
  begin
    raise EInvalidPointer.Create('Pointer value can only be "nil"');
  end;
end;

class operator NullableUInt16.Equal(LeftValue: NullableUInt16; RightValue: NullableUInt16) : Boolean;
begin
  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and (LeftValue.Value = RightValue.Value));
end;

procedure NullableUInt16.SetNull;
begin
  fValue := Default (UInt16);
  fHasValue := '';
end;

procedure NullableUInt16.SetValue(const Value: UInt16);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableUInt16.ValueOrDefault: UInt16;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (UInt16);
  end;
end;

function NullableUInt16.ValueOrElse(const ElseValue: UInt16): UInt16;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := ElseValue;
  end;
end;




{ NullableInt32 }

procedure NullableInt32.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('NullableInt32 value is null');
  end;
end;

function NullableInt32.TryHasValue(out Value: Int32): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := fValue;
  end;
end;

function NullableInt32.TryHasValue(out Value: TValue): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := TValue.From<Int32>(fValue);    
  end;
end;


procedure NullableInt32.Clear;
begin
  SetNull;
end;

function NullableInt32.Equals(const Value: NullableInt32): Boolean;
begin
  Result := Self = Value;
end;

function NullableInt32.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableInt32.GetIsNull: Boolean;
begin
  Result := not HasValue;
end;

function NullableInt32.GetValue: Int32;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableInt32.Implicit(const Value: NullableInt32): Int32;
begin
  Result := Value.Value;
end;

class operator NullableInt32.Implicit(const Value: Int32): NullableInt32;
begin
  Result.Value := Value;
end;

class operator NullableInt32.Implicit(const Value: Pointer): NullableInt32;
begin
  if Value = nil then
  begin
    Result.SetNull;
  end
  else
  begin
    raise EInvalidPointer.Create('Pointer value can only be "nil"');
  end;
end;

class operator NullableInt32.Equal(LeftValue: NullableInt32; RightValue: NullableInt32) : Boolean;
begin
  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and (LeftValue.Value = RightValue.Value));
end;

procedure NullableInt32.SetNull;
begin
  fValue := Default (Int32);
  fHasValue := '';
end;

procedure NullableInt32.SetValue(const Value: Int32);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableInt32.ValueOrDefault: Int32;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (Int32);
  end;
end;

function NullableInt32.ValueOrElse(const ElseValue: Int32): Int32;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := ElseValue;
  end;
end;




{ NullableInteger }

procedure NullableInteger.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('NullableInteger value is null');
  end;
end;

function NullableInteger.TryHasValue(out Value: Integer): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := fValue;
  end;
end;

function NullableInteger.TryHasValue(out Value: TValue): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := TValue.From<Integer>(fValue);    
  end;
end;


procedure NullableInteger.Clear;
begin
  SetNull;
end;

function NullableInteger.Equals(const Value: NullableInteger): Boolean;
begin
  Result := Self = Value;
end;

function NullableInteger.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableInteger.GetIsNull: Boolean;
begin
  Result := not HasValue;
end;

function NullableInteger.GetValue: Integer;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableInteger.Implicit(const Value: NullableInteger): Integer;
begin
  Result := Value.Value;
end;

class operator NullableInteger.Implicit(const Value: Integer): NullableInteger;
begin
  Result.Value := Value;
end;

class operator NullableInteger.Implicit(const Value: Pointer): NullableInteger;
begin
  if Value = nil then
  begin
    Result.SetNull;
  end
  else
  begin
    raise EInvalidPointer.Create('Pointer value can only be "nil"');
  end;
end;

class operator NullableInteger.Equal(LeftValue: NullableInteger; RightValue: NullableInteger) : Boolean;
begin
  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and (LeftValue.Value = RightValue.Value));
end;

procedure NullableInteger.SetNull;
begin
  fValue := Default (Integer);
  fHasValue := '';
end;

procedure NullableInteger.SetValue(const Value: Integer);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableInteger.ValueOrDefault: Integer;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (Integer);
  end;
end;

function NullableInteger.ValueOrElse(const ElseValue: Integer): Integer;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := ElseValue;
  end;
end;




{ NullableUInt32 }

procedure NullableUInt32.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('NullableUInt32 value is null');
  end;
end;

function NullableUInt32.TryHasValue(out Value: UInt32): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := fValue;
  end;
end;

function NullableUInt32.TryHasValue(out Value: TValue): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := TValue.From<UInt32>(fValue);    
  end;
end;


procedure NullableUInt32.Clear;
begin
  SetNull;
end;

function NullableUInt32.Equals(const Value: NullableUInt32): Boolean;
begin
  Result := Self = Value;
end;

function NullableUInt32.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableUInt32.GetIsNull: Boolean;
begin
  Result := not HasValue;
end;

function NullableUInt32.GetValue: UInt32;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableUInt32.Implicit(const Value: NullableUInt32): UInt32;
begin
  Result := Value.Value;
end;

class operator NullableUInt32.Implicit(const Value: UInt32): NullableUInt32;
begin
  Result.Value := Value;
end;

class operator NullableUInt32.Implicit(const Value: Pointer): NullableUInt32;
begin
  if Value = nil then
  begin
    Result.SetNull;
  end
  else
  begin
    raise EInvalidPointer.Create('Pointer value can only be "nil"');
  end;
end;

class operator NullableUInt32.Equal(LeftValue: NullableUInt32; RightValue: NullableUInt32) : Boolean;
begin
  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and (LeftValue.Value = RightValue.Value));
end;

procedure NullableUInt32.SetNull;
begin
  fValue := Default (UInt32);
  fHasValue := '';
end;

procedure NullableUInt32.SetValue(const Value: UInt32);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableUInt32.ValueOrDefault: UInt32;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (UInt32);
  end;
end;

function NullableUInt32.ValueOrElse(const ElseValue: UInt32): UInt32;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := ElseValue;
  end;
end;




{ NullableInt64 }

procedure NullableInt64.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('NullableInt64 value is null');
  end;
end;

function NullableInt64.TryHasValue(out Value: Int64): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := fValue;
  end;
end;

function NullableInt64.TryHasValue(out Value: TValue): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := TValue.From<Int64>(fValue);    
  end;
end;


procedure NullableInt64.Clear;
begin
  SetNull;
end;

function NullableInt64.Equals(const Value: NullableInt64): Boolean;
begin
  Result := Self = Value;
end;

function NullableInt64.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableInt64.GetIsNull: Boolean;
begin
  Result := not HasValue;
end;

function NullableInt64.GetValue: Int64;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableInt64.Implicit(const Value: NullableInt64): Int64;
begin
  Result := Value.Value;
end;

class operator NullableInt64.Implicit(const Value: Int64): NullableInt64;
begin
  Result.Value := Value;
end;

class operator NullableInt64.Implicit(const Value: Pointer): NullableInt64;
begin
  if Value = nil then
  begin
    Result.SetNull;
  end
  else
  begin
    raise EInvalidPointer.Create('Pointer value can only be "nil"');
  end;
end;

class operator NullableInt64.Equal(LeftValue: NullableInt64; RightValue: NullableInt64) : Boolean;
begin
  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and (LeftValue.Value = RightValue.Value));
end;

procedure NullableInt64.SetNull;
begin
  fValue := Default (Int64);
  fHasValue := '';
end;

procedure NullableInt64.SetValue(const Value: Int64);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableInt64.ValueOrDefault: Int64;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (Int64);
  end;
end;

function NullableInt64.ValueOrElse(const ElseValue: Int64): Int64;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := ElseValue;
  end;
end;




{ NullableUInt64 }

procedure NullableUInt64.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('NullableUInt64 value is null');
  end;
end;

function NullableUInt64.TryHasValue(out Value: UInt64): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := fValue;
  end;
end;

function NullableUInt64.TryHasValue(out Value: TValue): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := TValue.From<UInt64>(fValue);    
  end;
end;


procedure NullableUInt64.Clear;
begin
  SetNull;
end;

function NullableUInt64.Equals(const Value: NullableUInt64): Boolean;
begin
  Result := Self = Value;
end;

function NullableUInt64.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableUInt64.GetIsNull: Boolean;
begin
  Result := not HasValue;
end;

function NullableUInt64.GetValue: UInt64;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableUInt64.Implicit(const Value: NullableUInt64): UInt64;
begin
  Result := Value.Value;
end;

class operator NullableUInt64.Implicit(const Value: UInt64): NullableUInt64;
begin
  Result.Value := Value;
end;

class operator NullableUInt64.Implicit(const Value: Pointer): NullableUInt64;
begin
  if Value = nil then
  begin
    Result.SetNull;
  end
  else
  begin
    raise EInvalidPointer.Create('Pointer value can only be "nil"');
  end;
end;

class operator NullableUInt64.Equal(LeftValue: NullableUInt64; RightValue: NullableUInt64) : Boolean;
begin
  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and (LeftValue.Value = RightValue.Value));
end;

procedure NullableUInt64.SetNull;
begin
  fValue := Default (UInt64);
  fHasValue := '';
end;

procedure NullableUInt64.SetValue(const Value: UInt64);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableUInt64.ValueOrDefault: UInt64;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (UInt64);
  end;
end;

function NullableUInt64.ValueOrElse(const ElseValue: UInt64): UInt64;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := ElseValue;
  end;
end;




{ NullableTGUID }

procedure NullableTGUID.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('NullableTGUID value is null');
  end;
end;

function NullableTGUID.TryHasValue(out Value: TGUID): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := fValue;
  end;
end;

function NullableTGUID.TryHasValue(out Value: TValue): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := TValue.From<TGUID>(fValue);    
  end;
end;


procedure NullableTGUID.Clear;
begin
  SetNull;
end;

function NullableTGUID.Equals(const Value: NullableTGUID): Boolean;
begin
  Result := Self = Value;
end;

function NullableTGUID.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableTGUID.GetIsNull: Boolean;
begin
  Result := not HasValue;
end;

function NullableTGUID.GetValue: TGUID;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableTGUID.Implicit(const Value: NullableTGUID): TGUID;
begin
  Result := Value.Value;
end;

class operator NullableTGUID.Implicit(const Value: TGUID): NullableTGUID;
begin
  Result.Value := Value;
end;

class operator NullableTGUID.Implicit(const Value: Pointer): NullableTGUID;
begin
  if Value = nil then
  begin
    Result.SetNull;
  end
  else
  begin
    raise EInvalidPointer.Create('Pointer value can only be "nil"');
  end;
end;

class operator NullableTGUID.Equal(LeftValue: NullableTGUID; RightValue: NullableTGUID) : Boolean;
begin
  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and (LeftValue.Value = RightValue.Value));
end;

procedure NullableTGUID.SetNull;
begin
  fValue := Default (TGUID);
  fHasValue := '';
end;

procedure NullableTGUID.SetValue(const Value: TGUID);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableTGUID.ValueOrDefault: TGUID;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (TGUID);
  end;
end;

function NullableTGUID.ValueOrElse(const ElseValue: TGUID): TGUID;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := ElseValue;
  end;
end;




{ NullableNativeInt }

procedure NullableNativeInt.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('NullableNativeInt value is null');
  end;
end;

function NullableNativeInt.TryHasValue(out Value: NativeInt): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := fValue;
  end;
end;

function NullableNativeInt.TryHasValue(out Value: TValue): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := TValue.From<NativeInt>(fValue);    
  end;
end;


procedure NullableNativeInt.Clear;
begin
  SetNull;
end;

function NullableNativeInt.Equals(const Value: NullableNativeInt): Boolean;
begin
  Result := Self = Value;
end;

function NullableNativeInt.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableNativeInt.GetIsNull: Boolean;
begin
  Result := not HasValue;
end;

function NullableNativeInt.GetValue: NativeInt;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableNativeInt.Implicit(const Value: NullableNativeInt): NativeInt;
begin
  Result := Value.Value;
end;

class operator NullableNativeInt.Implicit(const Value: NativeInt): NullableNativeInt;
begin
  Result.Value := Value;
end;

class operator NullableNativeInt.Implicit(const Value: Pointer): NullableNativeInt;
begin
  if Value = nil then
  begin
    Result.SetNull;
  end
  else
  begin
    raise EInvalidPointer.Create('Pointer value can only be "nil"');
  end;
end;

class operator NullableNativeInt.Equal(LeftValue: NullableNativeInt; RightValue: NullableNativeInt) : Boolean;
begin
  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and (LeftValue.Value = RightValue.Value));
end;

procedure NullableNativeInt.SetNull;
begin
  fValue := Default (NativeInt);
  fHasValue := '';
end;

procedure NullableNativeInt.SetValue(const Value: NativeInt);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableNativeInt.ValueOrDefault: NativeInt;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (NativeInt);
  end;
end;

function NullableNativeInt.ValueOrElse(const ElseValue: NativeInt): NativeInt;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := ElseValue;
  end;
end;




{ NullableNativeUInt }

procedure NullableNativeUInt.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('NullableNativeUInt value is null');
  end;
end;

function NullableNativeUInt.TryHasValue(out Value: NativeUInt): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := fValue;
  end;
end;

function NullableNativeUInt.TryHasValue(out Value: TValue): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := TValue.From<NativeUInt>(fValue);    
  end;
end;


procedure NullableNativeUInt.Clear;
begin
  SetNull;
end;

function NullableNativeUInt.Equals(const Value: NullableNativeUInt): Boolean;
begin
  Result := Self = Value;
end;

function NullableNativeUInt.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function NullableNativeUInt.GetIsNull: Boolean;
begin
  Result := not HasValue;
end;

function NullableNativeUInt.GetValue: NativeUInt;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator NullableNativeUInt.Implicit(const Value: NullableNativeUInt): NativeUInt;
begin
  Result := Value.Value;
end;

class operator NullableNativeUInt.Implicit(const Value: NativeUInt): NullableNativeUInt;
begin
  Result.Value := Value;
end;

class operator NullableNativeUInt.Implicit(const Value: Pointer): NullableNativeUInt;
begin
  if Value = nil then
  begin
    Result.SetNull;
  end
  else
  begin
    raise EInvalidPointer.Create('Pointer value can only be "nil"');
  end;
end;

class operator NullableNativeUInt.Equal(LeftValue: NullableNativeUInt; RightValue: NullableNativeUInt) : Boolean;
begin
  Result := (LeftValue.IsNull and RightValue.IsNull) or ((LeftValue.HasValue and RightValue.HasValue) and (LeftValue.Value = RightValue.Value));
end;

procedure NullableNativeUInt.SetNull;
begin
  fValue := Default (NativeUInt);
  fHasValue := '';
end;

procedure NullableNativeUInt.SetValue(const Value: NativeUInt);
begin
  fValue := Value;
  fHasValue := '_';
end;

function NullableNativeUInt.ValueOrDefault: NativeUInt;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default (NativeUInt);
  end;
end;

function NullableNativeUInt.ValueOrElse(const ElseValue: NativeUInt): NativeUInt;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := ElseValue;
  end;
end;



function GetNullableType(const aTypeInfo: PTypeInfo): TNullableType;
begin
  if aTypeInfo = TypeInfo(NullableAnsiString) then 
    Exit(ntNullableAnsiString); 
  if aTypeInfo = TypeInfo(NullableString) then 
    Exit(ntNullableString); 
  if aTypeInfo = TypeInfo(NullableCurrency) then 
    Exit(ntNullableCurrency); 
  if aTypeInfo = TypeInfo(NullableBoolean) then 
    Exit(ntNullableBoolean); 
  if aTypeInfo = TypeInfo(NullableTDate) then 
    Exit(ntNullableTDate); 
  if aTypeInfo = TypeInfo(NullableTTime) then 
    Exit(ntNullableTTime); 
  if aTypeInfo = TypeInfo(NullableTDateTime) then 
    Exit(ntNullableTDateTime); 
  if aTypeInfo = TypeInfo(NullableSingle) then 
    Exit(ntNullableSingle); 
  if aTypeInfo = TypeInfo(NullableDouble) then 
    Exit(ntNullableDouble); 
  if aTypeInfo = TypeInfo(NullableFloat32) then 
    Exit(ntNullableFloat32); 
  if aTypeInfo = TypeInfo(NullableFloat64) then 
    Exit(ntNullableFloat64); 
  if aTypeInfo = TypeInfo(NullableExtended) then 
    Exit(ntNullableExtended); 
  if aTypeInfo = TypeInfo(NullableInt8) then 
    Exit(ntNullableInt8); 
  if aTypeInfo = TypeInfo(NullableUInt8) then 
    Exit(ntNullableUInt8); 
  if aTypeInfo = TypeInfo(NullableByte) then 
    Exit(ntNullableByte); 
  if aTypeInfo = TypeInfo(NullableInt16) then 
    Exit(ntNullableInt16); 
  if aTypeInfo = TypeInfo(NullableUInt16) then 
    Exit(ntNullableUInt16); 
  if aTypeInfo = TypeInfo(NullableInt32) then 
    Exit(ntNullableInt32); 
  if aTypeInfo = TypeInfo(NullableInteger) then 
    Exit(ntNullableInteger); 
  if aTypeInfo = TypeInfo(NullableUInt32) then 
    Exit(ntNullableUInt32); 
  if aTypeInfo = TypeInfo(NullableInt64) then 
    Exit(ntNullableInt64); 
  if aTypeInfo = TypeInfo(NullableUInt64) then 
    Exit(ntNullableUInt64); 
  if aTypeInfo = TypeInfo(NullableTGUID) then 
    Exit(ntNullableTGUID); 
  if aTypeInfo = TypeInfo(NullableNativeInt) then 
    Exit(ntNullableNativeInt); 
  if aTypeInfo = TypeInfo(NullableNativeUInt) then 
    Exit(ntNullableNativeUInt); 
  Result := ntInvalidNullableType;
end;

{ Nullable<T> }

procedure Nullable<T>.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('Nullable<T> value is null');
  end;
end;

function Nullable<T>.TryHasValue(out Value: T): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := fValue;
  end;
end;

function Nullable<T>.TryHasValue(out Value: TValue): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := TValue.From<Nullable<T>>(fValue);
  end;
end;


procedure Nullable<T>.Clear;
begin
  SetNull;
end;

function Nullable<T>.Equals(const Value: Nullable<T>): Boolean;
begin
  Result := Self = Value;
end;

function Nullable<T>.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function Nullable<T>.GetIsNull: Boolean;
begin
  Result := not HasValue;
end;

function Nullable<T>.GetValue: T;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator Nullable<T>.Implicit(const Value: Nullable<T>): T;
begin
  Result := Value.Value;
end;

class operator Nullable<T>.Implicit(const Value: T): Nullable<T>;
begin
  Result.Value := Value;
end;

class operator Nullable<T>.Implicit(const Value: Pointer): Nullable<T>;
begin
  if Value = nil then
  begin
    Result.SetNull;
  end
  else
  begin
    raise EInvalidPointer.Create('Pointer value can only be "nil"');
  end;
end;

class operator Nullable<T>.Equal(LeftValue: Nullable<T>; RightValue: Nullable<T>) : Boolean;
var
  lComparer: IEqualityComparer<T>;
begin
  lComparer := TEqualityComparer<T>.Default;
  if not Assigned(lComparer) then
  begin
    raise EMVCNullable.Create('Cannot compare Nullable<T> values without a valid IEqualityComparer<T>.');
  end;
  Result := (LeftValue.IsNull and RightValue.IsNull)
    or ((LeftValue.HasValue and RightValue.HasValue) and lComparer.Equals(LeftValue.Value, RightValue.Value));
end;

procedure Nullable<T>.SetNull;
begin
  fValue := Default(T);
  fHasValue := '';
end;

procedure Nullable<T>.SetValue(const Value: T);
begin
  fValue := Value;
  fHasValue := '_';
end;

function Nullable<T>.ValueOrDefault: T;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default(T);
  end;
end;

function Nullable<T>.ValueOrElse(const ElseValue: T): T;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := ElseValue;
  end;
end;

end.

