// ***************************************************************************
// 
// THIS FILE IS GENERATED BY "inv generate-nullables" DO NOT CHANGE MANUALLY!
// 
// ***************************************************************************
//
// *************************************************************************** }
//
// Delphi MVC Framework
//
// Copyright (c) 2010-2025 Daniele Teti and the DMVCFramework Team
//
// https://github.com/danieleteti/delphimvcframework
//
// ***************************************************************************
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


unit MVCFramework.Nullables;

{$IF CompilerVersion >= 35} // 11 Alexandria
{$DEFINE USE_EQUALS}
{$ENDIF}

interface

uses
  System.SysUtils, System.Classes, System.TypInfo, System.RTTI;

type
  EMVCNullable = class(Exception)

  end;

{$IF CompilerVersion <= 32} // 10.2 Tokyo
  Float32 = Single;
  Float64 = Double;
{$IFEND}

//**************************************************************************************************************
//** Nullable<T> -- In case of generic-types Delphi compiler generates different RTTI information for each BPL
//**                To de/serialize a Nullable<T> is required a CustomTypeSerializer
//**************************************************************************************************************

  Nullable<T> = record
  private
    fValue: T;
    fHasValue: String;
    function GetHasValue: Boolean;
	function GetIsNull: Boolean;	
  public
    procedure CheckHasValue;
    function GetValue: T;
    procedure SetValue(const Value: T);
    class operator Implicit(const Value: T): Nullable<T>; overload;
    class operator Implicit(const Value: Nullable<T>): T; overload;
    class operator Implicit(const Value: Pointer): Nullable<T>; overload;
	  class operator Equal(LeftValue: Nullable<T>; RightValue: Nullable<T>) : Boolean;	
    ///<summary>
    ///Returns `True` if the Nullable<T> contains a value
    ///</summary>	
    property HasValue: Boolean read GetHasValue;
    ///<summary>
    ///Returns `True` if the Nullable<T> contains a null
    ///</summary>	
    property IsNull: Boolean read GetIsNull;	
    ///<summary>
    ///Alias of `SetNull`
    ///</summary>
    procedure Clear;
    ///<summary>
    ///Set the value to `null`
    ///</summary>
    procedure SetNull;
    ///<summary>
    ///Returns the value stored or the default value for the type if the value is not set
    ///</summary>	
    function ValueOrDefault: T;
    ///<summary>
    ///Returns the value stored or else the value passed as parameter if the value is not set
    ///</summary>	
    function ValueOrElse(const ElseValue: T): T;
    /// <summary>
    /// Returns true is both item have the same value and that value is not null. 
    /// </summary>
    function Equals(const Value: Nullable<T>): Boolean;    
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: T): Boolean; overload;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: TValue): Boolean; overload;
    ///<summary>
    ///Returns the value stored or raises exception if no value is stored
    ///</summary>	
    property Value: T read GetValue write SetValue;
  end;

///INTERFACE.BEGIN
  Nullable$TYPE$ = record
  private
    fValue: $TYPE$;
    fHasValue: String;
    function GetHasValue: Boolean;
	  function GetIsNull: Boolean;	
  public
    procedure CheckHasValue;
    function GetValue: $TYPE$;
    procedure SetValue(const Value: $TYPE$);
    class operator Implicit(const Value: $TYPE$): Nullable$TYPE$;
    class operator Implicit(const Value: Nullable$TYPE$): $TYPE$;
    class operator Implicit(const Value: Pointer): Nullable$TYPE$;	
	  class operator Equal(LeftValue: Nullable$TYPE$; RightValue: Nullable$TYPE$) : Boolean;	
    ///<summary>
    ///Returns `True` if the Nullable$TYPE$ contains a value
    ///</summary>	
    property HasValue: Boolean read GetHasValue;
    ///<summary>
    ///Returns `True` if the Nullable$TYPE$ contains a null
    ///</summary>	
    property IsNull: Boolean read GetIsNull;	
    ///<summary>
    ///Alias of `SetNull`
    ///</summary>
    procedure Clear;
    ///<summary>
    ///Set the value to `null`
    ///</summary>
    procedure SetNull;
    ///<summary>
    ///Returns the value stored or the default value for the type if the value is not set
    ///</summary>	
    function ValueOrDefault: $TYPE$;
    ///<summary>
    ///Returns the value stored or else the value passed as parameter if the value is not set
    ///</summary>	
    function ValueOrElse(const ElseValue: $TYPE$): $TYPE$;    
    /// <summary>
    /// Returns true is both item have the same value and that value is not null. 
    /// </summary>
    function Equals(const Value: Nullable$TYPE$): Boolean;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: $TYPE$): Boolean; overload;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: TValue): Boolean; overload;
    ///<summary>
    ///Returns the value stored or raises exception if no value is stored
    ///</summary>	
    property Value: $TYPE$ read GetValue write SetValue;
  end;

///INTERFACE.END


implementation

uses
  System.Math, System.DateUtils, System.Types, System.Generics.Defaults;

function DateAreEquals(const DateA, DateB: TDate): Boolean;
begin
  Result := CompareDate(DateA, DateB) = 0;
end;

function TimeAreEquals(const TimeA, TimeB: TTime): Boolean;
begin
  Result := CompareValue(TimeA,TimeB, 0.000001) = 0;
end;

///IMPLEMENTATION.BEGIN

{ Nullable$TYPE$ }

procedure Nullable$TYPE$.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('Nullable$TYPE$ value is null');
  end;
end;

function Nullable$TYPE$.TryHasValue(out Value: $TYPE$): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := fValue;
  end;
end;

function Nullable$TYPE$.TryHasValue(out Value: TValue): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := TValue.From<$TYPE$>(fValue);    
  end;
end;


procedure Nullable$TYPE$.Clear;
begin
  SetNull;
end;

function Nullable$TYPE$.Equals(const Value: Nullable$TYPE$): Boolean;
begin
  Result := Self = Value;
end;

function Nullable$TYPE$.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function Nullable$TYPE$.GetIsNull: Boolean;
begin
  Result := not HasValue;
end;

function Nullable$TYPE$.GetValue: $TYPE$;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator Nullable$TYPE$.Implicit(const Value: Nullable$TYPE$): $TYPE$;
begin
  Result := Value.Value;
end;

class operator Nullable$TYPE$.Implicit(const Value: $TYPE$): Nullable$TYPE$;
begin
  Result.Value := Value;
end;

class operator Nullable$TYPE$.Implicit(const Value: Pointer): Nullable$TYPE$;
begin
  if Value = nil then
  begin
    Result.SetNull;
  end
  else
  begin
    raise EInvalidPointer.Create('Pointer value can only be "nil"');
  end;
end;

class operator Nullable$TYPE$.Equal(LeftValue: Nullable$TYPE$; RightValue: Nullable$TYPE$) : Boolean;
begin
  Result := $COMPARE$;
end;

procedure Nullable$TYPE$.SetNull;
begin
  fValue := Default ($TYPE$);
  fHasValue := '';
end;

procedure Nullable$TYPE$.SetValue(const Value: $TYPE$);
begin
  fValue := Value;
  fHasValue := '_';
end;

function Nullable$TYPE$.ValueOrDefault: $TYPE$;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default ($TYPE$);
  end;
end;

function Nullable$TYPE$.ValueOrElse(const ElseValue: $TYPE$): $TYPE$;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := ElseValue;
  end;
end;


///IMPLEMENTATION.END

{ Nullable<T> }

procedure Nullable<T>.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('Nullable<T> value is null');
  end;
end;

function Nullable<T>.TryHasValue(out Value: T): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := fValue;
  end;
end;

function Nullable<T>.TryHasValue(out Value: TValue): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := TValue.From<Nullable<T>>(fValue);
  end;
end;


procedure Nullable<T>.Clear;
begin
  SetNull;
end;

function Nullable<T>.Equals(const Value: Nullable<T>): Boolean;
begin
  Result := Self = Value;
end;

function Nullable<T>.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function Nullable<T>.GetIsNull: Boolean;
begin
  Result := not HasValue;
end;

function Nullable<T>.GetValue: T;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator Nullable<T>.Implicit(const Value: Nullable<T>): T;
begin
  Result := Value.Value;
end;

class operator Nullable<T>.Implicit(const Value: T): Nullable<T>;
begin
  Result.Value := Value;
end;

class operator Nullable<T>.Implicit(const Value: Pointer): Nullable<T>;
begin
  if Value = nil then
  begin
    Result.SetNull;
  end
  else
  begin
    raise EInvalidPointer.Create('Pointer value can only be "nil"');
  end;
end;

class operator Nullable<T>.Equal(LeftValue: Nullable<T>; RightValue: Nullable<T>) : Boolean;
var
  lComparer: IEqualityComparer<T>;
begin
  lComparer := TEqualityComparer<T>.Default;
  if not Assigned(lComparer) then
  begin
    raise EMVCNullable.Create('Cannot compare Nullable<T> values without a valid IEqualityComparer<T>.');
  end;
  Result := (LeftValue.IsNull and RightValue.IsNull)
    or ((LeftValue.HasValue and RightValue.HasValue) and lComparer.Equals(LeftValue.Value, RightValue.Value));
end;

procedure Nullable<T>.SetNull;
begin
  fValue := Default(T);
  fHasValue := '';
end;

procedure Nullable<T>.SetValue(const Value: T);
begin
  fValue := Value;
  fHasValue := '_';
end;

function Nullable<T>.ValueOrDefault: T;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default(T);
  end;
end;

function Nullable<T>.ValueOrElse(const ElseValue: T): T;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := ElseValue;
  end;
end;

end.
