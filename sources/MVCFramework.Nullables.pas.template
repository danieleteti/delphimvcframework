// ***************************************************************************
// 
// THIS FILE IS GENERATED BY "inv generate-nullables" DO NOT CHANGE MANUALLY!
// 
// ***************************************************************************
//
// *************************************************************************** }
//
// Delphi MVC Framework
//
// Copyright (c) 2010-2023 Daniele Teti and the DMVCFramework Team
//
// https://github.com/danieleteti/delphimvcframework
//
// ***************************************************************************
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


unit MVCFramework.Nullables;

interface

uses
  System.SysUtils, System.Classes, System.TypInfo, System.RTTI;

type
  EMVCNullable = class(Exception)

  end;

///INTERFACE.BEGIN
  Nullable$TYPE$ = record
  private
    fValue: $TYPE$;
    fHasValue: String;
    function GetHasValue: Boolean;
	function GetIsNull: Boolean;	
  public
    procedure CheckHasValue;
    function GetValue: $TYPE$;
    procedure SetValue(const Value: $TYPE$);
    class operator Implicit(const Value: $TYPE$): Nullable$TYPE$;
    class operator Implicit(const Value: Nullable$TYPE$): $TYPE$;
    class operator Implicit(const Value: Pointer): Nullable$TYPE$;	
	  class operator Equal(LeftValue: Nullable$TYPE$; RightValue: Nullable$TYPE$) : Boolean;	
    ///<summary>
    ///Returns `True` if the Nullable$TYPE$ contains a value
    ///</summary>	
    property HasValue: Boolean read GetHasValue;
    ///<summary>
    ///Returns `True` if the Nullable$TYPE$ contains a null
    ///</summary>	
    property IsNull: Boolean read GetIsNull;	
    ///<summary>
    ///Alias of `SetNull`
    ///</summary>
    procedure Clear;
    ///<summary>
    ///Set the value to `null`
    ///</summary>
    procedure SetNull;
    ///<summary>
    ///Returns the value stored or the default value for the type is the value is not set
    ///</summary>	
    function ValueOrDefault: $TYPE$;
    /// <summary>
    /// Returns true is both item have the same value and that value is not null. 
    /// </summary>
    function Equals(const Value: Nullable$TYPE$): Boolean;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: $TYPE$): Boolean; overload;
    ///<summary>
    ///Returns true if the nullable contains a value and returns the contained value in the out Value parameter.
    ///</summary>	
    function TryHasValue(out Value: TValue): Boolean; overload;
    ///<summary>
    ///Returns the value stored or raises exception if no value is stored
    ///</summary>	
    property Value: $TYPE$ read GetValue write SetValue;
  end;

///INTERFACE.END

implementation

uses
  System.Math, MVCFramework.Serializer.Commons;

///IMPLEMENTATION.BEGIN

{ Nullable$TYPE$ }

procedure Nullable$TYPE$.CheckHasValue;
begin
  if not GetHasValue then
  begin
    raise EMVCNullable.Create('Nullable$TYPE$ value is null');
  end;
end;

function Nullable$TYPE$.TryHasValue(out Value: $TYPE$): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := fValue;
  end;
end;

function Nullable$TYPE$.TryHasValue(out Value: TValue): Boolean;
begin
  Result := HasValue;
  if Result then
  begin
    Value := TValue.From<$TYPE$>(fValue);    
  end;
end;


procedure Nullable$TYPE$.Clear;
begin
  SetNull;
end;

function Nullable$TYPE$.Equals(const Value: Nullable$TYPE$): Boolean;
begin
  Result := Self = Value;
end;

function Nullable$TYPE$.GetHasValue: Boolean;
begin
  Result := fHasValue = '_';
end;

function Nullable$TYPE$.GetIsNull: Boolean;
begin
  Result := not HasValue;
end;

function Nullable$TYPE$.GetValue: $TYPE$;
begin
  CheckHasValue;
  Result := fValue;
end;

class operator Nullable$TYPE$.Implicit(const Value: Nullable$TYPE$): $TYPE$;
begin
  Result := Value.Value;
end;

class operator Nullable$TYPE$.Implicit(const Value: $TYPE$): Nullable$TYPE$;
begin
  Result.Value := Value;
end;

class operator Nullable$TYPE$.Implicit(const Value: Pointer): Nullable$TYPE$;
begin
  if Value = nil then
  begin
    Result.SetNull;
  end
  else
  begin
    raise EInvalidPointer.Create('Pointer value can only be "nil"');
  end;
end;

class operator Nullable$TYPE$.Equal(LeftValue: Nullable$TYPE$; RightValue: Nullable$TYPE$) : Boolean;
begin
  Result := $COMPARE$;
end;

procedure Nullable$TYPE$.SetNull;
begin
  fValue := Default ($TYPE$);
  fHasValue := '';
end;

procedure Nullable$TYPE$.SetValue(const Value: $TYPE$);
begin
  fValue := Value;
  fHasValue := '_';
end;

function Nullable$TYPE$.ValueOrDefault: $TYPE$;
begin
  if HasValue then
  begin
    Result := GetValue
  end
  else
  begin
    Result := Default ($TYPE$);
  end;
end;

///IMPLEMENTATION.END

end.
