// This file was autogenerated by cloop - Cross Language Object Oriented Programming

#ifndef IDL_FB_INTERFACES_H
#define IDL_FB_INTERFACES_H

#ifndef CLOOP_CARG
#define CLOOP_CARG
#endif


namespace Firebird
{
	class DoNotInherit
	{
	};

	template <typename T>
	class Inherit : public T
	{
	public:
		Inherit(DoNotInherit = DoNotInherit())
			: T(DoNotInherit())
		{
		}
	};

	// Forward interfaces declarations

	class IVersioned;
	class IReferenceCounted;
	class IDisposable;
	class IStatus;
	class IMaster;
	class IPluginBase;
	class IPluginSet;
	class IConfigEntry;
	class IConfig;
	class IFirebirdConf;
	class IPluginConfig;
	class IPluginFactory;
	class IPluginModule;
	class IPluginManager;
	class ICryptKey;
	class IConfigManager;
	class IEventCallback;
	class IBlob;
	class ITransaction;
	class IMessageMetadata;
	class IMetadataBuilder;
	class IResultSet;
	class IStatement;
	class IRequest;
	class IEvents;
	class IAttachment;
	class IService;
	class IProvider;
	class IDtcStart;
	class IDtc;
	class IAuth;
	class IWriter;
	class IServerBlock;
	class IClientBlock;
	class IServer;
	class IClient;
	class IUserField;
	class ICharUserField;
	class IIntUserField;
	class IUser;
	class IListUsers;
	class ILogonInfo;
	class IManagement;
	class IAuthBlock;
	class IWireCryptPlugin;
	class ICryptKeyCallback;
	class IKeyHolderPlugin;
	class IDbCryptInfo;
	class IDbCryptPlugin;
	class IExternalContext;
	class IExternalResultSet;
	class IExternalFunction;
	class IExternalProcedure;
	class IExternalTrigger;
	class IRoutineMetadata;
	class IExternalEngine;
	class ITimer;
	class ITimerControl;
	class IVersionCallback;
	class IUtil;
	class IOffsetsCallback;
	class IXpbBuilder;
	class ITraceConnection;
	class ITraceDatabaseConnection;
	class ITraceTransaction;
	class ITraceParams;
	class ITraceStatement;
	class ITraceSQLStatement;
	class ITraceBLRStatement;
	class ITraceDYNRequest;
	class ITraceContextVariable;
	class ITraceProcedure;
	class ITraceFunction;
	class ITraceTrigger;
	class ITraceServiceConnection;
	class ITraceStatusVector;
	class ITraceSweepInfo;
	class ITraceLogWriter;
	class ITraceInitInfo;
	class ITracePlugin;
	class ITraceFactory;
	class IUdrFunctionFactory;
	class IUdrProcedureFactory;
	class IUdrTriggerFactory;
	class IUdrPlugin;

	// Interfaces declarations

	class IVersioned
	{
	public:
		struct VTable
		{
			void* cloopDummy[1];
			uintptr_t version;
		};

		void* cloopDummy[1];
		VTable* cloopVTable;

	protected:
		IVersioned(DoNotInherit)
		{
		}

		~IVersioned()
		{
		}

	public:
		static const unsigned VERSION = 1;
	};

	class IReferenceCounted : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			void (CLOOP_CARG *addRef)(IReferenceCounted* self) throw();
			int (CLOOP_CARG *release)(IReferenceCounted* self) throw();
		};

	protected:
		IReferenceCounted(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IReferenceCounted()
		{
		}

	public:
		static const unsigned VERSION = 2;

		void addRef()
		{
			static_cast<VTable*>(this->cloopVTable)->addRef(this);
		}

		int release()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->release(this);
			return ret;
		}
	};

	class IDisposable : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			void (CLOOP_CARG *dispose)(IDisposable* self) throw();
		};

	protected:
		IDisposable(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IDisposable()
		{
		}

	public:
		static const unsigned VERSION = 2;

		void dispose()
		{
			static_cast<VTable*>(this->cloopVTable)->dispose(this);
		}
	};

	class IStatus : public IDisposable
	{
	public:
		struct VTable : public IDisposable::VTable
		{
			void (CLOOP_CARG *init)(IStatus* self) throw();
			unsigned (CLOOP_CARG *getState)(const IStatus* self) throw();
			void (CLOOP_CARG *setErrors2)(IStatus* self, unsigned length, const intptr_t* value) throw();
			void (CLOOP_CARG *setWarnings2)(IStatus* self, unsigned length, const intptr_t* value) throw();
			void (CLOOP_CARG *setErrors)(IStatus* self, const intptr_t* value) throw();
			void (CLOOP_CARG *setWarnings)(IStatus* self, const intptr_t* value) throw();
			const intptr_t* (CLOOP_CARG *getErrors)(const IStatus* self) throw();
			const intptr_t* (CLOOP_CARG *getWarnings)(const IStatus* self) throw();
			IStatus* (CLOOP_CARG *clone)(const IStatus* self) throw();
		};

	protected:
		IStatus(DoNotInherit)
			: IDisposable(DoNotInherit())
		{
		}

		~IStatus()
		{
		}

	public:
		static const unsigned VERSION = 3;

		static const unsigned STATE_WARNINGS = 0x1;
		static const unsigned STATE_ERRORS = 0x2;
		static const int RESULT_ERROR = -1;
		static const int RESULT_OK = 0;
		static const int RESULT_NO_DATA = 1;
		static const int RESULT_SEGMENT = 2;

		void init()
		{
			static_cast<VTable*>(this->cloopVTable)->init(this);
		}

		unsigned getState() const
		{
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getState(this);
			return ret;
		}

		void setErrors2(unsigned length, const intptr_t* value)
		{
			static_cast<VTable*>(this->cloopVTable)->setErrors2(this, length, value);
		}

		void setWarnings2(unsigned length, const intptr_t* value)
		{
			static_cast<VTable*>(this->cloopVTable)->setWarnings2(this, length, value);
		}

		void setErrors(const intptr_t* value)
		{
			static_cast<VTable*>(this->cloopVTable)->setErrors(this, value);
		}

		void setWarnings(const intptr_t* value)
		{
			static_cast<VTable*>(this->cloopVTable)->setWarnings(this, value);
		}

		const intptr_t* getErrors() const
		{
			const intptr_t* ret = static_cast<VTable*>(this->cloopVTable)->getErrors(this);
			return ret;
		}

		const intptr_t* getWarnings() const
		{
			const intptr_t* ret = static_cast<VTable*>(this->cloopVTable)->getWarnings(this);
			return ret;
		}

		IStatus* clone() const
		{
			IStatus* ret = static_cast<VTable*>(this->cloopVTable)->clone(this);
			return ret;
		}
	};

	class IMaster : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			IStatus* (CLOOP_CARG *getStatus)(IMaster* self) throw();
			IProvider* (CLOOP_CARG *getDispatcher)(IMaster* self) throw();
			IPluginManager* (CLOOP_CARG *getPluginManager)(IMaster* self) throw();
			ITimerControl* (CLOOP_CARG *getTimerControl)(IMaster* self) throw();
			IDtc* (CLOOP_CARG *getDtc)(IMaster* self) throw();
			IAttachment* (CLOOP_CARG *registerAttachment)(IMaster* self, IProvider* provider, IAttachment* attachment) throw();
			ITransaction* (CLOOP_CARG *registerTransaction)(IMaster* self, IAttachment* attachment, ITransaction* transaction) throw();
			IMetadataBuilder* (CLOOP_CARG *getMetadataBuilder)(IMaster* self, IStatus* status, unsigned fieldCount) throw();
			int (CLOOP_CARG *serverMode)(IMaster* self, int mode) throw();
			IUtil* (CLOOP_CARG *getUtilInterface)(IMaster* self) throw();
			IConfigManager* (CLOOP_CARG *getConfigManager)(IMaster* self) throw();
			FB_BOOLEAN (CLOOP_CARG *getProcessExiting)(IMaster* self) throw();
		};

	protected:
		IMaster(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IMaster()
		{
		}

	public:
		static const unsigned VERSION = 2;

		IStatus* getStatus()
		{
			IStatus* ret = static_cast<VTable*>(this->cloopVTable)->getStatus(this);
			return ret;
		}

		IProvider* getDispatcher()
		{
			IProvider* ret = static_cast<VTable*>(this->cloopVTable)->getDispatcher(this);
			return ret;
		}

		IPluginManager* getPluginManager()
		{
			IPluginManager* ret = static_cast<VTable*>(this->cloopVTable)->getPluginManager(this);
			return ret;
		}

		ITimerControl* getTimerControl()
		{
			ITimerControl* ret = static_cast<VTable*>(this->cloopVTable)->getTimerControl(this);
			return ret;
		}

		IDtc* getDtc()
		{
			IDtc* ret = static_cast<VTable*>(this->cloopVTable)->getDtc(this);
			return ret;
		}

		IAttachment* registerAttachment(IProvider* provider, IAttachment* attachment)
		{
			IAttachment* ret = static_cast<VTable*>(this->cloopVTable)->registerAttachment(this, provider, attachment);
			return ret;
		}

		ITransaction* registerTransaction(IAttachment* attachment, ITransaction* transaction)
		{
			ITransaction* ret = static_cast<VTable*>(this->cloopVTable)->registerTransaction(this, attachment, transaction);
			return ret;
		}

		template <typename StatusType> IMetadataBuilder* getMetadataBuilder(StatusType* status, unsigned fieldCount)
		{
			StatusType::clearException(status);
			IMetadataBuilder* ret = static_cast<VTable*>(this->cloopVTable)->getMetadataBuilder(this, status, fieldCount);
			StatusType::checkException(status);
			return ret;
		}

		int serverMode(int mode)
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->serverMode(this, mode);
			return ret;
		}

		IUtil* getUtilInterface()
		{
			IUtil* ret = static_cast<VTable*>(this->cloopVTable)->getUtilInterface(this);
			return ret;
		}

		IConfigManager* getConfigManager()
		{
			IConfigManager* ret = static_cast<VTable*>(this->cloopVTable)->getConfigManager(this);
			return ret;
		}

		FB_BOOLEAN getProcessExiting()
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->getProcessExiting(this);
			return ret;
		}
	};

	class IPluginBase : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			void (CLOOP_CARG *setOwner)(IPluginBase* self, IReferenceCounted* r) throw();
			IReferenceCounted* (CLOOP_CARG *getOwner)(IPluginBase* self) throw();
		};

	protected:
		IPluginBase(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~IPluginBase()
		{
		}

	public:
		static const unsigned VERSION = 3;

		void setOwner(IReferenceCounted* r)
		{
			static_cast<VTable*>(this->cloopVTable)->setOwner(this, r);
		}

		IReferenceCounted* getOwner()
		{
			IReferenceCounted* ret = static_cast<VTable*>(this->cloopVTable)->getOwner(this);
			return ret;
		}
	};

	class IPluginSet : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			const char* (CLOOP_CARG *getName)(const IPluginSet* self) throw();
			const char* (CLOOP_CARG *getModuleName)(const IPluginSet* self) throw();
			IPluginBase* (CLOOP_CARG *getPlugin)(IPluginSet* self, IStatus* status) throw();
			void (CLOOP_CARG *next)(IPluginSet* self, IStatus* status) throw();
			void (CLOOP_CARG *set)(IPluginSet* self, IStatus* status, const char* s) throw();
		};

	protected:
		IPluginSet(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~IPluginSet()
		{
		}

	public:
		static const unsigned VERSION = 3;

		const char* getName() const
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getName(this);
			return ret;
		}

		const char* getModuleName() const
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getModuleName(this);
			return ret;
		}

		template <typename StatusType> IPluginBase* getPlugin(StatusType* status)
		{
			StatusType::clearException(status);
			IPluginBase* ret = static_cast<VTable*>(this->cloopVTable)->getPlugin(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> void next(StatusType* status)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->next(this, status);
			StatusType::checkException(status);
		}

		template <typename StatusType> void set(StatusType* status, const char* s)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->set(this, status, s);
			StatusType::checkException(status);
		}
	};

	class IConfigEntry : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			const char* (CLOOP_CARG *getName)(IConfigEntry* self) throw();
			const char* (CLOOP_CARG *getValue)(IConfigEntry* self) throw();
			ISC_INT64 (CLOOP_CARG *getIntValue)(IConfigEntry* self) throw();
			FB_BOOLEAN (CLOOP_CARG *getBoolValue)(IConfigEntry* self) throw();
			IConfig* (CLOOP_CARG *getSubConfig)(IConfigEntry* self, IStatus* status) throw();
		};

	protected:
		IConfigEntry(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~IConfigEntry()
		{
		}

	public:
		static const unsigned VERSION = 3;

		const char* getName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getName(this);
			return ret;
		}

		const char* getValue()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getValue(this);
			return ret;
		}

		ISC_INT64 getIntValue()
		{
			ISC_INT64 ret = static_cast<VTable*>(this->cloopVTable)->getIntValue(this);
			return ret;
		}

		FB_BOOLEAN getBoolValue()
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->getBoolValue(this);
			return ret;
		}

		template <typename StatusType> IConfig* getSubConfig(StatusType* status)
		{
			StatusType::clearException(status);
			IConfig* ret = static_cast<VTable*>(this->cloopVTable)->getSubConfig(this, status);
			StatusType::checkException(status);
			return ret;
		}
	};

	class IConfig : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			IConfigEntry* (CLOOP_CARG *find)(IConfig* self, IStatus* status, const char* name) throw();
			IConfigEntry* (CLOOP_CARG *findValue)(IConfig* self, IStatus* status, const char* name, const char* value) throw();
			IConfigEntry* (CLOOP_CARG *findPos)(IConfig* self, IStatus* status, const char* name, unsigned pos) throw();
		};

	protected:
		IConfig(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~IConfig()
		{
		}

	public:
		static const unsigned VERSION = 3;

		template <typename StatusType> IConfigEntry* find(StatusType* status, const char* name)
		{
			StatusType::clearException(status);
			IConfigEntry* ret = static_cast<VTable*>(this->cloopVTable)->find(this, status, name);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> IConfigEntry* findValue(StatusType* status, const char* name, const char* value)
		{
			StatusType::clearException(status);
			IConfigEntry* ret = static_cast<VTable*>(this->cloopVTable)->findValue(this, status, name, value);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> IConfigEntry* findPos(StatusType* status, const char* name, unsigned pos)
		{
			StatusType::clearException(status);
			IConfigEntry* ret = static_cast<VTable*>(this->cloopVTable)->findPos(this, status, name, pos);
			StatusType::checkException(status);
			return ret;
		}
	};

	class IFirebirdConf : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			unsigned (CLOOP_CARG *getKey)(IFirebirdConf* self, const char* name) throw();
			ISC_INT64 (CLOOP_CARG *asInteger)(IFirebirdConf* self, unsigned key) throw();
			const char* (CLOOP_CARG *asString)(IFirebirdConf* self, unsigned key) throw();
			FB_BOOLEAN (CLOOP_CARG *asBoolean)(IFirebirdConf* self, unsigned key) throw();
		};

	protected:
		IFirebirdConf(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~IFirebirdConf()
		{
		}

	public:
		static const unsigned VERSION = 3;

		unsigned getKey(const char* name)
		{
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getKey(this, name);
			return ret;
		}

		ISC_INT64 asInteger(unsigned key)
		{
			ISC_INT64 ret = static_cast<VTable*>(this->cloopVTable)->asInteger(this, key);
			return ret;
		}

		const char* asString(unsigned key)
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->asString(this, key);
			return ret;
		}

		FB_BOOLEAN asBoolean(unsigned key)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->asBoolean(this, key);
			return ret;
		}
	};

	class IPluginConfig : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			const char* (CLOOP_CARG *getConfigFileName)(IPluginConfig* self) throw();
			IConfig* (CLOOP_CARG *getDefaultConfig)(IPluginConfig* self, IStatus* status) throw();
			IFirebirdConf* (CLOOP_CARG *getFirebirdConf)(IPluginConfig* self, IStatus* status) throw();
			void (CLOOP_CARG *setReleaseDelay)(IPluginConfig* self, IStatus* status, ISC_UINT64 microSeconds) throw();
		};

	protected:
		IPluginConfig(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~IPluginConfig()
		{
		}

	public:
		static const unsigned VERSION = 3;

		const char* getConfigFileName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getConfigFileName(this);
			return ret;
		}

		template <typename StatusType> IConfig* getDefaultConfig(StatusType* status)
		{
			StatusType::clearException(status);
			IConfig* ret = static_cast<VTable*>(this->cloopVTable)->getDefaultConfig(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> IFirebirdConf* getFirebirdConf(StatusType* status)
		{
			StatusType::clearException(status);
			IFirebirdConf* ret = static_cast<VTable*>(this->cloopVTable)->getFirebirdConf(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> void setReleaseDelay(StatusType* status, ISC_UINT64 microSeconds)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->setReleaseDelay(this, status, microSeconds);
			StatusType::checkException(status);
		}
	};

	class IPluginFactory : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			IPluginBase* (CLOOP_CARG *createPlugin)(IPluginFactory* self, IStatus* status, IPluginConfig* factoryParameter) throw();
		};

	protected:
		IPluginFactory(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IPluginFactory()
		{
		}

	public:
		static const unsigned VERSION = 2;

		template <typename StatusType> IPluginBase* createPlugin(StatusType* status, IPluginConfig* factoryParameter)
		{
			StatusType::clearException(status);
			IPluginBase* ret = static_cast<VTable*>(this->cloopVTable)->createPlugin(this, status, factoryParameter);
			StatusType::checkException(status);
			return ret;
		}
	};

	class IPluginModule : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			void (CLOOP_CARG *doClean)(IPluginModule* self) throw();
			void (CLOOP_CARG *threadDetach)(IPluginModule* self) throw();
		};

	protected:
		IPluginModule(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IPluginModule()
		{
		}

	public:
		static const unsigned VERSION = 3;

		void doClean()
		{
			static_cast<VTable*>(this->cloopVTable)->doClean(this);
		}

		void threadDetach()
		{
			if (cloopVTable->version < 3)
			{
				return;
			}
			static_cast<VTable*>(this->cloopVTable)->threadDetach(this);
		}
	};

	class IPluginManager : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			void (CLOOP_CARG *registerPluginFactory)(IPluginManager* self, unsigned pluginType, const char* defaultName, IPluginFactory* factory) throw();
			void (CLOOP_CARG *registerModule)(IPluginManager* self, IPluginModule* cleanup) throw();
			void (CLOOP_CARG *unregisterModule)(IPluginManager* self, IPluginModule* cleanup) throw();
			IPluginSet* (CLOOP_CARG *getPlugins)(IPluginManager* self, IStatus* status, unsigned pluginType, const char* namesList, IFirebirdConf* firebirdConf) throw();
			IConfig* (CLOOP_CARG *getConfig)(IPluginManager* self, IStatus* status, const char* filename) throw();
			void (CLOOP_CARG *releasePlugin)(IPluginManager* self, IPluginBase* plugin) throw();
		};

	protected:
		IPluginManager(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IPluginManager()
		{
		}

	public:
		static const unsigned VERSION = 2;

		static const unsigned TYPE_PROVIDER = 1;
		static const unsigned TYPE_FIRST_NON_LIB = 2;
		static const unsigned TYPE_AUTH_SERVER = 3;
		static const unsigned TYPE_AUTH_CLIENT = 4;
		static const unsigned TYPE_AUTH_USER_MANAGEMENT = 5;
		static const unsigned TYPE_EXTERNAL_ENGINE = 6;
		static const unsigned TYPE_TRACE = 7;
		static const unsigned TYPE_WIRE_CRYPT = 8;
		static const unsigned TYPE_DB_CRYPT = 9;
		static const unsigned TYPE_KEY_HOLDER = 10;
		static const unsigned TYPE_COUNT = 11;

		void registerPluginFactory(unsigned pluginType, const char* defaultName, IPluginFactory* factory)
		{
			static_cast<VTable*>(this->cloopVTable)->registerPluginFactory(this, pluginType, defaultName, factory);
		}

		void registerModule(IPluginModule* cleanup)
		{
			static_cast<VTable*>(this->cloopVTable)->registerModule(this, cleanup);
		}

		void unregisterModule(IPluginModule* cleanup)
		{
			static_cast<VTable*>(this->cloopVTable)->unregisterModule(this, cleanup);
		}

		template <typename StatusType> IPluginSet* getPlugins(StatusType* status, unsigned pluginType, const char* namesList, IFirebirdConf* firebirdConf)
		{
			StatusType::clearException(status);
			IPluginSet* ret = static_cast<VTable*>(this->cloopVTable)->getPlugins(this, status, pluginType, namesList, firebirdConf);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> IConfig* getConfig(StatusType* status, const char* filename)
		{
			StatusType::clearException(status);
			IConfig* ret = static_cast<VTable*>(this->cloopVTable)->getConfig(this, status, filename);
			StatusType::checkException(status);
			return ret;
		}

		void releasePlugin(IPluginBase* plugin)
		{
			static_cast<VTable*>(this->cloopVTable)->releasePlugin(this, plugin);
		}
	};

	class ICryptKey : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			void (CLOOP_CARG *setSymmetric)(ICryptKey* self, IStatus* status, const char* type, unsigned keyLength, const void* key) throw();
			void (CLOOP_CARG *setAsymmetric)(ICryptKey* self, IStatus* status, const char* type, unsigned encryptKeyLength, const void* encryptKey, unsigned decryptKeyLength, const void* decryptKey) throw();
			const void* (CLOOP_CARG *getEncryptKey)(ICryptKey* self, unsigned* length) throw();
			const void* (CLOOP_CARG *getDecryptKey)(ICryptKey* self, unsigned* length) throw();
		};

	protected:
		ICryptKey(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~ICryptKey()
		{
		}

	public:
		static const unsigned VERSION = 2;

		template <typename StatusType> void setSymmetric(StatusType* status, const char* type, unsigned keyLength, const void* key)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->setSymmetric(this, status, type, keyLength, key);
			StatusType::checkException(status);
		}

		template <typename StatusType> void setAsymmetric(StatusType* status, const char* type, unsigned encryptKeyLength, const void* encryptKey, unsigned decryptKeyLength, const void* decryptKey)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->setAsymmetric(this, status, type, encryptKeyLength, encryptKey, decryptKeyLength, decryptKey);
			StatusType::checkException(status);
		}

		const void* getEncryptKey(unsigned* length)
		{
			const void* ret = static_cast<VTable*>(this->cloopVTable)->getEncryptKey(this, length);
			return ret;
		}

		const void* getDecryptKey(unsigned* length)
		{
			const void* ret = static_cast<VTable*>(this->cloopVTable)->getDecryptKey(this, length);
			return ret;
		}
	};

	class IConfigManager : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			const char* (CLOOP_CARG *getDirectory)(IConfigManager* self, unsigned code) throw();
			IFirebirdConf* (CLOOP_CARG *getFirebirdConf)(IConfigManager* self) throw();
			IFirebirdConf* (CLOOP_CARG *getDatabaseConf)(IConfigManager* self, const char* dbName) throw();
			IConfig* (CLOOP_CARG *getPluginConfig)(IConfigManager* self, const char* configuredPlugin) throw();
			const char* (CLOOP_CARG *getInstallDirectory)(IConfigManager* self) throw();
			const char* (CLOOP_CARG *getRootDirectory)(IConfigManager* self) throw();
			const char* (CLOOP_CARG *getDefaultSecurityDb)(IConfigManager* self) throw();
		};

	protected:
		IConfigManager(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IConfigManager()
		{
		}

	public:
		static const unsigned VERSION = 3;

		static const unsigned DIR_BIN = 0;
		static const unsigned DIR_SBIN = 1;
		static const unsigned DIR_CONF = 2;
		static const unsigned DIR_LIB = 3;
		static const unsigned DIR_INC = 4;
		static const unsigned DIR_DOC = 5;
		static const unsigned DIR_UDF = 6;
		static const unsigned DIR_SAMPLE = 7;
		static const unsigned DIR_SAMPLEDB = 8;
		static const unsigned DIR_HELP = 9;
		static const unsigned DIR_INTL = 10;
		static const unsigned DIR_MISC = 11;
		static const unsigned DIR_SECDB = 12;
		static const unsigned DIR_MSG = 13;
		static const unsigned DIR_LOG = 14;
		static const unsigned DIR_GUARD = 15;
		static const unsigned DIR_PLUGINS = 16;
		static const unsigned DIR_COUNT = 17;

		const char* getDirectory(unsigned code)
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getDirectory(this, code);
			return ret;
		}

		IFirebirdConf* getFirebirdConf()
		{
			IFirebirdConf* ret = static_cast<VTable*>(this->cloopVTable)->getFirebirdConf(this);
			return ret;
		}

		IFirebirdConf* getDatabaseConf(const char* dbName)
		{
			IFirebirdConf* ret = static_cast<VTable*>(this->cloopVTable)->getDatabaseConf(this, dbName);
			return ret;
		}

		IConfig* getPluginConfig(const char* configuredPlugin)
		{
			IConfig* ret = static_cast<VTable*>(this->cloopVTable)->getPluginConfig(this, configuredPlugin);
			return ret;
		}

		const char* getInstallDirectory()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getInstallDirectory(this);
			return ret;
		}

		const char* getRootDirectory()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getRootDirectory(this);
			return ret;
		}

		const char* getDefaultSecurityDb()
		{
			if (cloopVTable->version < 3)
			{
				return 0;
			}
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getDefaultSecurityDb(this);
			return ret;
		}
	};

	class IEventCallback : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			void (CLOOP_CARG *eventCallbackFunction)(IEventCallback* self, unsigned length, const unsigned char* events) throw();
		};

	protected:
		IEventCallback(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~IEventCallback()
		{
		}

	public:
		static const unsigned VERSION = 3;

		void eventCallbackFunction(unsigned length, const unsigned char* events)
		{
			static_cast<VTable*>(this->cloopVTable)->eventCallbackFunction(this, length, events);
		}
	};

	class IBlob : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			void (CLOOP_CARG *getInfo)(IBlob* self, IStatus* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) throw();
			int (CLOOP_CARG *getSegment)(IBlob* self, IStatus* status, unsigned bufferLength, void* buffer, unsigned* segmentLength) throw();
			void (CLOOP_CARG *putSegment)(IBlob* self, IStatus* status, unsigned length, const void* buffer) throw();
			void (CLOOP_CARG *cancel)(IBlob* self, IStatus* status) throw();
			void (CLOOP_CARG *close)(IBlob* self, IStatus* status) throw();
			int (CLOOP_CARG *seek)(IBlob* self, IStatus* status, int mode, int offset) throw();
		};

	protected:
		IBlob(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~IBlob()
		{
		}

	public:
		static const unsigned VERSION = 3;

		template <typename StatusType> void getInfo(StatusType* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->getInfo(this, status, itemsLength, items, bufferLength, buffer);
			StatusType::checkException(status);
		}

		template <typename StatusType> int getSegment(StatusType* status, unsigned bufferLength, void* buffer, unsigned* segmentLength)
		{
			StatusType::clearException(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->getSegment(this, status, bufferLength, buffer, segmentLength);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> void putSegment(StatusType* status, unsigned length, const void* buffer)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->putSegment(this, status, length, buffer);
			StatusType::checkException(status);
		}

		template <typename StatusType> void cancel(StatusType* status)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->cancel(this, status);
			StatusType::checkException(status);
		}

		template <typename StatusType> void close(StatusType* status)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->close(this, status);
			StatusType::checkException(status);
		}

		template <typename StatusType> int seek(StatusType* status, int mode, int offset)
		{
			StatusType::clearException(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->seek(this, status, mode, offset);
			StatusType::checkException(status);
			return ret;
		}
	};

	class ITransaction : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			void (CLOOP_CARG *getInfo)(ITransaction* self, IStatus* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) throw();
			void (CLOOP_CARG *prepare)(ITransaction* self, IStatus* status, unsigned msgLength, const unsigned char* message) throw();
			void (CLOOP_CARG *commit)(ITransaction* self, IStatus* status) throw();
			void (CLOOP_CARG *commitRetaining)(ITransaction* self, IStatus* status) throw();
			void (CLOOP_CARG *rollback)(ITransaction* self, IStatus* status) throw();
			void (CLOOP_CARG *rollbackRetaining)(ITransaction* self, IStatus* status) throw();
			void (CLOOP_CARG *disconnect)(ITransaction* self, IStatus* status) throw();
			ITransaction* (CLOOP_CARG *join)(ITransaction* self, IStatus* status, ITransaction* transaction) throw();
			ITransaction* (CLOOP_CARG *validate)(ITransaction* self, IStatus* status, IAttachment* attachment) throw();
			ITransaction* (CLOOP_CARG *enterDtc)(ITransaction* self, IStatus* status) throw();
		};

	protected:
		ITransaction(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~ITransaction()
		{
		}

	public:
		static const unsigned VERSION = 3;

		template <typename StatusType> void getInfo(StatusType* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->getInfo(this, status, itemsLength, items, bufferLength, buffer);
			StatusType::checkException(status);
		}

		template <typename StatusType> void prepare(StatusType* status, unsigned msgLength, const unsigned char* message)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->prepare(this, status, msgLength, message);
			StatusType::checkException(status);
		}

		template <typename StatusType> void commit(StatusType* status)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->commit(this, status);
			StatusType::checkException(status);
		}

		template <typename StatusType> void commitRetaining(StatusType* status)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->commitRetaining(this, status);
			StatusType::checkException(status);
		}

		template <typename StatusType> void rollback(StatusType* status)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->rollback(this, status);
			StatusType::checkException(status);
		}

		template <typename StatusType> void rollbackRetaining(StatusType* status)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->rollbackRetaining(this, status);
			StatusType::checkException(status);
		}

		template <typename StatusType> void disconnect(StatusType* status)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->disconnect(this, status);
			StatusType::checkException(status);
		}

		template <typename StatusType> ITransaction* join(StatusType* status, ITransaction* transaction)
		{
			StatusType::clearException(status);
			ITransaction* ret = static_cast<VTable*>(this->cloopVTable)->join(this, status, transaction);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> ITransaction* validate(StatusType* status, IAttachment* attachment)
		{
			StatusType::clearException(status);
			ITransaction* ret = static_cast<VTable*>(this->cloopVTable)->validate(this, status, attachment);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> ITransaction* enterDtc(StatusType* status)
		{
			StatusType::clearException(status);
			ITransaction* ret = static_cast<VTable*>(this->cloopVTable)->enterDtc(this, status);
			StatusType::checkException(status);
			return ret;
		}
	};

	class IMessageMetadata : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			unsigned (CLOOP_CARG *getCount)(IMessageMetadata* self, IStatus* status) throw();
			const char* (CLOOP_CARG *getField)(IMessageMetadata* self, IStatus* status, unsigned index) throw();
			const char* (CLOOP_CARG *getRelation)(IMessageMetadata* self, IStatus* status, unsigned index) throw();
			const char* (CLOOP_CARG *getOwner)(IMessageMetadata* self, IStatus* status, unsigned index) throw();
			const char* (CLOOP_CARG *getAlias)(IMessageMetadata* self, IStatus* status, unsigned index) throw();
			unsigned (CLOOP_CARG *getType)(IMessageMetadata* self, IStatus* status, unsigned index) throw();
			FB_BOOLEAN (CLOOP_CARG *isNullable)(IMessageMetadata* self, IStatus* status, unsigned index) throw();
			int (CLOOP_CARG *getSubType)(IMessageMetadata* self, IStatus* status, unsigned index) throw();
			unsigned (CLOOP_CARG *getLength)(IMessageMetadata* self, IStatus* status, unsigned index) throw();
			int (CLOOP_CARG *getScale)(IMessageMetadata* self, IStatus* status, unsigned index) throw();
			unsigned (CLOOP_CARG *getCharSet)(IMessageMetadata* self, IStatus* status, unsigned index) throw();
			unsigned (CLOOP_CARG *getOffset)(IMessageMetadata* self, IStatus* status, unsigned index) throw();
			unsigned (CLOOP_CARG *getNullOffset)(IMessageMetadata* self, IStatus* status, unsigned index) throw();
			IMetadataBuilder* (CLOOP_CARG *getBuilder)(IMessageMetadata* self, IStatus* status) throw();
			unsigned (CLOOP_CARG *getMessageLength)(IMessageMetadata* self, IStatus* status) throw();
		};

	protected:
		IMessageMetadata(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~IMessageMetadata()
		{
		}

	public:
		static const unsigned VERSION = 3;

		template <typename StatusType> unsigned getCount(StatusType* status)
		{
			StatusType::clearException(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getCount(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> const char* getField(StatusType* status, unsigned index)
		{
			StatusType::clearException(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getField(this, status, index);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> const char* getRelation(StatusType* status, unsigned index)
		{
			StatusType::clearException(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getRelation(this, status, index);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> const char* getOwner(StatusType* status, unsigned index)
		{
			StatusType::clearException(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getOwner(this, status, index);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> const char* getAlias(StatusType* status, unsigned index)
		{
			StatusType::clearException(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getAlias(this, status, index);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> unsigned getType(StatusType* status, unsigned index)
		{
			StatusType::clearException(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getType(this, status, index);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> FB_BOOLEAN isNullable(StatusType* status, unsigned index)
		{
			StatusType::clearException(status);
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->isNullable(this, status, index);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> int getSubType(StatusType* status, unsigned index)
		{
			StatusType::clearException(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->getSubType(this, status, index);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> unsigned getLength(StatusType* status, unsigned index)
		{
			StatusType::clearException(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getLength(this, status, index);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> int getScale(StatusType* status, unsigned index)
		{
			StatusType::clearException(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->getScale(this, status, index);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> unsigned getCharSet(StatusType* status, unsigned index)
		{
			StatusType::clearException(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getCharSet(this, status, index);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> unsigned getOffset(StatusType* status, unsigned index)
		{
			StatusType::clearException(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getOffset(this, status, index);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> unsigned getNullOffset(StatusType* status, unsigned index)
		{
			StatusType::clearException(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getNullOffset(this, status, index);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> IMetadataBuilder* getBuilder(StatusType* status)
		{
			StatusType::clearException(status);
			IMetadataBuilder* ret = static_cast<VTable*>(this->cloopVTable)->getBuilder(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> unsigned getMessageLength(StatusType* status)
		{
			StatusType::clearException(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getMessageLength(this, status);
			StatusType::checkException(status);
			return ret;
		}
	};

	class IMetadataBuilder : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			void (CLOOP_CARG *setType)(IMetadataBuilder* self, IStatus* status, unsigned index, unsigned type) throw();
			void (CLOOP_CARG *setSubType)(IMetadataBuilder* self, IStatus* status, unsigned index, int subType) throw();
			void (CLOOP_CARG *setLength)(IMetadataBuilder* self, IStatus* status, unsigned index, unsigned length) throw();
			void (CLOOP_CARG *setCharSet)(IMetadataBuilder* self, IStatus* status, unsigned index, unsigned charSet) throw();
			void (CLOOP_CARG *setScale)(IMetadataBuilder* self, IStatus* status, unsigned index, int scale) throw();
			void (CLOOP_CARG *truncate)(IMetadataBuilder* self, IStatus* status, unsigned count) throw();
			void (CLOOP_CARG *moveNameToIndex)(IMetadataBuilder* self, IStatus* status, const char* name, unsigned index) throw();
			void (CLOOP_CARG *remove)(IMetadataBuilder* self, IStatus* status, unsigned index) throw();
			unsigned (CLOOP_CARG *addField)(IMetadataBuilder* self, IStatus* status) throw();
			IMessageMetadata* (CLOOP_CARG *getMetadata)(IMetadataBuilder* self, IStatus* status) throw();
		};

	protected:
		IMetadataBuilder(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~IMetadataBuilder()
		{
		}

	public:
		static const unsigned VERSION = 3;

		template <typename StatusType> void setType(StatusType* status, unsigned index, unsigned type)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->setType(this, status, index, type);
			StatusType::checkException(status);
		}

		template <typename StatusType> void setSubType(StatusType* status, unsigned index, int subType)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->setSubType(this, status, index, subType);
			StatusType::checkException(status);
		}

		template <typename StatusType> void setLength(StatusType* status, unsigned index, unsigned length)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->setLength(this, status, index, length);
			StatusType::checkException(status);
		}

		template <typename StatusType> void setCharSet(StatusType* status, unsigned index, unsigned charSet)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->setCharSet(this, status, index, charSet);
			StatusType::checkException(status);
		}

		template <typename StatusType> void setScale(StatusType* status, unsigned index, int scale)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->setScale(this, status, index, scale);
			StatusType::checkException(status);
		}

		template <typename StatusType> void truncate(StatusType* status, unsigned count)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->truncate(this, status, count);
			StatusType::checkException(status);
		}

		template <typename StatusType> void moveNameToIndex(StatusType* status, const char* name, unsigned index)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->moveNameToIndex(this, status, name, index);
			StatusType::checkException(status);
		}

		template <typename StatusType> void remove(StatusType* status, unsigned index)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->remove(this, status, index);
			StatusType::checkException(status);
		}

		template <typename StatusType> unsigned addField(StatusType* status)
		{
			StatusType::clearException(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->addField(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> IMessageMetadata* getMetadata(StatusType* status)
		{
			StatusType::clearException(status);
			IMessageMetadata* ret = static_cast<VTable*>(this->cloopVTable)->getMetadata(this, status);
			StatusType::checkException(status);
			return ret;
		}
	};

	class IResultSet : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			int (CLOOP_CARG *fetchNext)(IResultSet* self, IStatus* status, void* message) throw();
			int (CLOOP_CARG *fetchPrior)(IResultSet* self, IStatus* status, void* message) throw();
			int (CLOOP_CARG *fetchFirst)(IResultSet* self, IStatus* status, void* message) throw();
			int (CLOOP_CARG *fetchLast)(IResultSet* self, IStatus* status, void* message) throw();
			int (CLOOP_CARG *fetchAbsolute)(IResultSet* self, IStatus* status, int position, void* message) throw();
			int (CLOOP_CARG *fetchRelative)(IResultSet* self, IStatus* status, int offset, void* message) throw();
			FB_BOOLEAN (CLOOP_CARG *isEof)(IResultSet* self, IStatus* status) throw();
			FB_BOOLEAN (CLOOP_CARG *isBof)(IResultSet* self, IStatus* status) throw();
			IMessageMetadata* (CLOOP_CARG *getMetadata)(IResultSet* self, IStatus* status) throw();
			void (CLOOP_CARG *close)(IResultSet* self, IStatus* status) throw();
			void (CLOOP_CARG *setDelayedOutputFormat)(IResultSet* self, IStatus* status, IMessageMetadata* format) throw();
		};

	protected:
		IResultSet(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~IResultSet()
		{
		}

	public:
		static const unsigned VERSION = 3;

		template <typename StatusType> int fetchNext(StatusType* status, void* message)
		{
			StatusType::clearException(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->fetchNext(this, status, message);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> int fetchPrior(StatusType* status, void* message)
		{
			StatusType::clearException(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->fetchPrior(this, status, message);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> int fetchFirst(StatusType* status, void* message)
		{
			StatusType::clearException(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->fetchFirst(this, status, message);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> int fetchLast(StatusType* status, void* message)
		{
			StatusType::clearException(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->fetchLast(this, status, message);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> int fetchAbsolute(StatusType* status, int position, void* message)
		{
			StatusType::clearException(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->fetchAbsolute(this, status, position, message);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> int fetchRelative(StatusType* status, int offset, void* message)
		{
			StatusType::clearException(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->fetchRelative(this, status, offset, message);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> FB_BOOLEAN isEof(StatusType* status)
		{
			StatusType::clearException(status);
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->isEof(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> FB_BOOLEAN isBof(StatusType* status)
		{
			StatusType::clearException(status);
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->isBof(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> IMessageMetadata* getMetadata(StatusType* status)
		{
			StatusType::clearException(status);
			IMessageMetadata* ret = static_cast<VTable*>(this->cloopVTable)->getMetadata(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> void close(StatusType* status)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->close(this, status);
			StatusType::checkException(status);
		}

		template <typename StatusType> void setDelayedOutputFormat(StatusType* status, IMessageMetadata* format)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->setDelayedOutputFormat(this, status, format);
			StatusType::checkException(status);
		}
	};

	class IStatement : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			void (CLOOP_CARG *getInfo)(IStatement* self, IStatus* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) throw();
			unsigned (CLOOP_CARG *getType)(IStatement* self, IStatus* status) throw();
			const char* (CLOOP_CARG *getPlan)(IStatement* self, IStatus* status, FB_BOOLEAN detailed) throw();
			ISC_UINT64 (CLOOP_CARG *getAffectedRecords)(IStatement* self, IStatus* status) throw();
			IMessageMetadata* (CLOOP_CARG *getInputMetadata)(IStatement* self, IStatus* status) throw();
			IMessageMetadata* (CLOOP_CARG *getOutputMetadata)(IStatement* self, IStatus* status) throw();
			ITransaction* (CLOOP_CARG *execute)(IStatement* self, IStatus* status, ITransaction* transaction, IMessageMetadata* inMetadata, void* inBuffer, IMessageMetadata* outMetadata, void* outBuffer) throw();
			IResultSet* (CLOOP_CARG *openCursor)(IStatement* self, IStatus* status, ITransaction* transaction, IMessageMetadata* inMetadata, void* inBuffer, IMessageMetadata* outMetadata, unsigned flags) throw();
			void (CLOOP_CARG *setCursorName)(IStatement* self, IStatus* status, const char* name) throw();
			void (CLOOP_CARG *free)(IStatement* self, IStatus* status) throw();
			unsigned (CLOOP_CARG *getFlags)(IStatement* self, IStatus* status) throw();
		};

	protected:
		IStatement(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~IStatement()
		{
		}

	public:
		static const unsigned VERSION = 3;

		static const unsigned PREPARE_PREFETCH_NONE = 0x0;
		static const unsigned PREPARE_PREFETCH_TYPE = 0x1;
		static const unsigned PREPARE_PREFETCH_INPUT_PARAMETERS = 0x2;
		static const unsigned PREPARE_PREFETCH_OUTPUT_PARAMETERS = 0x4;
		static const unsigned PREPARE_PREFETCH_LEGACY_PLAN = 0x8;
		static const unsigned PREPARE_PREFETCH_DETAILED_PLAN = 0x10;
		static const unsigned PREPARE_PREFETCH_AFFECTED_RECORDS = 0x20;
		static const unsigned PREPARE_PREFETCH_FLAGS = 0x40;
		static const unsigned PREPARE_PREFETCH_METADATA = IStatement::PREPARE_PREFETCH_TYPE | IStatement::PREPARE_PREFETCH_FLAGS | IStatement::PREPARE_PREFETCH_INPUT_PARAMETERS | IStatement::PREPARE_PREFETCH_OUTPUT_PARAMETERS;
		static const unsigned PREPARE_PREFETCH_ALL = IStatement::PREPARE_PREFETCH_METADATA | IStatement::PREPARE_PREFETCH_LEGACY_PLAN | IStatement::PREPARE_PREFETCH_DETAILED_PLAN | IStatement::PREPARE_PREFETCH_AFFECTED_RECORDS;
		static const unsigned FLAG_HAS_CURSOR = 0x1;
		static const unsigned FLAG_REPEAT_EXECUTE = 0x2;
		static const unsigned CURSOR_TYPE_SCROLLABLE = 0x1;

		template <typename StatusType> void getInfo(StatusType* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->getInfo(this, status, itemsLength, items, bufferLength, buffer);
			StatusType::checkException(status);
		}

		template <typename StatusType> unsigned getType(StatusType* status)
		{
			StatusType::clearException(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getType(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> const char* getPlan(StatusType* status, FB_BOOLEAN detailed)
		{
			StatusType::clearException(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getPlan(this, status, detailed);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> ISC_UINT64 getAffectedRecords(StatusType* status)
		{
			StatusType::clearException(status);
			ISC_UINT64 ret = static_cast<VTable*>(this->cloopVTable)->getAffectedRecords(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> IMessageMetadata* getInputMetadata(StatusType* status)
		{
			StatusType::clearException(status);
			IMessageMetadata* ret = static_cast<VTable*>(this->cloopVTable)->getInputMetadata(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> IMessageMetadata* getOutputMetadata(StatusType* status)
		{
			StatusType::clearException(status);
			IMessageMetadata* ret = static_cast<VTable*>(this->cloopVTable)->getOutputMetadata(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> ITransaction* execute(StatusType* status, ITransaction* transaction, IMessageMetadata* inMetadata, void* inBuffer, IMessageMetadata* outMetadata, void* outBuffer)
		{
			StatusType::clearException(status);
			ITransaction* ret = static_cast<VTable*>(this->cloopVTable)->execute(this, status, transaction, inMetadata, inBuffer, outMetadata, outBuffer);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> IResultSet* openCursor(StatusType* status, ITransaction* transaction, IMessageMetadata* inMetadata, void* inBuffer, IMessageMetadata* outMetadata, unsigned flags)
		{
			StatusType::clearException(status);
			IResultSet* ret = static_cast<VTable*>(this->cloopVTable)->openCursor(this, status, transaction, inMetadata, inBuffer, outMetadata, flags);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> void setCursorName(StatusType* status, const char* name)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->setCursorName(this, status, name);
			StatusType::checkException(status);
		}

		template <typename StatusType> void free(StatusType* status)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->free(this, status);
			StatusType::checkException(status);
		}

		template <typename StatusType> unsigned getFlags(StatusType* status)
		{
			StatusType::clearException(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getFlags(this, status);
			StatusType::checkException(status);
			return ret;
		}
	};

	class IRequest : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			void (CLOOP_CARG *receive)(IRequest* self, IStatus* status, int level, unsigned msgType, unsigned length, unsigned char* message) throw();
			void (CLOOP_CARG *send)(IRequest* self, IStatus* status, int level, unsigned msgType, unsigned length, const unsigned char* message) throw();
			void (CLOOP_CARG *getInfo)(IRequest* self, IStatus* status, int level, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) throw();
			void (CLOOP_CARG *start)(IRequest* self, IStatus* status, ITransaction* tra, int level) throw();
			void (CLOOP_CARG *startAndSend)(IRequest* self, IStatus* status, ITransaction* tra, int level, unsigned msgType, unsigned length, const unsigned char* message) throw();
			void (CLOOP_CARG *unwind)(IRequest* self, IStatus* status, int level) throw();
			void (CLOOP_CARG *free)(IRequest* self, IStatus* status) throw();
		};

	protected:
		IRequest(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~IRequest()
		{
		}

	public:
		static const unsigned VERSION = 3;

		template <typename StatusType> void receive(StatusType* status, int level, unsigned msgType, unsigned length, unsigned char* message)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->receive(this, status, level, msgType, length, message);
			StatusType::checkException(status);
		}

		template <typename StatusType> void send(StatusType* status, int level, unsigned msgType, unsigned length, const unsigned char* message)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->send(this, status, level, msgType, length, message);
			StatusType::checkException(status);
		}

		template <typename StatusType> void getInfo(StatusType* status, int level, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->getInfo(this, status, level, itemsLength, items, bufferLength, buffer);
			StatusType::checkException(status);
		}

		template <typename StatusType> void start(StatusType* status, ITransaction* tra, int level)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->start(this, status, tra, level);
			StatusType::checkException(status);
		}

		template <typename StatusType> void startAndSend(StatusType* status, ITransaction* tra, int level, unsigned msgType, unsigned length, const unsigned char* message)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->startAndSend(this, status, tra, level, msgType, length, message);
			StatusType::checkException(status);
		}

		template <typename StatusType> void unwind(StatusType* status, int level)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->unwind(this, status, level);
			StatusType::checkException(status);
		}

		template <typename StatusType> void free(StatusType* status)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->free(this, status);
			StatusType::checkException(status);
		}
	};

	class IEvents : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			void (CLOOP_CARG *cancel)(IEvents* self, IStatus* status) throw();
		};

	protected:
		IEvents(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~IEvents()
		{
		}

	public:
		static const unsigned VERSION = 3;

		template <typename StatusType> void cancel(StatusType* status)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->cancel(this, status);
			StatusType::checkException(status);
		}
	};

	class IAttachment : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			void (CLOOP_CARG *getInfo)(IAttachment* self, IStatus* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) throw();
			ITransaction* (CLOOP_CARG *startTransaction)(IAttachment* self, IStatus* status, unsigned tpbLength, const unsigned char* tpb) throw();
			ITransaction* (CLOOP_CARG *reconnectTransaction)(IAttachment* self, IStatus* status, unsigned length, const unsigned char* id) throw();
			IRequest* (CLOOP_CARG *compileRequest)(IAttachment* self, IStatus* status, unsigned blrLength, const unsigned char* blr) throw();
			void (CLOOP_CARG *transactRequest)(IAttachment* self, IStatus* status, ITransaction* transaction, unsigned blrLength, const unsigned char* blr, unsigned inMsgLength, const unsigned char* inMsg, unsigned outMsgLength, unsigned char* outMsg) throw();
			IBlob* (CLOOP_CARG *createBlob)(IAttachment* self, IStatus* status, ITransaction* transaction, ISC_QUAD* id, unsigned bpbLength, const unsigned char* bpb) throw();
			IBlob* (CLOOP_CARG *openBlob)(IAttachment* self, IStatus* status, ITransaction* transaction, ISC_QUAD* id, unsigned bpbLength, const unsigned char* bpb) throw();
			int (CLOOP_CARG *getSlice)(IAttachment* self, IStatus* status, ITransaction* transaction, ISC_QUAD* id, unsigned sdlLength, const unsigned char* sdl, unsigned paramLength, const unsigned char* param, int sliceLength, unsigned char* slice) throw();
			void (CLOOP_CARG *putSlice)(IAttachment* self, IStatus* status, ITransaction* transaction, ISC_QUAD* id, unsigned sdlLength, const unsigned char* sdl, unsigned paramLength, const unsigned char* param, int sliceLength, unsigned char* slice) throw();
			void (CLOOP_CARG *executeDyn)(IAttachment* self, IStatus* status, ITransaction* transaction, unsigned length, const unsigned char* dyn) throw();
			IStatement* (CLOOP_CARG *prepare)(IAttachment* self, IStatus* status, ITransaction* tra, unsigned stmtLength, const char* sqlStmt, unsigned dialect, unsigned flags) throw();
			ITransaction* (CLOOP_CARG *execute)(IAttachment* self, IStatus* status, ITransaction* transaction, unsigned stmtLength, const char* sqlStmt, unsigned dialect, IMessageMetadata* inMetadata, void* inBuffer, IMessageMetadata* outMetadata, void* outBuffer) throw();
			IResultSet* (CLOOP_CARG *openCursor)(IAttachment* self, IStatus* status, ITransaction* transaction, unsigned stmtLength, const char* sqlStmt, unsigned dialect, IMessageMetadata* inMetadata, void* inBuffer, IMessageMetadata* outMetadata, const char* cursorName, unsigned cursorFlags) throw();
			IEvents* (CLOOP_CARG *queEvents)(IAttachment* self, IStatus* status, IEventCallback* callback, unsigned length, const unsigned char* events) throw();
			void (CLOOP_CARG *cancelOperation)(IAttachment* self, IStatus* status, int option) throw();
			void (CLOOP_CARG *ping)(IAttachment* self, IStatus* status) throw();
			void (CLOOP_CARG *detach)(IAttachment* self, IStatus* status) throw();
			void (CLOOP_CARG *dropDatabase)(IAttachment* self, IStatus* status) throw();
		};

	protected:
		IAttachment(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~IAttachment()
		{
		}

	public:
		static const unsigned VERSION = 3;

		template <typename StatusType> void getInfo(StatusType* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->getInfo(this, status, itemsLength, items, bufferLength, buffer);
			StatusType::checkException(status);
		}

		template <typename StatusType> ITransaction* startTransaction(StatusType* status, unsigned tpbLength, const unsigned char* tpb)
		{
			StatusType::clearException(status);
			ITransaction* ret = static_cast<VTable*>(this->cloopVTable)->startTransaction(this, status, tpbLength, tpb);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> ITransaction* reconnectTransaction(StatusType* status, unsigned length, const unsigned char* id)
		{
			StatusType::clearException(status);
			ITransaction* ret = static_cast<VTable*>(this->cloopVTable)->reconnectTransaction(this, status, length, id);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> IRequest* compileRequest(StatusType* status, unsigned blrLength, const unsigned char* blr)
		{
			StatusType::clearException(status);
			IRequest* ret = static_cast<VTable*>(this->cloopVTable)->compileRequest(this, status, blrLength, blr);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> void transactRequest(StatusType* status, ITransaction* transaction, unsigned blrLength, const unsigned char* blr, unsigned inMsgLength, const unsigned char* inMsg, unsigned outMsgLength, unsigned char* outMsg)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->transactRequest(this, status, transaction, blrLength, blr, inMsgLength, inMsg, outMsgLength, outMsg);
			StatusType::checkException(status);
		}

		template <typename StatusType> IBlob* createBlob(StatusType* status, ITransaction* transaction, ISC_QUAD* id, unsigned bpbLength, const unsigned char* bpb)
		{
			StatusType::clearException(status);
			IBlob* ret = static_cast<VTable*>(this->cloopVTable)->createBlob(this, status, transaction, id, bpbLength, bpb);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> IBlob* openBlob(StatusType* status, ITransaction* transaction, ISC_QUAD* id, unsigned bpbLength, const unsigned char* bpb)
		{
			StatusType::clearException(status);
			IBlob* ret = static_cast<VTable*>(this->cloopVTable)->openBlob(this, status, transaction, id, bpbLength, bpb);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> int getSlice(StatusType* status, ITransaction* transaction, ISC_QUAD* id, unsigned sdlLength, const unsigned char* sdl, unsigned paramLength, const unsigned char* param, int sliceLength, unsigned char* slice)
		{
			StatusType::clearException(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->getSlice(this, status, transaction, id, sdlLength, sdl, paramLength, param, sliceLength, slice);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> void putSlice(StatusType* status, ITransaction* transaction, ISC_QUAD* id, unsigned sdlLength, const unsigned char* sdl, unsigned paramLength, const unsigned char* param, int sliceLength, unsigned char* slice)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->putSlice(this, status, transaction, id, sdlLength, sdl, paramLength, param, sliceLength, slice);
			StatusType::checkException(status);
		}

		template <typename StatusType> void executeDyn(StatusType* status, ITransaction* transaction, unsigned length, const unsigned char* dyn)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->executeDyn(this, status, transaction, length, dyn);
			StatusType::checkException(status);
		}

		template <typename StatusType> IStatement* prepare(StatusType* status, ITransaction* tra, unsigned stmtLength, const char* sqlStmt, unsigned dialect, unsigned flags)
		{
			StatusType::clearException(status);
			IStatement* ret = static_cast<VTable*>(this->cloopVTable)->prepare(this, status, tra, stmtLength, sqlStmt, dialect, flags);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> ITransaction* execute(StatusType* status, ITransaction* transaction, unsigned stmtLength, const char* sqlStmt, unsigned dialect, IMessageMetadata* inMetadata, void* inBuffer, IMessageMetadata* outMetadata, void* outBuffer)
		{
			StatusType::clearException(status);
			ITransaction* ret = static_cast<VTable*>(this->cloopVTable)->execute(this, status, transaction, stmtLength, sqlStmt, dialect, inMetadata, inBuffer, outMetadata, outBuffer);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> IResultSet* openCursor(StatusType* status, ITransaction* transaction, unsigned stmtLength, const char* sqlStmt, unsigned dialect, IMessageMetadata* inMetadata, void* inBuffer, IMessageMetadata* outMetadata, const char* cursorName, unsigned cursorFlags)
		{
			StatusType::clearException(status);
			IResultSet* ret = static_cast<VTable*>(this->cloopVTable)->openCursor(this, status, transaction, stmtLength, sqlStmt, dialect, inMetadata, inBuffer, outMetadata, cursorName, cursorFlags);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> IEvents* queEvents(StatusType* status, IEventCallback* callback, unsigned length, const unsigned char* events)
		{
			StatusType::clearException(status);
			IEvents* ret = static_cast<VTable*>(this->cloopVTable)->queEvents(this, status, callback, length, events);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> void cancelOperation(StatusType* status, int option)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->cancelOperation(this, status, option);
			StatusType::checkException(status);
		}

		template <typename StatusType> void ping(StatusType* status)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->ping(this, status);
			StatusType::checkException(status);
		}

		template <typename StatusType> void detach(StatusType* status)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->detach(this, status);
			StatusType::checkException(status);
		}

		template <typename StatusType> void dropDatabase(StatusType* status)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->dropDatabase(this, status);
			StatusType::checkException(status);
		}
	};

	class IService : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			void (CLOOP_CARG *detach)(IService* self, IStatus* status) throw();
			void (CLOOP_CARG *query)(IService* self, IStatus* status, unsigned sendLength, const unsigned char* sendItems, unsigned receiveLength, const unsigned char* receiveItems, unsigned bufferLength, unsigned char* buffer) throw();
			void (CLOOP_CARG *start)(IService* self, IStatus* status, unsigned spbLength, const unsigned char* spb) throw();
		};

	protected:
		IService(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~IService()
		{
		}

	public:
		static const unsigned VERSION = 3;

		template <typename StatusType> void detach(StatusType* status)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->detach(this, status);
			StatusType::checkException(status);
		}

		template <typename StatusType> void query(StatusType* status, unsigned sendLength, const unsigned char* sendItems, unsigned receiveLength, const unsigned char* receiveItems, unsigned bufferLength, unsigned char* buffer)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->query(this, status, sendLength, sendItems, receiveLength, receiveItems, bufferLength, buffer);
			StatusType::checkException(status);
		}

		template <typename StatusType> void start(StatusType* status, unsigned spbLength, const unsigned char* spb)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->start(this, status, spbLength, spb);
			StatusType::checkException(status);
		}
	};

	class IProvider : public IPluginBase
	{
	public:
		struct VTable : public IPluginBase::VTable
		{
			IAttachment* (CLOOP_CARG *attachDatabase)(IProvider* self, IStatus* status, const char* fileName, unsigned dpbLength, const unsigned char* dpb) throw();
			IAttachment* (CLOOP_CARG *createDatabase)(IProvider* self, IStatus* status, const char* fileName, unsigned dpbLength, const unsigned char* dpb) throw();
			IService* (CLOOP_CARG *attachServiceManager)(IProvider* self, IStatus* status, const char* service, unsigned spbLength, const unsigned char* spb) throw();
			void (CLOOP_CARG *shutdown)(IProvider* self, IStatus* status, unsigned timeout, const int reason) throw();
			void (CLOOP_CARG *setDbCryptCallback)(IProvider* self, IStatus* status, ICryptKeyCallback* cryptCallback) throw();
		};

	protected:
		IProvider(DoNotInherit)
			: IPluginBase(DoNotInherit())
		{
		}

		~IProvider()
		{
		}

	public:
		static const unsigned VERSION = 4;

		template <typename StatusType> IAttachment* attachDatabase(StatusType* status, const char* fileName, unsigned dpbLength, const unsigned char* dpb)
		{
			StatusType::clearException(status);
			IAttachment* ret = static_cast<VTable*>(this->cloopVTable)->attachDatabase(this, status, fileName, dpbLength, dpb);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> IAttachment* createDatabase(StatusType* status, const char* fileName, unsigned dpbLength, const unsigned char* dpb)
		{
			StatusType::clearException(status);
			IAttachment* ret = static_cast<VTable*>(this->cloopVTable)->createDatabase(this, status, fileName, dpbLength, dpb);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> IService* attachServiceManager(StatusType* status, const char* service, unsigned spbLength, const unsigned char* spb)
		{
			StatusType::clearException(status);
			IService* ret = static_cast<VTable*>(this->cloopVTable)->attachServiceManager(this, status, service, spbLength, spb);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> void shutdown(StatusType* status, unsigned timeout, const int reason)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->shutdown(this, status, timeout, reason);
			StatusType::checkException(status);
		}

		template <typename StatusType> void setDbCryptCallback(StatusType* status, ICryptKeyCallback* cryptCallback)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->setDbCryptCallback(this, status, cryptCallback);
			StatusType::checkException(status);
		}
	};

	class IDtcStart : public IDisposable
	{
	public:
		struct VTable : public IDisposable::VTable
		{
			void (CLOOP_CARG *addAttachment)(IDtcStart* self, IStatus* status, IAttachment* att) throw();
			void (CLOOP_CARG *addWithTpb)(IDtcStart* self, IStatus* status, IAttachment* att, unsigned length, const unsigned char* tpb) throw();
			ITransaction* (CLOOP_CARG *start)(IDtcStart* self, IStatus* status) throw();
		};

	protected:
		IDtcStart(DoNotInherit)
			: IDisposable(DoNotInherit())
		{
		}

		~IDtcStart()
		{
		}

	public:
		static const unsigned VERSION = 3;

		template <typename StatusType> void addAttachment(StatusType* status, IAttachment* att)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->addAttachment(this, status, att);
			StatusType::checkException(status);
		}

		template <typename StatusType> void addWithTpb(StatusType* status, IAttachment* att, unsigned length, const unsigned char* tpb)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->addWithTpb(this, status, att, length, tpb);
			StatusType::checkException(status);
		}

		template <typename StatusType> ITransaction* start(StatusType* status)
		{
			StatusType::clearException(status);
			ITransaction* ret = static_cast<VTable*>(this->cloopVTable)->start(this, status);
			StatusType::checkException(status);
			return ret;
		}
	};

	class IDtc : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			ITransaction* (CLOOP_CARG *join)(IDtc* self, IStatus* status, ITransaction* one, ITransaction* two) throw();
			IDtcStart* (CLOOP_CARG *startBuilder)(IDtc* self, IStatus* status) throw();
		};

	protected:
		IDtc(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IDtc()
		{
		}

	public:
		static const unsigned VERSION = 2;

		template <typename StatusType> ITransaction* join(StatusType* status, ITransaction* one, ITransaction* two)
		{
			StatusType::clearException(status);
			ITransaction* ret = static_cast<VTable*>(this->cloopVTable)->join(this, status, one, two);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> IDtcStart* startBuilder(StatusType* status)
		{
			StatusType::clearException(status);
			IDtcStart* ret = static_cast<VTable*>(this->cloopVTable)->startBuilder(this, status);
			StatusType::checkException(status);
			return ret;
		}
	};

	class IAuth : public IPluginBase
	{
	public:
		struct VTable : public IPluginBase::VTable
		{
		};

	protected:
		IAuth(DoNotInherit)
			: IPluginBase(DoNotInherit())
		{
		}

		~IAuth()
		{
		}

	public:
		static const unsigned VERSION = 4;

		static const int AUTH_FAILED = -1;
		static const int AUTH_SUCCESS = 0;
		static const int AUTH_MORE_DATA = 1;
		static const int AUTH_CONTINUE = 2;
	};

	class IWriter : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			void (CLOOP_CARG *reset)(IWriter* self) throw();
			void (CLOOP_CARG *add)(IWriter* self, IStatus* status, const char* name) throw();
			void (CLOOP_CARG *setType)(IWriter* self, IStatus* status, const char* value) throw();
			void (CLOOP_CARG *setDb)(IWriter* self, IStatus* status, const char* value) throw();
		};

	protected:
		IWriter(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IWriter()
		{
		}

	public:
		static const unsigned VERSION = 2;

		void reset()
		{
			static_cast<VTable*>(this->cloopVTable)->reset(this);
		}

		template <typename StatusType> void add(StatusType* status, const char* name)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->add(this, status, name);
			StatusType::checkException(status);
		}

		template <typename StatusType> void setType(StatusType* status, const char* value)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->setType(this, status, value);
			StatusType::checkException(status);
		}

		template <typename StatusType> void setDb(StatusType* status, const char* value)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->setDb(this, status, value);
			StatusType::checkException(status);
		}
	};

	class IServerBlock : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			const char* (CLOOP_CARG *getLogin)(IServerBlock* self) throw();
			const unsigned char* (CLOOP_CARG *getData)(IServerBlock* self, unsigned* length) throw();
			void (CLOOP_CARG *putData)(IServerBlock* self, IStatus* status, unsigned length, const void* data) throw();
			ICryptKey* (CLOOP_CARG *newKey)(IServerBlock* self, IStatus* status) throw();
		};

	protected:
		IServerBlock(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IServerBlock()
		{
		}

	public:
		static const unsigned VERSION = 2;

		const char* getLogin()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getLogin(this);
			return ret;
		}

		const unsigned char* getData(unsigned* length)
		{
			const unsigned char* ret = static_cast<VTable*>(this->cloopVTable)->getData(this, length);
			return ret;
		}

		template <typename StatusType> void putData(StatusType* status, unsigned length, const void* data)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->putData(this, status, length, data);
			StatusType::checkException(status);
		}

		template <typename StatusType> ICryptKey* newKey(StatusType* status)
		{
			StatusType::clearException(status);
			ICryptKey* ret = static_cast<VTable*>(this->cloopVTable)->newKey(this, status);
			StatusType::checkException(status);
			return ret;
		}
	};

	class IClientBlock : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			const char* (CLOOP_CARG *getLogin)(IClientBlock* self) throw();
			const char* (CLOOP_CARG *getPassword)(IClientBlock* self) throw();
			const unsigned char* (CLOOP_CARG *getData)(IClientBlock* self, unsigned* length) throw();
			void (CLOOP_CARG *putData)(IClientBlock* self, IStatus* status, unsigned length, const void* data) throw();
			ICryptKey* (CLOOP_CARG *newKey)(IClientBlock* self, IStatus* status) throw();
			IAuthBlock* (CLOOP_CARG *getAuthBlock)(IClientBlock* self, IStatus* status) throw();
		};

	protected:
		IClientBlock(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~IClientBlock()
		{
		}

	public:
		static const unsigned VERSION = 4;

		const char* getLogin()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getLogin(this);
			return ret;
		}

		const char* getPassword()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getPassword(this);
			return ret;
		}

		const unsigned char* getData(unsigned* length)
		{
			const unsigned char* ret = static_cast<VTable*>(this->cloopVTable)->getData(this, length);
			return ret;
		}

		template <typename StatusType> void putData(StatusType* status, unsigned length, const void* data)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->putData(this, status, length, data);
			StatusType::checkException(status);
		}

		template <typename StatusType> ICryptKey* newKey(StatusType* status)
		{
			StatusType::clearException(status);
			ICryptKey* ret = static_cast<VTable*>(this->cloopVTable)->newKey(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> IAuthBlock* getAuthBlock(StatusType* status)
		{
			if (cloopVTable->version < 4)
			{
				StatusType::setVersionError(status, "IClientBlock", cloopVTable->version, 4);
				StatusType::checkException(status);
				return 0;
			}
			StatusType::clearException(status);
			IAuthBlock* ret = static_cast<VTable*>(this->cloopVTable)->getAuthBlock(this, status);
			StatusType::checkException(status);
			return ret;
		}
	};

	class IServer : public IAuth
	{
	public:
		struct VTable : public IAuth::VTable
		{
			int (CLOOP_CARG *authenticate)(IServer* self, IStatus* status, IServerBlock* sBlock, IWriter* writerInterface) throw();
			void (CLOOP_CARG *setDbCryptCallback)(IServer* self, IStatus* status, ICryptKeyCallback* cryptCallback) throw();
		};

	protected:
		IServer(DoNotInherit)
			: IAuth(DoNotInherit())
		{
		}

		~IServer()
		{
		}

	public:
		static const unsigned VERSION = 6;

		template <typename StatusType> int authenticate(StatusType* status, IServerBlock* sBlock, IWriter* writerInterface)
		{
			StatusType::clearException(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->authenticate(this, status, sBlock, writerInterface);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> void setDbCryptCallback(StatusType* status, ICryptKeyCallback* cryptCallback)
		{
			if (cloopVTable->version < 6)
			{
				StatusType::setVersionError(status, "IServer", cloopVTable->version, 6);
				StatusType::checkException(status);
				return;
			}
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->setDbCryptCallback(this, status, cryptCallback);
			StatusType::checkException(status);
		}
	};

	class IClient : public IAuth
	{
	public:
		struct VTable : public IAuth::VTable
		{
			int (CLOOP_CARG *authenticate)(IClient* self, IStatus* status, IClientBlock* cBlock) throw();
		};

	protected:
		IClient(DoNotInherit)
			: IAuth(DoNotInherit())
		{
		}

		~IClient()
		{
		}

	public:
		static const unsigned VERSION = 5;

		template <typename StatusType> int authenticate(StatusType* status, IClientBlock* cBlock)
		{
			StatusType::clearException(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->authenticate(this, status, cBlock);
			StatusType::checkException(status);
			return ret;
		}
	};

	class IUserField : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			int (CLOOP_CARG *entered)(IUserField* self) throw();
			int (CLOOP_CARG *specified)(IUserField* self) throw();
			void (CLOOP_CARG *setEntered)(IUserField* self, IStatus* status, int newValue) throw();
		};

	protected:
		IUserField(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IUserField()
		{
		}

	public:
		static const unsigned VERSION = 2;

		int entered()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->entered(this);
			return ret;
		}

		int specified()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->specified(this);
			return ret;
		}

		template <typename StatusType> void setEntered(StatusType* status, int newValue)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->setEntered(this, status, newValue);
			StatusType::checkException(status);
		}
	};

	class ICharUserField : public IUserField
	{
	public:
		struct VTable : public IUserField::VTable
		{
			const char* (CLOOP_CARG *get)(ICharUserField* self) throw();
			void (CLOOP_CARG *set)(ICharUserField* self, IStatus* status, const char* newValue) throw();
		};

	protected:
		ICharUserField(DoNotInherit)
			: IUserField(DoNotInherit())
		{
		}

		~ICharUserField()
		{
		}

	public:
		static const unsigned VERSION = 3;

		const char* get()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->get(this);
			return ret;
		}

		template <typename StatusType> void set(StatusType* status, const char* newValue)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->set(this, status, newValue);
			StatusType::checkException(status);
		}
	};

	class IIntUserField : public IUserField
	{
	public:
		struct VTable : public IUserField::VTable
		{
			int (CLOOP_CARG *get)(IIntUserField* self) throw();
			void (CLOOP_CARG *set)(IIntUserField* self, IStatus* status, int newValue) throw();
		};

	protected:
		IIntUserField(DoNotInherit)
			: IUserField(DoNotInherit())
		{
		}

		~IIntUserField()
		{
		}

	public:
		static const unsigned VERSION = 3;

		int get()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->get(this);
			return ret;
		}

		template <typename StatusType> void set(StatusType* status, int newValue)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->set(this, status, newValue);
			StatusType::checkException(status);
		}
	};

	class IUser : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			unsigned (CLOOP_CARG *operation)(IUser* self) throw();
			ICharUserField* (CLOOP_CARG *userName)(IUser* self) throw();
			ICharUserField* (CLOOP_CARG *password)(IUser* self) throw();
			ICharUserField* (CLOOP_CARG *firstName)(IUser* self) throw();
			ICharUserField* (CLOOP_CARG *lastName)(IUser* self) throw();
			ICharUserField* (CLOOP_CARG *middleName)(IUser* self) throw();
			ICharUserField* (CLOOP_CARG *comment)(IUser* self) throw();
			ICharUserField* (CLOOP_CARG *attributes)(IUser* self) throw();
			IIntUserField* (CLOOP_CARG *active)(IUser* self) throw();
			IIntUserField* (CLOOP_CARG *admin)(IUser* self) throw();
			void (CLOOP_CARG *clear)(IUser* self, IStatus* status) throw();
		};

	protected:
		IUser(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IUser()
		{
		}

	public:
		static const unsigned VERSION = 2;

		static const unsigned OP_USER_ADD = 1;
		static const unsigned OP_USER_MODIFY = 2;
		static const unsigned OP_USER_DELETE = 3;
		static const unsigned OP_USER_DISPLAY = 4;
		static const unsigned OP_USER_SET_MAP = 5;
		static const unsigned OP_USER_DROP_MAP = 6;

		unsigned operation()
		{
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->operation(this);
			return ret;
		}

		ICharUserField* userName()
		{
			ICharUserField* ret = static_cast<VTable*>(this->cloopVTable)->userName(this);
			return ret;
		}

		ICharUserField* password()
		{
			ICharUserField* ret = static_cast<VTable*>(this->cloopVTable)->password(this);
			return ret;
		}

		ICharUserField* firstName()
		{
			ICharUserField* ret = static_cast<VTable*>(this->cloopVTable)->firstName(this);
			return ret;
		}

		ICharUserField* lastName()
		{
			ICharUserField* ret = static_cast<VTable*>(this->cloopVTable)->lastName(this);
			return ret;
		}

		ICharUserField* middleName()
		{
			ICharUserField* ret = static_cast<VTable*>(this->cloopVTable)->middleName(this);
			return ret;
		}

		ICharUserField* comment()
		{
			ICharUserField* ret = static_cast<VTable*>(this->cloopVTable)->comment(this);
			return ret;
		}

		ICharUserField* attributes()
		{
			ICharUserField* ret = static_cast<VTable*>(this->cloopVTable)->attributes(this);
			return ret;
		}

		IIntUserField* active()
		{
			IIntUserField* ret = static_cast<VTable*>(this->cloopVTable)->active(this);
			return ret;
		}

		IIntUserField* admin()
		{
			IIntUserField* ret = static_cast<VTable*>(this->cloopVTable)->admin(this);
			return ret;
		}

		template <typename StatusType> void clear(StatusType* status)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->clear(this, status);
			StatusType::checkException(status);
		}
	};

	class IListUsers : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			void (CLOOP_CARG *list)(IListUsers* self, IStatus* status, IUser* user) throw();
		};

	protected:
		IListUsers(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IListUsers()
		{
		}

	public:
		static const unsigned VERSION = 2;

		template <typename StatusType> void list(StatusType* status, IUser* user)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->list(this, status, user);
			StatusType::checkException(status);
		}
	};

	class ILogonInfo : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			const char* (CLOOP_CARG *name)(ILogonInfo* self) throw();
			const char* (CLOOP_CARG *role)(ILogonInfo* self) throw();
			const char* (CLOOP_CARG *networkProtocol)(ILogonInfo* self) throw();
			const char* (CLOOP_CARG *remoteAddress)(ILogonInfo* self) throw();
			const unsigned char* (CLOOP_CARG *authBlock)(ILogonInfo* self, unsigned* length) throw();
		};

	protected:
		ILogonInfo(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~ILogonInfo()
		{
		}

	public:
		static const unsigned VERSION = 2;

		const char* name()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->name(this);
			return ret;
		}

		const char* role()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->role(this);
			return ret;
		}

		const char* networkProtocol()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->networkProtocol(this);
			return ret;
		}

		const char* remoteAddress()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->remoteAddress(this);
			return ret;
		}

		const unsigned char* authBlock(unsigned* length)
		{
			const unsigned char* ret = static_cast<VTable*>(this->cloopVTable)->authBlock(this, length);
			return ret;
		}
	};

	class IManagement : public IPluginBase
	{
	public:
		struct VTable : public IPluginBase::VTable
		{
			void (CLOOP_CARG *start)(IManagement* self, IStatus* status, ILogonInfo* logonInfo) throw();
			int (CLOOP_CARG *execute)(IManagement* self, IStatus* status, IUser* user, IListUsers* callback) throw();
			void (CLOOP_CARG *commit)(IManagement* self, IStatus* status) throw();
			void (CLOOP_CARG *rollback)(IManagement* self, IStatus* status) throw();
		};

	protected:
		IManagement(DoNotInherit)
			: IPluginBase(DoNotInherit())
		{
		}

		~IManagement()
		{
		}

	public:
		static const unsigned VERSION = 4;

		template <typename StatusType> void start(StatusType* status, ILogonInfo* logonInfo)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->start(this, status, logonInfo);
			StatusType::checkException(status);
		}

		template <typename StatusType> int execute(StatusType* status, IUser* user, IListUsers* callback)
		{
			StatusType::clearException(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->execute(this, status, user, callback);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> void commit(StatusType* status)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->commit(this, status);
			StatusType::checkException(status);
		}

		template <typename StatusType> void rollback(StatusType* status)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->rollback(this, status);
			StatusType::checkException(status);
		}
	};

	class IAuthBlock : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			const char* (CLOOP_CARG *getType)(IAuthBlock* self) throw();
			const char* (CLOOP_CARG *getName)(IAuthBlock* self) throw();
			const char* (CLOOP_CARG *getPlugin)(IAuthBlock* self) throw();
			const char* (CLOOP_CARG *getSecurityDb)(IAuthBlock* self) throw();
			const char* (CLOOP_CARG *getOriginalPlugin)(IAuthBlock* self) throw();
			FB_BOOLEAN (CLOOP_CARG *next)(IAuthBlock* self, IStatus* status) throw();
			FB_BOOLEAN (CLOOP_CARG *first)(IAuthBlock* self, IStatus* status) throw();
		};

	protected:
		IAuthBlock(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IAuthBlock()
		{
		}

	public:
		static const unsigned VERSION = 2;

		const char* getType()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getType(this);
			return ret;
		}

		const char* getName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getName(this);
			return ret;
		}

		const char* getPlugin()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getPlugin(this);
			return ret;
		}

		const char* getSecurityDb()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getSecurityDb(this);
			return ret;
		}

		const char* getOriginalPlugin()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getOriginalPlugin(this);
			return ret;
		}

		template <typename StatusType> FB_BOOLEAN next(StatusType* status)
		{
			StatusType::clearException(status);
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->next(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> FB_BOOLEAN first(StatusType* status)
		{
			StatusType::clearException(status);
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->first(this, status);
			StatusType::checkException(status);
			return ret;
		}
	};

	class IWireCryptPlugin : public IPluginBase
	{
	public:
		struct VTable : public IPluginBase::VTable
		{
			const char* (CLOOP_CARG *getKnownTypes)(IWireCryptPlugin* self, IStatus* status) throw();
			void (CLOOP_CARG *setKey)(IWireCryptPlugin* self, IStatus* status, ICryptKey* key) throw();
			void (CLOOP_CARG *encrypt)(IWireCryptPlugin* self, IStatus* status, unsigned length, const void* from, void* to) throw();
			void (CLOOP_CARG *decrypt)(IWireCryptPlugin* self, IStatus* status, unsigned length, const void* from, void* to) throw();
		};

	protected:
		IWireCryptPlugin(DoNotInherit)
			: IPluginBase(DoNotInherit())
		{
		}

		~IWireCryptPlugin()
		{
		}

	public:
		static const unsigned VERSION = 4;

		template <typename StatusType> const char* getKnownTypes(StatusType* status)
		{
			StatusType::clearException(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getKnownTypes(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> void setKey(StatusType* status, ICryptKey* key)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->setKey(this, status, key);
			StatusType::checkException(status);
		}

		template <typename StatusType> void encrypt(StatusType* status, unsigned length, const void* from, void* to)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->encrypt(this, status, length, from, to);
			StatusType::checkException(status);
		}

		template <typename StatusType> void decrypt(StatusType* status, unsigned length, const void* from, void* to)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->decrypt(this, status, length, from, to);
			StatusType::checkException(status);
		}
	};

	class ICryptKeyCallback : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			unsigned (CLOOP_CARG *callback)(ICryptKeyCallback* self, unsigned dataLength, const void* data, unsigned bufferLength, void* buffer) throw();
		};

	protected:
		ICryptKeyCallback(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~ICryptKeyCallback()
		{
		}

	public:
		static const unsigned VERSION = 2;

		unsigned callback(unsigned dataLength, const void* data, unsigned bufferLength, void* buffer)
		{
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->callback(this, dataLength, data, bufferLength, buffer);
			return ret;
		}
	};

	class IKeyHolderPlugin : public IPluginBase
	{
	public:
		struct VTable : public IPluginBase::VTable
		{
			int (CLOOP_CARG *keyCallback)(IKeyHolderPlugin* self, IStatus* status, ICryptKeyCallback* callback) throw();
			ICryptKeyCallback* (CLOOP_CARG *keyHandle)(IKeyHolderPlugin* self, IStatus* status, const char* keyName) throw();
			FB_BOOLEAN (CLOOP_CARG *useOnlyOwnKeys)(IKeyHolderPlugin* self, IStatus* status) throw();
			ICryptKeyCallback* (CLOOP_CARG *chainHandle)(IKeyHolderPlugin* self, IStatus* status) throw();
		};

	protected:
		IKeyHolderPlugin(DoNotInherit)
			: IPluginBase(DoNotInherit())
		{
		}

		~IKeyHolderPlugin()
		{
		}

	public:
		static const unsigned VERSION = 5;

		template <typename StatusType> int keyCallback(StatusType* status, ICryptKeyCallback* callback)
		{
			StatusType::clearException(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->keyCallback(this, status, callback);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> ICryptKeyCallback* keyHandle(StatusType* status, const char* keyName)
		{
			StatusType::clearException(status);
			ICryptKeyCallback* ret = static_cast<VTable*>(this->cloopVTable)->keyHandle(this, status, keyName);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> FB_BOOLEAN useOnlyOwnKeys(StatusType* status)
		{
			if (cloopVTable->version < 5)
			{
				StatusType::setVersionError(status, "IKeyHolderPlugin", cloopVTable->version, 5);
				StatusType::checkException(status);
				return 0;
			}
			StatusType::clearException(status);
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->useOnlyOwnKeys(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> ICryptKeyCallback* chainHandle(StatusType* status)
		{
			if (cloopVTable->version < 5)
			{
				StatusType::setVersionError(status, "IKeyHolderPlugin", cloopVTable->version, 5);
				StatusType::checkException(status);
				return 0;
			}
			StatusType::clearException(status);
			ICryptKeyCallback* ret = static_cast<VTable*>(this->cloopVTable)->chainHandle(this, status);
			StatusType::checkException(status);
			return ret;
		}
	};

	class IDbCryptInfo : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			const char* (CLOOP_CARG *getDatabaseFullPath)(IDbCryptInfo* self, IStatus* status) throw();
		};

	protected:
		IDbCryptInfo(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~IDbCryptInfo()
		{
		}

	public:
		static const unsigned VERSION = 3;

		template <typename StatusType> const char* getDatabaseFullPath(StatusType* status)
		{
			StatusType::clearException(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getDatabaseFullPath(this, status);
			StatusType::checkException(status);
			return ret;
		}
	};

	class IDbCryptPlugin : public IPluginBase
	{
	public:
		struct VTable : public IPluginBase::VTable
		{
			void (CLOOP_CARG *setKey)(IDbCryptPlugin* self, IStatus* status, unsigned length, IKeyHolderPlugin** sources, const char* keyName) throw();
			void (CLOOP_CARG *encrypt)(IDbCryptPlugin* self, IStatus* status, unsigned length, const void* from, void* to) throw();
			void (CLOOP_CARG *decrypt)(IDbCryptPlugin* self, IStatus* status, unsigned length, const void* from, void* to) throw();
			void (CLOOP_CARG *setInfo)(IDbCryptPlugin* self, IStatus* status, IDbCryptInfo* info) throw();
		};

	protected:
		IDbCryptPlugin(DoNotInherit)
			: IPluginBase(DoNotInherit())
		{
		}

		~IDbCryptPlugin()
		{
		}

	public:
		static const unsigned VERSION = 5;

		template <typename StatusType> void setKey(StatusType* status, unsigned length, IKeyHolderPlugin** sources, const char* keyName)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->setKey(this, status, length, sources, keyName);
			StatusType::checkException(status);
		}

		template <typename StatusType> void encrypt(StatusType* status, unsigned length, const void* from, void* to)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->encrypt(this, status, length, from, to);
			StatusType::checkException(status);
		}

		template <typename StatusType> void decrypt(StatusType* status, unsigned length, const void* from, void* to)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->decrypt(this, status, length, from, to);
			StatusType::checkException(status);
		}

		template <typename StatusType> void setInfo(StatusType* status, IDbCryptInfo* info)
		{
			if (cloopVTable->version < 5)
			{
				StatusType::setVersionError(status, "IDbCryptPlugin", cloopVTable->version, 5);
				StatusType::checkException(status);
				return;
			}
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->setInfo(this, status, info);
			StatusType::checkException(status);
		}
	};

	class IExternalContext : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			IMaster* (CLOOP_CARG *getMaster)(IExternalContext* self) throw();
			IExternalEngine* (CLOOP_CARG *getEngine)(IExternalContext* self, IStatus* status) throw();
			IAttachment* (CLOOP_CARG *getAttachment)(IExternalContext* self, IStatus* status) throw();
			ITransaction* (CLOOP_CARG *getTransaction)(IExternalContext* self, IStatus* status) throw();
			const char* (CLOOP_CARG *getUserName)(IExternalContext* self) throw();
			const char* (CLOOP_CARG *getDatabaseName)(IExternalContext* self) throw();
			const char* (CLOOP_CARG *getClientCharSet)(IExternalContext* self) throw();
			int (CLOOP_CARG *obtainInfoCode)(IExternalContext* self) throw();
			void* (CLOOP_CARG *getInfo)(IExternalContext* self, int code) throw();
			void* (CLOOP_CARG *setInfo)(IExternalContext* self, int code, void* value) throw();
		};

	protected:
		IExternalContext(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IExternalContext()
		{
		}

	public:
		static const unsigned VERSION = 2;

		IMaster* getMaster()
		{
			IMaster* ret = static_cast<VTable*>(this->cloopVTable)->getMaster(this);
			return ret;
		}

		template <typename StatusType> IExternalEngine* getEngine(StatusType* status)
		{
			StatusType::clearException(status);
			IExternalEngine* ret = static_cast<VTable*>(this->cloopVTable)->getEngine(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> IAttachment* getAttachment(StatusType* status)
		{
			StatusType::clearException(status);
			IAttachment* ret = static_cast<VTable*>(this->cloopVTable)->getAttachment(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> ITransaction* getTransaction(StatusType* status)
		{
			StatusType::clearException(status);
			ITransaction* ret = static_cast<VTable*>(this->cloopVTable)->getTransaction(this, status);
			StatusType::checkException(status);
			return ret;
		}

		const char* getUserName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getUserName(this);
			return ret;
		}

		const char* getDatabaseName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getDatabaseName(this);
			return ret;
		}

		const char* getClientCharSet()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getClientCharSet(this);
			return ret;
		}

		int obtainInfoCode()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->obtainInfoCode(this);
			return ret;
		}

		void* getInfo(int code)
		{
			void* ret = static_cast<VTable*>(this->cloopVTable)->getInfo(this, code);
			return ret;
		}

		void* setInfo(int code, void* value)
		{
			void* ret = static_cast<VTable*>(this->cloopVTable)->setInfo(this, code, value);
			return ret;
		}
	};

	class IExternalResultSet : public IDisposable
	{
	public:
		struct VTable : public IDisposable::VTable
		{
			FB_BOOLEAN (CLOOP_CARG *fetch)(IExternalResultSet* self, IStatus* status) throw();
		};

	protected:
		IExternalResultSet(DoNotInherit)
			: IDisposable(DoNotInherit())
		{
		}

		~IExternalResultSet()
		{
		}

	public:
		static const unsigned VERSION = 3;

		template <typename StatusType> FB_BOOLEAN fetch(StatusType* status)
		{
			StatusType::clearException(status);
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->fetch(this, status);
			StatusType::checkException(status);
			return ret;
		}
	};

	class IExternalFunction : public IDisposable
	{
	public:
		struct VTable : public IDisposable::VTable
		{
			void (CLOOP_CARG *getCharSet)(IExternalFunction* self, IStatus* status, IExternalContext* context, char* name, unsigned nameSize) throw();
			void (CLOOP_CARG *execute)(IExternalFunction* self, IStatus* status, IExternalContext* context, void* inMsg, void* outMsg) throw();
		};

	protected:
		IExternalFunction(DoNotInherit)
			: IDisposable(DoNotInherit())
		{
		}

		~IExternalFunction()
		{
		}

	public:
		static const unsigned VERSION = 3;

		template <typename StatusType> void getCharSet(StatusType* status, IExternalContext* context, char* name, unsigned nameSize)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->getCharSet(this, status, context, name, nameSize);
			StatusType::checkException(status);
		}

		template <typename StatusType> void execute(StatusType* status, IExternalContext* context, void* inMsg, void* outMsg)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->execute(this, status, context, inMsg, outMsg);
			StatusType::checkException(status);
		}
	};

	class IExternalProcedure : public IDisposable
	{
	public:
		struct VTable : public IDisposable::VTable
		{
			void (CLOOP_CARG *getCharSet)(IExternalProcedure* self, IStatus* status, IExternalContext* context, char* name, unsigned nameSize) throw();
			IExternalResultSet* (CLOOP_CARG *open)(IExternalProcedure* self, IStatus* status, IExternalContext* context, void* inMsg, void* outMsg) throw();
		};

	protected:
		IExternalProcedure(DoNotInherit)
			: IDisposable(DoNotInherit())
		{
		}

		~IExternalProcedure()
		{
		}

	public:
		static const unsigned VERSION = 3;

		template <typename StatusType> void getCharSet(StatusType* status, IExternalContext* context, char* name, unsigned nameSize)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->getCharSet(this, status, context, name, nameSize);
			StatusType::checkException(status);
		}

		template <typename StatusType> IExternalResultSet* open(StatusType* status, IExternalContext* context, void* inMsg, void* outMsg)
		{
			StatusType::clearException(status);
			IExternalResultSet* ret = static_cast<VTable*>(this->cloopVTable)->open(this, status, context, inMsg, outMsg);
			StatusType::checkException(status);
			return ret;
		}
	};

	class IExternalTrigger : public IDisposable
	{
	public:
		struct VTable : public IDisposable::VTable
		{
			void (CLOOP_CARG *getCharSet)(IExternalTrigger* self, IStatus* status, IExternalContext* context, char* name, unsigned nameSize) throw();
			void (CLOOP_CARG *execute)(IExternalTrigger* self, IStatus* status, IExternalContext* context, unsigned action, void* oldMsg, void* newMsg) throw();
		};

	protected:
		IExternalTrigger(DoNotInherit)
			: IDisposable(DoNotInherit())
		{
		}

		~IExternalTrigger()
		{
		}

	public:
		static const unsigned VERSION = 3;

		static const unsigned TYPE_BEFORE = 1;
		static const unsigned TYPE_AFTER = 2;
		static const unsigned TYPE_DATABASE = 3;
		static const unsigned ACTION_INSERT = 1;
		static const unsigned ACTION_UPDATE = 2;
		static const unsigned ACTION_DELETE = 3;
		static const unsigned ACTION_CONNECT = 4;
		static const unsigned ACTION_DISCONNECT = 5;
		static const unsigned ACTION_TRANS_START = 6;
		static const unsigned ACTION_TRANS_COMMIT = 7;
		static const unsigned ACTION_TRANS_ROLLBACK = 8;
		static const unsigned ACTION_DDL = 9;

		template <typename StatusType> void getCharSet(StatusType* status, IExternalContext* context, char* name, unsigned nameSize)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->getCharSet(this, status, context, name, nameSize);
			StatusType::checkException(status);
		}

		template <typename StatusType> void execute(StatusType* status, IExternalContext* context, unsigned action, void* oldMsg, void* newMsg)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->execute(this, status, context, action, oldMsg, newMsg);
			StatusType::checkException(status);
		}
	};

	class IRoutineMetadata : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			const char* (CLOOP_CARG *getPackage)(const IRoutineMetadata* self, IStatus* status) throw();
			const char* (CLOOP_CARG *getName)(const IRoutineMetadata* self, IStatus* status) throw();
			const char* (CLOOP_CARG *getEntryPoint)(const IRoutineMetadata* self, IStatus* status) throw();
			const char* (CLOOP_CARG *getBody)(const IRoutineMetadata* self, IStatus* status) throw();
			IMessageMetadata* (CLOOP_CARG *getInputMetadata)(const IRoutineMetadata* self, IStatus* status) throw();
			IMessageMetadata* (CLOOP_CARG *getOutputMetadata)(const IRoutineMetadata* self, IStatus* status) throw();
			IMessageMetadata* (CLOOP_CARG *getTriggerMetadata)(const IRoutineMetadata* self, IStatus* status) throw();
			const char* (CLOOP_CARG *getTriggerTable)(const IRoutineMetadata* self, IStatus* status) throw();
			unsigned (CLOOP_CARG *getTriggerType)(const IRoutineMetadata* self, IStatus* status) throw();
		};

	protected:
		IRoutineMetadata(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IRoutineMetadata()
		{
		}

	public:
		static const unsigned VERSION = 2;

		template <typename StatusType> const char* getPackage(StatusType* status) const
		{
			StatusType::clearException(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getPackage(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> const char* getName(StatusType* status) const
		{
			StatusType::clearException(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getName(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> const char* getEntryPoint(StatusType* status) const
		{
			StatusType::clearException(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getEntryPoint(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> const char* getBody(StatusType* status) const
		{
			StatusType::clearException(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getBody(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> IMessageMetadata* getInputMetadata(StatusType* status) const
		{
			StatusType::clearException(status);
			IMessageMetadata* ret = static_cast<VTable*>(this->cloopVTable)->getInputMetadata(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> IMessageMetadata* getOutputMetadata(StatusType* status) const
		{
			StatusType::clearException(status);
			IMessageMetadata* ret = static_cast<VTable*>(this->cloopVTable)->getOutputMetadata(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> IMessageMetadata* getTriggerMetadata(StatusType* status) const
		{
			StatusType::clearException(status);
			IMessageMetadata* ret = static_cast<VTable*>(this->cloopVTable)->getTriggerMetadata(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> const char* getTriggerTable(StatusType* status) const
		{
			StatusType::clearException(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getTriggerTable(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> unsigned getTriggerType(StatusType* status) const
		{
			StatusType::clearException(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getTriggerType(this, status);
			StatusType::checkException(status);
			return ret;
		}
	};

	class IExternalEngine : public IPluginBase
	{
	public:
		struct VTable : public IPluginBase::VTable
		{
			void (CLOOP_CARG *open)(IExternalEngine* self, IStatus* status, IExternalContext* context, char* charSet, unsigned charSetSize) throw();
			void (CLOOP_CARG *openAttachment)(IExternalEngine* self, IStatus* status, IExternalContext* context) throw();
			void (CLOOP_CARG *closeAttachment)(IExternalEngine* self, IStatus* status, IExternalContext* context) throw();
			IExternalFunction* (CLOOP_CARG *makeFunction)(IExternalEngine* self, IStatus* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* inBuilder, IMetadataBuilder* outBuilder) throw();
			IExternalProcedure* (CLOOP_CARG *makeProcedure)(IExternalEngine* self, IStatus* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* inBuilder, IMetadataBuilder* outBuilder) throw();
			IExternalTrigger* (CLOOP_CARG *makeTrigger)(IExternalEngine* self, IStatus* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* fieldsBuilder) throw();
		};

	protected:
		IExternalEngine(DoNotInherit)
			: IPluginBase(DoNotInherit())
		{
		}

		~IExternalEngine()
		{
		}

	public:
		static const unsigned VERSION = 4;

		template <typename StatusType> void open(StatusType* status, IExternalContext* context, char* charSet, unsigned charSetSize)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->open(this, status, context, charSet, charSetSize);
			StatusType::checkException(status);
		}

		template <typename StatusType> void openAttachment(StatusType* status, IExternalContext* context)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->openAttachment(this, status, context);
			StatusType::checkException(status);
		}

		template <typename StatusType> void closeAttachment(StatusType* status, IExternalContext* context)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->closeAttachment(this, status, context);
			StatusType::checkException(status);
		}

		template <typename StatusType> IExternalFunction* makeFunction(StatusType* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* inBuilder, IMetadataBuilder* outBuilder)
		{
			StatusType::clearException(status);
			IExternalFunction* ret = static_cast<VTable*>(this->cloopVTable)->makeFunction(this, status, context, metadata, inBuilder, outBuilder);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> IExternalProcedure* makeProcedure(StatusType* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* inBuilder, IMetadataBuilder* outBuilder)
		{
			StatusType::clearException(status);
			IExternalProcedure* ret = static_cast<VTable*>(this->cloopVTable)->makeProcedure(this, status, context, metadata, inBuilder, outBuilder);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> IExternalTrigger* makeTrigger(StatusType* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* fieldsBuilder)
		{
			StatusType::clearException(status);
			IExternalTrigger* ret = static_cast<VTable*>(this->cloopVTable)->makeTrigger(this, status, context, metadata, fieldsBuilder);
			StatusType::checkException(status);
			return ret;
		}
	};

	class ITimer : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			void (CLOOP_CARG *handler)(ITimer* self) throw();
		};

	protected:
		ITimer(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~ITimer()
		{
		}

	public:
		static const unsigned VERSION = 3;

		void handler()
		{
			static_cast<VTable*>(this->cloopVTable)->handler(this);
		}
	};

	class ITimerControl : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			void (CLOOP_CARG *start)(ITimerControl* self, IStatus* status, ITimer* timer, ISC_UINT64 microSeconds) throw();
			void (CLOOP_CARG *stop)(ITimerControl* self, IStatus* status, ITimer* timer) throw();
		};

	protected:
		ITimerControl(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~ITimerControl()
		{
		}

	public:
		static const unsigned VERSION = 2;

		template <typename StatusType> void start(StatusType* status, ITimer* timer, ISC_UINT64 microSeconds)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->start(this, status, timer, microSeconds);
			StatusType::checkException(status);
		}

		template <typename StatusType> void stop(StatusType* status, ITimer* timer)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->stop(this, status, timer);
			StatusType::checkException(status);
		}
	};

	class IVersionCallback : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			void (CLOOP_CARG *callback)(IVersionCallback* self, IStatus* status, const char* text) throw();
		};

	protected:
		IVersionCallback(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IVersionCallback()
		{
		}

	public:
		static const unsigned VERSION = 2;

		template <typename StatusType> void callback(StatusType* status, const char* text)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->callback(this, status, text);
			StatusType::checkException(status);
		}
	};

	class IUtil : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			void (CLOOP_CARG *getFbVersion)(IUtil* self, IStatus* status, IAttachment* att, IVersionCallback* callback) throw();
			void (CLOOP_CARG *loadBlob)(IUtil* self, IStatus* status, ISC_QUAD* blobId, IAttachment* att, ITransaction* tra, const char* file, FB_BOOLEAN txt) throw();
			void (CLOOP_CARG *dumpBlob)(IUtil* self, IStatus* status, ISC_QUAD* blobId, IAttachment* att, ITransaction* tra, const char* file, FB_BOOLEAN txt) throw();
			void (CLOOP_CARG *getPerfCounters)(IUtil* self, IStatus* status, IAttachment* att, const char* countersSet, ISC_INT64* counters) throw();
			IAttachment* (CLOOP_CARG *executeCreateDatabase)(IUtil* self, IStatus* status, unsigned stmtLength, const char* creatDBstatement, unsigned dialect, FB_BOOLEAN* stmtIsCreateDb) throw();
			void (CLOOP_CARG *decodeDate)(IUtil* self, ISC_DATE date, unsigned* year, unsigned* month, unsigned* day) throw();
			void (CLOOP_CARG *decodeTime)(IUtil* self, ISC_TIME time, unsigned* hours, unsigned* minutes, unsigned* seconds, unsigned* fractions) throw();
			ISC_DATE (CLOOP_CARG *encodeDate)(IUtil* self, unsigned year, unsigned month, unsigned day) throw();
			ISC_TIME (CLOOP_CARG *encodeTime)(IUtil* self, unsigned hours, unsigned minutes, unsigned seconds, unsigned fractions) throw();
			unsigned (CLOOP_CARG *formatStatus)(IUtil* self, char* buffer, unsigned bufferSize, IStatus* status) throw();
			unsigned (CLOOP_CARG *getClientVersion)(IUtil* self) throw();
			IXpbBuilder* (CLOOP_CARG *getXpbBuilder)(IUtil* self, IStatus* status, unsigned kind, const unsigned char* buf, unsigned len) throw();
			unsigned (CLOOP_CARG *setOffsets)(IUtil* self, IStatus* status, IMessageMetadata* metadata, IOffsetsCallback* callback) throw();
		};

	protected:
		IUtil(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IUtil()
		{
		}

	public:
		static const unsigned VERSION = 2;

		template <typename StatusType> void getFbVersion(StatusType* status, IAttachment* att, IVersionCallback* callback)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->getFbVersion(this, status, att, callback);
			StatusType::checkException(status);
		}

		template <typename StatusType> void loadBlob(StatusType* status, ISC_QUAD* blobId, IAttachment* att, ITransaction* tra, const char* file, FB_BOOLEAN txt)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->loadBlob(this, status, blobId, att, tra, file, txt);
			StatusType::checkException(status);
		}

		template <typename StatusType> void dumpBlob(StatusType* status, ISC_QUAD* blobId, IAttachment* att, ITransaction* tra, const char* file, FB_BOOLEAN txt)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->dumpBlob(this, status, blobId, att, tra, file, txt);
			StatusType::checkException(status);
		}

		template <typename StatusType> void getPerfCounters(StatusType* status, IAttachment* att, const char* countersSet, ISC_INT64* counters)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->getPerfCounters(this, status, att, countersSet, counters);
			StatusType::checkException(status);
		}

		template <typename StatusType> IAttachment* executeCreateDatabase(StatusType* status, unsigned stmtLength, const char* creatDBstatement, unsigned dialect, FB_BOOLEAN* stmtIsCreateDb)
		{
			StatusType::clearException(status);
			IAttachment* ret = static_cast<VTable*>(this->cloopVTable)->executeCreateDatabase(this, status, stmtLength, creatDBstatement, dialect, stmtIsCreateDb);
			StatusType::checkException(status);
			return ret;
		}

		void decodeDate(ISC_DATE date, unsigned* year, unsigned* month, unsigned* day)
		{
			static_cast<VTable*>(this->cloopVTable)->decodeDate(this, date, year, month, day);
		}

		void decodeTime(ISC_TIME time, unsigned* hours, unsigned* minutes, unsigned* seconds, unsigned* fractions)
		{
			static_cast<VTable*>(this->cloopVTable)->decodeTime(this, time, hours, minutes, seconds, fractions);
		}

		ISC_DATE encodeDate(unsigned year, unsigned month, unsigned day)
		{
			ISC_DATE ret = static_cast<VTable*>(this->cloopVTable)->encodeDate(this, year, month, day);
			return ret;
		}

		ISC_TIME encodeTime(unsigned hours, unsigned minutes, unsigned seconds, unsigned fractions)
		{
			ISC_TIME ret = static_cast<VTable*>(this->cloopVTable)->encodeTime(this, hours, minutes, seconds, fractions);
			return ret;
		}

		unsigned formatStatus(char* buffer, unsigned bufferSize, IStatus* status)
		{
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->formatStatus(this, buffer, bufferSize, status);
			return ret;
		}

		unsigned getClientVersion()
		{
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getClientVersion(this);
			return ret;
		}

		template <typename StatusType> IXpbBuilder* getXpbBuilder(StatusType* status, unsigned kind, const unsigned char* buf, unsigned len)
		{
			StatusType::clearException(status);
			IXpbBuilder* ret = static_cast<VTable*>(this->cloopVTable)->getXpbBuilder(this, status, kind, buf, len);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> unsigned setOffsets(StatusType* status, IMessageMetadata* metadata, IOffsetsCallback* callback)
		{
			StatusType::clearException(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->setOffsets(this, status, metadata, callback);
			StatusType::checkException(status);
			return ret;
		}
	};

	class IOffsetsCallback : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			void (CLOOP_CARG *setOffset)(IOffsetsCallback* self, IStatus* status, unsigned index, unsigned offset, unsigned nullOffset) throw();
		};

	protected:
		IOffsetsCallback(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IOffsetsCallback()
		{
		}

	public:
		static const unsigned VERSION = 2;

		template <typename StatusType> void setOffset(StatusType* status, unsigned index, unsigned offset, unsigned nullOffset)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->setOffset(this, status, index, offset, nullOffset);
			StatusType::checkException(status);
		}
	};

	class IXpbBuilder : public IDisposable
	{
	public:
		struct VTable : public IDisposable::VTable
		{
			void (CLOOP_CARG *clear)(IXpbBuilder* self, IStatus* status) throw();
			void (CLOOP_CARG *removeCurrent)(IXpbBuilder* self, IStatus* status) throw();
			void (CLOOP_CARG *insertInt)(IXpbBuilder* self, IStatus* status, unsigned char tag, int value) throw();
			void (CLOOP_CARG *insertBigInt)(IXpbBuilder* self, IStatus* status, unsigned char tag, ISC_INT64 value) throw();
			void (CLOOP_CARG *insertBytes)(IXpbBuilder* self, IStatus* status, unsigned char tag, const void* bytes, unsigned length) throw();
			void (CLOOP_CARG *insertString)(IXpbBuilder* self, IStatus* status, unsigned char tag, const char* str) throw();
			void (CLOOP_CARG *insertTag)(IXpbBuilder* self, IStatus* status, unsigned char tag) throw();
			FB_BOOLEAN (CLOOP_CARG *isEof)(IXpbBuilder* self, IStatus* status) throw();
			void (CLOOP_CARG *moveNext)(IXpbBuilder* self, IStatus* status) throw();
			void (CLOOP_CARG *rewind)(IXpbBuilder* self, IStatus* status) throw();
			FB_BOOLEAN (CLOOP_CARG *findFirst)(IXpbBuilder* self, IStatus* status, unsigned char tag) throw();
			FB_BOOLEAN (CLOOP_CARG *findNext)(IXpbBuilder* self, IStatus* status) throw();
			unsigned char (CLOOP_CARG *getTag)(IXpbBuilder* self, IStatus* status) throw();
			unsigned (CLOOP_CARG *getLength)(IXpbBuilder* self, IStatus* status) throw();
			int (CLOOP_CARG *getInt)(IXpbBuilder* self, IStatus* status) throw();
			ISC_INT64 (CLOOP_CARG *getBigInt)(IXpbBuilder* self, IStatus* status) throw();
			const char* (CLOOP_CARG *getString)(IXpbBuilder* self, IStatus* status) throw();
			const unsigned char* (CLOOP_CARG *getBytes)(IXpbBuilder* self, IStatus* status) throw();
			unsigned (CLOOP_CARG *getBufferLength)(IXpbBuilder* self, IStatus* status) throw();
			const unsigned char* (CLOOP_CARG *getBuffer)(IXpbBuilder* self, IStatus* status) throw();
		};

	protected:
		IXpbBuilder(DoNotInherit)
			: IDisposable(DoNotInherit())
		{
		}

		~IXpbBuilder()
		{
		}

	public:
		static const unsigned VERSION = 3;

		static const unsigned DPB = 1;
		static const unsigned SPB_ATTACH = 2;
		static const unsigned SPB_START = 3;
		static const unsigned TPB = 4;

		template <typename StatusType> void clear(StatusType* status)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->clear(this, status);
			StatusType::checkException(status);
		}

		template <typename StatusType> void removeCurrent(StatusType* status)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->removeCurrent(this, status);
			StatusType::checkException(status);
		}

		template <typename StatusType> void insertInt(StatusType* status, unsigned char tag, int value)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->insertInt(this, status, tag, value);
			StatusType::checkException(status);
		}

		template <typename StatusType> void insertBigInt(StatusType* status, unsigned char tag, ISC_INT64 value)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->insertBigInt(this, status, tag, value);
			StatusType::checkException(status);
		}

		template <typename StatusType> void insertBytes(StatusType* status, unsigned char tag, const void* bytes, unsigned length)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->insertBytes(this, status, tag, bytes, length);
			StatusType::checkException(status);
		}

		template <typename StatusType> void insertString(StatusType* status, unsigned char tag, const char* str)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->insertString(this, status, tag, str);
			StatusType::checkException(status);
		}

		template <typename StatusType> void insertTag(StatusType* status, unsigned char tag)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->insertTag(this, status, tag);
			StatusType::checkException(status);
		}

		template <typename StatusType> FB_BOOLEAN isEof(StatusType* status)
		{
			StatusType::clearException(status);
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->isEof(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> void moveNext(StatusType* status)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->moveNext(this, status);
			StatusType::checkException(status);
		}

		template <typename StatusType> void rewind(StatusType* status)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->rewind(this, status);
			StatusType::checkException(status);
		}

		template <typename StatusType> FB_BOOLEAN findFirst(StatusType* status, unsigned char tag)
		{
			StatusType::clearException(status);
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->findFirst(this, status, tag);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> FB_BOOLEAN findNext(StatusType* status)
		{
			StatusType::clearException(status);
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->findNext(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> unsigned char getTag(StatusType* status)
		{
			StatusType::clearException(status);
			unsigned char ret = static_cast<VTable*>(this->cloopVTable)->getTag(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> unsigned getLength(StatusType* status)
		{
			StatusType::clearException(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getLength(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> int getInt(StatusType* status)
		{
			StatusType::clearException(status);
			int ret = static_cast<VTable*>(this->cloopVTable)->getInt(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> ISC_INT64 getBigInt(StatusType* status)
		{
			StatusType::clearException(status);
			ISC_INT64 ret = static_cast<VTable*>(this->cloopVTable)->getBigInt(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> const char* getString(StatusType* status)
		{
			StatusType::clearException(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getString(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> const unsigned char* getBytes(StatusType* status)
		{
			StatusType::clearException(status);
			const unsigned char* ret = static_cast<VTable*>(this->cloopVTable)->getBytes(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> unsigned getBufferLength(StatusType* status)
		{
			StatusType::clearException(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getBufferLength(this, status);
			StatusType::checkException(status);
			return ret;
		}

		template <typename StatusType> const unsigned char* getBuffer(StatusType* status)
		{
			StatusType::clearException(status);
			const unsigned char* ret = static_cast<VTable*>(this->cloopVTable)->getBuffer(this, status);
			StatusType::checkException(status);
			return ret;
		}
	};

	class ITraceConnection : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			unsigned (CLOOP_CARG *getKind)(ITraceConnection* self) throw();
			int (CLOOP_CARG *getProcessID)(ITraceConnection* self) throw();
			const char* (CLOOP_CARG *getUserName)(ITraceConnection* self) throw();
			const char* (CLOOP_CARG *getRoleName)(ITraceConnection* self) throw();
			const char* (CLOOP_CARG *getCharSet)(ITraceConnection* self) throw();
			const char* (CLOOP_CARG *getRemoteProtocol)(ITraceConnection* self) throw();
			const char* (CLOOP_CARG *getRemoteAddress)(ITraceConnection* self) throw();
			int (CLOOP_CARG *getRemoteProcessID)(ITraceConnection* self) throw();
			const char* (CLOOP_CARG *getRemoteProcessName)(ITraceConnection* self) throw();
		};

	protected:
		ITraceConnection(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~ITraceConnection()
		{
		}

	public:
		static const unsigned VERSION = 2;

		static const unsigned KIND_DATABASE = 1;
		static const unsigned KIND_SERVICE = 2;

		unsigned getKind()
		{
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getKind(this);
			return ret;
		}

		int getProcessID()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->getProcessID(this);
			return ret;
		}

		const char* getUserName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getUserName(this);
			return ret;
		}

		const char* getRoleName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getRoleName(this);
			return ret;
		}

		const char* getCharSet()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getCharSet(this);
			return ret;
		}

		const char* getRemoteProtocol()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getRemoteProtocol(this);
			return ret;
		}

		const char* getRemoteAddress()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getRemoteAddress(this);
			return ret;
		}

		int getRemoteProcessID()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->getRemoteProcessID(this);
			return ret;
		}

		const char* getRemoteProcessName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getRemoteProcessName(this);
			return ret;
		}
	};

	class ITraceDatabaseConnection : public ITraceConnection
	{
	public:
		struct VTable : public ITraceConnection::VTable
		{
			ISC_INT64 (CLOOP_CARG *getConnectionID)(ITraceDatabaseConnection* self) throw();
			const char* (CLOOP_CARG *getDatabaseName)(ITraceDatabaseConnection* self) throw();
		};

	protected:
		ITraceDatabaseConnection(DoNotInherit)
			: ITraceConnection(DoNotInherit())
		{
		}

		~ITraceDatabaseConnection()
		{
		}

	public:
		static const unsigned VERSION = 3;

		ISC_INT64 getConnectionID()
		{
			ISC_INT64 ret = static_cast<VTable*>(this->cloopVTable)->getConnectionID(this);
			return ret;
		}

		const char* getDatabaseName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getDatabaseName(this);
			return ret;
		}
	};

	class ITraceTransaction : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			ISC_INT64 (CLOOP_CARG *getTransactionID)(ITraceTransaction* self) throw();
			FB_BOOLEAN (CLOOP_CARG *getReadOnly)(ITraceTransaction* self) throw();
			int (CLOOP_CARG *getWait)(ITraceTransaction* self) throw();
			unsigned (CLOOP_CARG *getIsolation)(ITraceTransaction* self) throw();
			PerformanceInfo* (CLOOP_CARG *getPerf)(ITraceTransaction* self) throw();
			ISC_INT64 (CLOOP_CARG *getInitialID)(ITraceTransaction* self) throw();
			ISC_INT64 (CLOOP_CARG *getPreviousID)(ITraceTransaction* self) throw();
		};

	protected:
		ITraceTransaction(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~ITraceTransaction()
		{
		}

	public:
		static const unsigned VERSION = 3;

		static const unsigned ISOLATION_CONSISTENCY = 1;
		static const unsigned ISOLATION_CONCURRENCY = 2;
		static const unsigned ISOLATION_READ_COMMITTED_RECVER = 3;
		static const unsigned ISOLATION_READ_COMMITTED_NORECVER = 4;

		ISC_INT64 getTransactionID()
		{
			ISC_INT64 ret = static_cast<VTable*>(this->cloopVTable)->getTransactionID(this);
			return ret;
		}

		FB_BOOLEAN getReadOnly()
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->getReadOnly(this);
			return ret;
		}

		int getWait()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->getWait(this);
			return ret;
		}

		unsigned getIsolation()
		{
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getIsolation(this);
			return ret;
		}

		PerformanceInfo* getPerf()
		{
			PerformanceInfo* ret = static_cast<VTable*>(this->cloopVTable)->getPerf(this);
			return ret;
		}

		ISC_INT64 getInitialID()
		{
			if (cloopVTable->version < 3)
			{
				return 0;
			}
			ISC_INT64 ret = static_cast<VTable*>(this->cloopVTable)->getInitialID(this);
			return ret;
		}

		ISC_INT64 getPreviousID()
		{
			if (cloopVTable->version < 3)
			{
				return 0;
			}
			ISC_INT64 ret = static_cast<VTable*>(this->cloopVTable)->getPreviousID(this);
			return ret;
		}
	};

	class ITraceParams : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			unsigned (CLOOP_CARG *getCount)(ITraceParams* self) throw();
			const dsc* (CLOOP_CARG *getParam)(ITraceParams* self, unsigned idx) throw();
			const char* (CLOOP_CARG *getTextUTF8)(ITraceParams* self, IStatus* status, unsigned idx) throw();
		};

	protected:
		ITraceParams(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~ITraceParams()
		{
		}

	public:
		static const unsigned VERSION = 3;

		unsigned getCount()
		{
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getCount(this);
			return ret;
		}

		const dsc* getParam(unsigned idx)
		{
			const dsc* ret = static_cast<VTable*>(this->cloopVTable)->getParam(this, idx);
			return ret;
		}

		template <typename StatusType> const char* getTextUTF8(StatusType* status, unsigned idx)
		{
			if (cloopVTable->version < 3)
			{
				StatusType::setVersionError(status, "ITraceParams", cloopVTable->version, 3);
				StatusType::checkException(status);
				return 0;
			}
			StatusType::clearException(status);
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getTextUTF8(this, status, idx);
			StatusType::checkException(status);
			return ret;
		}
	};

	class ITraceStatement : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			ISC_INT64 (CLOOP_CARG *getStmtID)(ITraceStatement* self) throw();
			PerformanceInfo* (CLOOP_CARG *getPerf)(ITraceStatement* self) throw();
		};

	protected:
		ITraceStatement(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~ITraceStatement()
		{
		}

	public:
		static const unsigned VERSION = 2;

		ISC_INT64 getStmtID()
		{
			ISC_INT64 ret = static_cast<VTable*>(this->cloopVTable)->getStmtID(this);
			return ret;
		}

		PerformanceInfo* getPerf()
		{
			PerformanceInfo* ret = static_cast<VTable*>(this->cloopVTable)->getPerf(this);
			return ret;
		}
	};

	class ITraceSQLStatement : public ITraceStatement
	{
	public:
		struct VTable : public ITraceStatement::VTable
		{
			const char* (CLOOP_CARG *getText)(ITraceSQLStatement* self) throw();
			const char* (CLOOP_CARG *getPlan)(ITraceSQLStatement* self) throw();
			ITraceParams* (CLOOP_CARG *getInputs)(ITraceSQLStatement* self) throw();
			const char* (CLOOP_CARG *getTextUTF8)(ITraceSQLStatement* self) throw();
			const char* (CLOOP_CARG *getExplainedPlan)(ITraceSQLStatement* self) throw();
		};

	protected:
		ITraceSQLStatement(DoNotInherit)
			: ITraceStatement(DoNotInherit())
		{
		}

		~ITraceSQLStatement()
		{
		}

	public:
		static const unsigned VERSION = 3;

		const char* getText()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getText(this);
			return ret;
		}

		const char* getPlan()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getPlan(this);
			return ret;
		}

		ITraceParams* getInputs()
		{
			ITraceParams* ret = static_cast<VTable*>(this->cloopVTable)->getInputs(this);
			return ret;
		}

		const char* getTextUTF8()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getTextUTF8(this);
			return ret;
		}

		const char* getExplainedPlan()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getExplainedPlan(this);
			return ret;
		}
	};

	class ITraceBLRStatement : public ITraceStatement
	{
	public:
		struct VTable : public ITraceStatement::VTable
		{
			const unsigned char* (CLOOP_CARG *getData)(ITraceBLRStatement* self) throw();
			unsigned (CLOOP_CARG *getDataLength)(ITraceBLRStatement* self) throw();
			const char* (CLOOP_CARG *getText)(ITraceBLRStatement* self) throw();
		};

	protected:
		ITraceBLRStatement(DoNotInherit)
			: ITraceStatement(DoNotInherit())
		{
		}

		~ITraceBLRStatement()
		{
		}

	public:
		static const unsigned VERSION = 3;

		const unsigned char* getData()
		{
			const unsigned char* ret = static_cast<VTable*>(this->cloopVTable)->getData(this);
			return ret;
		}

		unsigned getDataLength()
		{
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getDataLength(this);
			return ret;
		}

		const char* getText()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getText(this);
			return ret;
		}
	};

	class ITraceDYNRequest : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			const unsigned char* (CLOOP_CARG *getData)(ITraceDYNRequest* self) throw();
			unsigned (CLOOP_CARG *getDataLength)(ITraceDYNRequest* self) throw();
			const char* (CLOOP_CARG *getText)(ITraceDYNRequest* self) throw();
		};

	protected:
		ITraceDYNRequest(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~ITraceDYNRequest()
		{
		}

	public:
		static const unsigned VERSION = 2;

		const unsigned char* getData()
		{
			const unsigned char* ret = static_cast<VTable*>(this->cloopVTable)->getData(this);
			return ret;
		}

		unsigned getDataLength()
		{
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->getDataLength(this);
			return ret;
		}

		const char* getText()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getText(this);
			return ret;
		}
	};

	class ITraceContextVariable : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			const char* (CLOOP_CARG *getNameSpace)(ITraceContextVariable* self) throw();
			const char* (CLOOP_CARG *getVarName)(ITraceContextVariable* self) throw();
			const char* (CLOOP_CARG *getVarValue)(ITraceContextVariable* self) throw();
		};

	protected:
		ITraceContextVariable(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~ITraceContextVariable()
		{
		}

	public:
		static const unsigned VERSION = 2;

		const char* getNameSpace()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getNameSpace(this);
			return ret;
		}

		const char* getVarName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getVarName(this);
			return ret;
		}

		const char* getVarValue()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getVarValue(this);
			return ret;
		}
	};

	class ITraceProcedure : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			const char* (CLOOP_CARG *getProcName)(ITraceProcedure* self) throw();
			ITraceParams* (CLOOP_CARG *getInputs)(ITraceProcedure* self) throw();
			PerformanceInfo* (CLOOP_CARG *getPerf)(ITraceProcedure* self) throw();
		};

	protected:
		ITraceProcedure(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~ITraceProcedure()
		{
		}

	public:
		static const unsigned VERSION = 2;

		const char* getProcName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getProcName(this);
			return ret;
		}

		ITraceParams* getInputs()
		{
			ITraceParams* ret = static_cast<VTable*>(this->cloopVTable)->getInputs(this);
			return ret;
		}

		PerformanceInfo* getPerf()
		{
			PerformanceInfo* ret = static_cast<VTable*>(this->cloopVTable)->getPerf(this);
			return ret;
		}
	};

	class ITraceFunction : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			const char* (CLOOP_CARG *getFuncName)(ITraceFunction* self) throw();
			ITraceParams* (CLOOP_CARG *getInputs)(ITraceFunction* self) throw();
			ITraceParams* (CLOOP_CARG *getResult)(ITraceFunction* self) throw();
			PerformanceInfo* (CLOOP_CARG *getPerf)(ITraceFunction* self) throw();
		};

	protected:
		ITraceFunction(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~ITraceFunction()
		{
		}

	public:
		static const unsigned VERSION = 2;

		const char* getFuncName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getFuncName(this);
			return ret;
		}

		ITraceParams* getInputs()
		{
			ITraceParams* ret = static_cast<VTable*>(this->cloopVTable)->getInputs(this);
			return ret;
		}

		ITraceParams* getResult()
		{
			ITraceParams* ret = static_cast<VTable*>(this->cloopVTable)->getResult(this);
			return ret;
		}

		PerformanceInfo* getPerf()
		{
			PerformanceInfo* ret = static_cast<VTable*>(this->cloopVTable)->getPerf(this);
			return ret;
		}
	};

	class ITraceTrigger : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			const char* (CLOOP_CARG *getTriggerName)(ITraceTrigger* self) throw();
			const char* (CLOOP_CARG *getRelationName)(ITraceTrigger* self) throw();
			int (CLOOP_CARG *getAction)(ITraceTrigger* self) throw();
			int (CLOOP_CARG *getWhich)(ITraceTrigger* self) throw();
			PerformanceInfo* (CLOOP_CARG *getPerf)(ITraceTrigger* self) throw();
		};

	protected:
		ITraceTrigger(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~ITraceTrigger()
		{
		}

	public:
		static const unsigned VERSION = 2;

		static const unsigned TYPE_ALL = 0;
		static const unsigned TYPE_BEFORE = 1;
		static const unsigned TYPE_AFTER = 2;

		const char* getTriggerName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getTriggerName(this);
			return ret;
		}

		const char* getRelationName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getRelationName(this);
			return ret;
		}

		int getAction()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->getAction(this);
			return ret;
		}

		int getWhich()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->getWhich(this);
			return ret;
		}

		PerformanceInfo* getPerf()
		{
			PerformanceInfo* ret = static_cast<VTable*>(this->cloopVTable)->getPerf(this);
			return ret;
		}
	};

	class ITraceServiceConnection : public ITraceConnection
	{
	public:
		struct VTable : public ITraceConnection::VTable
		{
			void* (CLOOP_CARG *getServiceID)(ITraceServiceConnection* self) throw();
			const char* (CLOOP_CARG *getServiceMgr)(ITraceServiceConnection* self) throw();
			const char* (CLOOP_CARG *getServiceName)(ITraceServiceConnection* self) throw();
		};

	protected:
		ITraceServiceConnection(DoNotInherit)
			: ITraceConnection(DoNotInherit())
		{
		}

		~ITraceServiceConnection()
		{
		}

	public:
		static const unsigned VERSION = 3;

		void* getServiceID()
		{
			void* ret = static_cast<VTable*>(this->cloopVTable)->getServiceID(this);
			return ret;
		}

		const char* getServiceMgr()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getServiceMgr(this);
			return ret;
		}

		const char* getServiceName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getServiceName(this);
			return ret;
		}
	};

	class ITraceStatusVector : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			FB_BOOLEAN (CLOOP_CARG *hasError)(ITraceStatusVector* self) throw();
			FB_BOOLEAN (CLOOP_CARG *hasWarning)(ITraceStatusVector* self) throw();
			IStatus* (CLOOP_CARG *getStatus)(ITraceStatusVector* self) throw();
			const char* (CLOOP_CARG *getText)(ITraceStatusVector* self) throw();
		};

	protected:
		ITraceStatusVector(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~ITraceStatusVector()
		{
		}

	public:
		static const unsigned VERSION = 2;

		FB_BOOLEAN hasError()
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->hasError(this);
			return ret;
		}

		FB_BOOLEAN hasWarning()
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->hasWarning(this);
			return ret;
		}

		IStatus* getStatus()
		{
			IStatus* ret = static_cast<VTable*>(this->cloopVTable)->getStatus(this);
			return ret;
		}

		const char* getText()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getText(this);
			return ret;
		}
	};

	class ITraceSweepInfo : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			ISC_INT64 (CLOOP_CARG *getOIT)(ITraceSweepInfo* self) throw();
			ISC_INT64 (CLOOP_CARG *getOST)(ITraceSweepInfo* self) throw();
			ISC_INT64 (CLOOP_CARG *getOAT)(ITraceSweepInfo* self) throw();
			ISC_INT64 (CLOOP_CARG *getNext)(ITraceSweepInfo* self) throw();
			PerformanceInfo* (CLOOP_CARG *getPerf)(ITraceSweepInfo* self) throw();
		};

	protected:
		ITraceSweepInfo(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~ITraceSweepInfo()
		{
		}

	public:
		static const unsigned VERSION = 2;

		ISC_INT64 getOIT()
		{
			ISC_INT64 ret = static_cast<VTable*>(this->cloopVTable)->getOIT(this);
			return ret;
		}

		ISC_INT64 getOST()
		{
			ISC_INT64 ret = static_cast<VTable*>(this->cloopVTable)->getOST(this);
			return ret;
		}

		ISC_INT64 getOAT()
		{
			ISC_INT64 ret = static_cast<VTable*>(this->cloopVTable)->getOAT(this);
			return ret;
		}

		ISC_INT64 getNext()
		{
			ISC_INT64 ret = static_cast<VTable*>(this->cloopVTable)->getNext(this);
			return ret;
		}

		PerformanceInfo* getPerf()
		{
			PerformanceInfo* ret = static_cast<VTable*>(this->cloopVTable)->getPerf(this);
			return ret;
		}
	};

	class ITraceLogWriter : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			unsigned (CLOOP_CARG *write)(ITraceLogWriter* self, const void* buf, unsigned size) throw();
			unsigned (CLOOP_CARG *write_s)(ITraceLogWriter* self, IStatus* status, const void* buf, unsigned size) throw();
		};

	protected:
		ITraceLogWriter(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~ITraceLogWriter()
		{
		}

	public:
		static const unsigned VERSION = 4;

		unsigned write(const void* buf, unsigned size)
		{
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->write(this, buf, size);
			return ret;
		}

		template <typename StatusType> unsigned write_s(StatusType* status, const void* buf, unsigned size)
		{
			if (cloopVTable->version < 4)
			{
				StatusType::setVersionError(status, "ITraceLogWriter", cloopVTable->version, 4);
				StatusType::checkException(status);
				return 0;
			}
			StatusType::clearException(status);
			unsigned ret = static_cast<VTable*>(this->cloopVTable)->write_s(this, status, buf, size);
			StatusType::checkException(status);
			return ret;
		}
	};

	class ITraceInitInfo : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			const char* (CLOOP_CARG *getConfigText)(ITraceInitInfo* self) throw();
			int (CLOOP_CARG *getTraceSessionID)(ITraceInitInfo* self) throw();
			const char* (CLOOP_CARG *getTraceSessionName)(ITraceInitInfo* self) throw();
			const char* (CLOOP_CARG *getFirebirdRootDirectory)(ITraceInitInfo* self) throw();
			const char* (CLOOP_CARG *getDatabaseName)(ITraceInitInfo* self) throw();
			ITraceDatabaseConnection* (CLOOP_CARG *getConnection)(ITraceInitInfo* self) throw();
			ITraceLogWriter* (CLOOP_CARG *getLogWriter)(ITraceInitInfo* self) throw();
		};

	protected:
		ITraceInitInfo(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~ITraceInitInfo()
		{
		}

	public:
		static const unsigned VERSION = 2;

		const char* getConfigText()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getConfigText(this);
			return ret;
		}

		int getTraceSessionID()
		{
			int ret = static_cast<VTable*>(this->cloopVTable)->getTraceSessionID(this);
			return ret;
		}

		const char* getTraceSessionName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getTraceSessionName(this);
			return ret;
		}

		const char* getFirebirdRootDirectory()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getFirebirdRootDirectory(this);
			return ret;
		}

		const char* getDatabaseName()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->getDatabaseName(this);
			return ret;
		}

		ITraceDatabaseConnection* getConnection()
		{
			ITraceDatabaseConnection* ret = static_cast<VTable*>(this->cloopVTable)->getConnection(this);
			return ret;
		}

		ITraceLogWriter* getLogWriter()
		{
			ITraceLogWriter* ret = static_cast<VTable*>(this->cloopVTable)->getLogWriter(this);
			return ret;
		}
	};

	class ITracePlugin : public IReferenceCounted
	{
	public:
		struct VTable : public IReferenceCounted::VTable
		{
			const char* (CLOOP_CARG *trace_get_error)(ITracePlugin* self) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_attach)(ITracePlugin* self, ITraceDatabaseConnection* connection, FB_BOOLEAN create_db, unsigned att_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_detach)(ITracePlugin* self, ITraceDatabaseConnection* connection, FB_BOOLEAN drop_db) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_transaction_start)(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, unsigned tpb_length, const unsigned char* tpb, unsigned tra_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_transaction_end)(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, FB_BOOLEAN commit, FB_BOOLEAN retain_context, unsigned tra_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_proc_execute)(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceProcedure* procedure, FB_BOOLEAN started, unsigned proc_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_trigger_execute)(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceTrigger* trigger, FB_BOOLEAN started, unsigned trig_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_set_context)(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceContextVariable* variable) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_dsql_prepare)(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceSQLStatement* statement, ISC_INT64 time_millis, unsigned req_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_dsql_free)(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceSQLStatement* statement, unsigned option) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_dsql_execute)(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceSQLStatement* statement, FB_BOOLEAN started, unsigned req_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_blr_compile)(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceBLRStatement* statement, ISC_INT64 time_millis, unsigned req_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_blr_execute)(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceBLRStatement* statement, unsigned req_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_dyn_execute)(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceDYNRequest* request, ISC_INT64 time_millis, unsigned req_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_service_attach)(ITracePlugin* self, ITraceServiceConnection* service, unsigned att_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_service_start)(ITracePlugin* self, ITraceServiceConnection* service, unsigned switches_length, const char* switches, unsigned start_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_service_query)(ITracePlugin* self, ITraceServiceConnection* service, unsigned send_item_length, const unsigned char* send_items, unsigned recv_item_length, const unsigned char* recv_items, unsigned query_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_service_detach)(ITracePlugin* self, ITraceServiceConnection* service, unsigned detach_result) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_event_error)(ITracePlugin* self, ITraceConnection* connection, ITraceStatusVector* status, const char* function) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_event_sweep)(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceSweepInfo* sweep, unsigned sweep_state) throw();
			FB_BOOLEAN (CLOOP_CARG *trace_func_execute)(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceFunction* function, FB_BOOLEAN started, unsigned func_result) throw();
		};

	protected:
		ITracePlugin(DoNotInherit)
			: IReferenceCounted(DoNotInherit())
		{
		}

		~ITracePlugin()
		{
		}

	public:
		static const unsigned VERSION = 3;

		static const unsigned RESULT_SUCCESS = 0;
		static const unsigned RESULT_FAILED = 1;
		static const unsigned RESULT_UNAUTHORIZED = 2;
		static const unsigned SWEEP_STATE_STARTED = 1;
		static const unsigned SWEEP_STATE_FINISHED = 2;
		static const unsigned SWEEP_STATE_FAILED = 3;
		static const unsigned SWEEP_STATE_PROGRESS = 4;

		const char* trace_get_error()
		{
			const char* ret = static_cast<VTable*>(this->cloopVTable)->trace_get_error(this);
			return ret;
		}

		FB_BOOLEAN trace_attach(ITraceDatabaseConnection* connection, FB_BOOLEAN create_db, unsigned att_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_attach(this, connection, create_db, att_result);
			return ret;
		}

		FB_BOOLEAN trace_detach(ITraceDatabaseConnection* connection, FB_BOOLEAN drop_db)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_detach(this, connection, drop_db);
			return ret;
		}

		FB_BOOLEAN trace_transaction_start(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, unsigned tpb_length, const unsigned char* tpb, unsigned tra_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_transaction_start(this, connection, transaction, tpb_length, tpb, tra_result);
			return ret;
		}

		FB_BOOLEAN trace_transaction_end(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, FB_BOOLEAN commit, FB_BOOLEAN retain_context, unsigned tra_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_transaction_end(this, connection, transaction, commit, retain_context, tra_result);
			return ret;
		}

		FB_BOOLEAN trace_proc_execute(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceProcedure* procedure, FB_BOOLEAN started, unsigned proc_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_proc_execute(this, connection, transaction, procedure, started, proc_result);
			return ret;
		}

		FB_BOOLEAN trace_trigger_execute(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceTrigger* trigger, FB_BOOLEAN started, unsigned trig_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_trigger_execute(this, connection, transaction, trigger, started, trig_result);
			return ret;
		}

		FB_BOOLEAN trace_set_context(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceContextVariable* variable)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_set_context(this, connection, transaction, variable);
			return ret;
		}

		FB_BOOLEAN trace_dsql_prepare(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceSQLStatement* statement, ISC_INT64 time_millis, unsigned req_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_dsql_prepare(this, connection, transaction, statement, time_millis, req_result);
			return ret;
		}

		FB_BOOLEAN trace_dsql_free(ITraceDatabaseConnection* connection, ITraceSQLStatement* statement, unsigned option)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_dsql_free(this, connection, statement, option);
			return ret;
		}

		FB_BOOLEAN trace_dsql_execute(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceSQLStatement* statement, FB_BOOLEAN started, unsigned req_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_dsql_execute(this, connection, transaction, statement, started, req_result);
			return ret;
		}

		FB_BOOLEAN trace_blr_compile(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceBLRStatement* statement, ISC_INT64 time_millis, unsigned req_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_blr_compile(this, connection, transaction, statement, time_millis, req_result);
			return ret;
		}

		FB_BOOLEAN trace_blr_execute(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceBLRStatement* statement, unsigned req_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_blr_execute(this, connection, transaction, statement, req_result);
			return ret;
		}

		FB_BOOLEAN trace_dyn_execute(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceDYNRequest* request, ISC_INT64 time_millis, unsigned req_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_dyn_execute(this, connection, transaction, request, time_millis, req_result);
			return ret;
		}

		FB_BOOLEAN trace_service_attach(ITraceServiceConnection* service, unsigned att_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_service_attach(this, service, att_result);
			return ret;
		}

		FB_BOOLEAN trace_service_start(ITraceServiceConnection* service, unsigned switches_length, const char* switches, unsigned start_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_service_start(this, service, switches_length, switches, start_result);
			return ret;
		}

		FB_BOOLEAN trace_service_query(ITraceServiceConnection* service, unsigned send_item_length, const unsigned char* send_items, unsigned recv_item_length, const unsigned char* recv_items, unsigned query_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_service_query(this, service, send_item_length, send_items, recv_item_length, recv_items, query_result);
			return ret;
		}

		FB_BOOLEAN trace_service_detach(ITraceServiceConnection* service, unsigned detach_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_service_detach(this, service, detach_result);
			return ret;
		}

		FB_BOOLEAN trace_event_error(ITraceConnection* connection, ITraceStatusVector* status, const char* function)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_event_error(this, connection, status, function);
			return ret;
		}

		FB_BOOLEAN trace_event_sweep(ITraceDatabaseConnection* connection, ITraceSweepInfo* sweep, unsigned sweep_state)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_event_sweep(this, connection, sweep, sweep_state);
			return ret;
		}

		FB_BOOLEAN trace_func_execute(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceFunction* function, FB_BOOLEAN started, unsigned func_result)
		{
			FB_BOOLEAN ret = static_cast<VTable*>(this->cloopVTable)->trace_func_execute(this, connection, transaction, function, started, func_result);
			return ret;
		}
	};

	class ITraceFactory : public IPluginBase
	{
	public:
		struct VTable : public IPluginBase::VTable
		{
			ISC_UINT64 (CLOOP_CARG *trace_needs)(ITraceFactory* self) throw();
			ITracePlugin* (CLOOP_CARG *trace_create)(ITraceFactory* self, IStatus* status, ITraceInitInfo* init_info) throw();
		};

	protected:
		ITraceFactory(DoNotInherit)
			: IPluginBase(DoNotInherit())
		{
		}

		~ITraceFactory()
		{
		}

	public:
		static const unsigned VERSION = 4;

		static const unsigned TRACE_EVENT_ATTACH = 0;
		static const unsigned TRACE_EVENT_DETACH = 1;
		static const unsigned TRACE_EVENT_TRANSACTION_START = 2;
		static const unsigned TRACE_EVENT_TRANSACTION_END = 3;
		static const unsigned TRACE_EVENT_SET_CONTEXT = 4;
		static const unsigned TRACE_EVENT_PROC_EXECUTE = 5;
		static const unsigned TRACE_EVENT_TRIGGER_EXECUTE = 6;
		static const unsigned TRACE_EVENT_DSQL_PREPARE = 7;
		static const unsigned TRACE_EVENT_DSQL_FREE = 8;
		static const unsigned TRACE_EVENT_DSQL_EXECUTE = 9;
		static const unsigned TRACE_EVENT_BLR_COMPILE = 10;
		static const unsigned TRACE_EVENT_BLR_EXECUTE = 11;
		static const unsigned TRACE_EVENT_DYN_EXECUTE = 12;
		static const unsigned TRACE_EVENT_SERVICE_ATTACH = 13;
		static const unsigned TRACE_EVENT_SERVICE_START = 14;
		static const unsigned TRACE_EVENT_SERVICE_QUERY = 15;
		static const unsigned TRACE_EVENT_SERVICE_DETACH = 16;
		static const unsigned TRACE_EVENT_ERROR = 17;
		static const unsigned TRACE_EVENT_SWEEP = 18;
		static const unsigned TRACE_EVENT_FUNC_EXECUTE = 19;
		static const unsigned TRACE_EVENT_MAX = 20;

		ISC_UINT64 trace_needs()
		{
			ISC_UINT64 ret = static_cast<VTable*>(this->cloopVTable)->trace_needs(this);
			return ret;
		}

		template <typename StatusType> ITracePlugin* trace_create(StatusType* status, ITraceInitInfo* init_info)
		{
			StatusType::clearException(status);
			ITracePlugin* ret = static_cast<VTable*>(this->cloopVTable)->trace_create(this, status, init_info);
			StatusType::checkException(status);
			return ret;
		}
	};

	class IUdrFunctionFactory : public IDisposable
	{
	public:
		struct VTable : public IDisposable::VTable
		{
			void (CLOOP_CARG *setup)(IUdrFunctionFactory* self, IStatus* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* inBuilder, IMetadataBuilder* outBuilder) throw();
			IExternalFunction* (CLOOP_CARG *newItem)(IUdrFunctionFactory* self, IStatus* status, IExternalContext* context, IRoutineMetadata* metadata) throw();
		};

	protected:
		IUdrFunctionFactory(DoNotInherit)
			: IDisposable(DoNotInherit())
		{
		}

		~IUdrFunctionFactory()
		{
		}

	public:
		static const unsigned VERSION = 3;

		template <typename StatusType> void setup(StatusType* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* inBuilder, IMetadataBuilder* outBuilder)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->setup(this, status, context, metadata, inBuilder, outBuilder);
			StatusType::checkException(status);
		}

		template <typename StatusType> IExternalFunction* newItem(StatusType* status, IExternalContext* context, IRoutineMetadata* metadata)
		{
			StatusType::clearException(status);
			IExternalFunction* ret = static_cast<VTable*>(this->cloopVTable)->newItem(this, status, context, metadata);
			StatusType::checkException(status);
			return ret;
		}
	};

	class IUdrProcedureFactory : public IDisposable
	{
	public:
		struct VTable : public IDisposable::VTable
		{
			void (CLOOP_CARG *setup)(IUdrProcedureFactory* self, IStatus* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* inBuilder, IMetadataBuilder* outBuilder) throw();
			IExternalProcedure* (CLOOP_CARG *newItem)(IUdrProcedureFactory* self, IStatus* status, IExternalContext* context, IRoutineMetadata* metadata) throw();
		};

	protected:
		IUdrProcedureFactory(DoNotInherit)
			: IDisposable(DoNotInherit())
		{
		}

		~IUdrProcedureFactory()
		{
		}

	public:
		static const unsigned VERSION = 3;

		template <typename StatusType> void setup(StatusType* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* inBuilder, IMetadataBuilder* outBuilder)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->setup(this, status, context, metadata, inBuilder, outBuilder);
			StatusType::checkException(status);
		}

		template <typename StatusType> IExternalProcedure* newItem(StatusType* status, IExternalContext* context, IRoutineMetadata* metadata)
		{
			StatusType::clearException(status);
			IExternalProcedure* ret = static_cast<VTable*>(this->cloopVTable)->newItem(this, status, context, metadata);
			StatusType::checkException(status);
			return ret;
		}
	};

	class IUdrTriggerFactory : public IDisposable
	{
	public:
		struct VTable : public IDisposable::VTable
		{
			void (CLOOP_CARG *setup)(IUdrTriggerFactory* self, IStatus* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* fieldsBuilder) throw();
			IExternalTrigger* (CLOOP_CARG *newItem)(IUdrTriggerFactory* self, IStatus* status, IExternalContext* context, IRoutineMetadata* metadata) throw();
		};

	protected:
		IUdrTriggerFactory(DoNotInherit)
			: IDisposable(DoNotInherit())
		{
		}

		~IUdrTriggerFactory()
		{
		}

	public:
		static const unsigned VERSION = 3;

		template <typename StatusType> void setup(StatusType* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* fieldsBuilder)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->setup(this, status, context, metadata, fieldsBuilder);
			StatusType::checkException(status);
		}

		template <typename StatusType> IExternalTrigger* newItem(StatusType* status, IExternalContext* context, IRoutineMetadata* metadata)
		{
			StatusType::clearException(status);
			IExternalTrigger* ret = static_cast<VTable*>(this->cloopVTable)->newItem(this, status, context, metadata);
			StatusType::checkException(status);
			return ret;
		}
	};

	class IUdrPlugin : public IVersioned
	{
	public:
		struct VTable : public IVersioned::VTable
		{
			IMaster* (CLOOP_CARG *getMaster)(IUdrPlugin* self) throw();
			void (CLOOP_CARG *registerFunction)(IUdrPlugin* self, IStatus* status, const char* name, IUdrFunctionFactory* factory) throw();
			void (CLOOP_CARG *registerProcedure)(IUdrPlugin* self, IStatus* status, const char* name, IUdrProcedureFactory* factory) throw();
			void (CLOOP_CARG *registerTrigger)(IUdrPlugin* self, IStatus* status, const char* name, IUdrTriggerFactory* factory) throw();
		};

	protected:
		IUdrPlugin(DoNotInherit)
			: IVersioned(DoNotInherit())
		{
		}

		~IUdrPlugin()
		{
		}

	public:
		static const unsigned VERSION = 2;

		IMaster* getMaster()
		{
			IMaster* ret = static_cast<VTable*>(this->cloopVTable)->getMaster(this);
			return ret;
		}

		template <typename StatusType> void registerFunction(StatusType* status, const char* name, IUdrFunctionFactory* factory)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->registerFunction(this, status, name, factory);
			StatusType::checkException(status);
		}

		template <typename StatusType> void registerProcedure(StatusType* status, const char* name, IUdrProcedureFactory* factory)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->registerProcedure(this, status, name, factory);
			StatusType::checkException(status);
		}

		template <typename StatusType> void registerTrigger(StatusType* status, const char* name, IUdrTriggerFactory* factory)
		{
			StatusType::clearException(status);
			static_cast<VTable*>(this->cloopVTable)->registerTrigger(this, status, name, factory);
			StatusType::checkException(status);
		}
	};

	// Interfaces implementations

	template <typename Name, typename StatusType, typename Base>
	class IVersionedBaseImpl : public Base
	{
	public:
		typedef IVersioned Declaration;

		IVersionedBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}
	};

	template <typename Name, typename StatusType, typename Base = Inherit<IVersioned> >
	class IVersionedImpl : public IVersionedBaseImpl<Name, StatusType, Base>
	{
	protected:
		IVersionedImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IVersionedImpl()
		{
		}

	};

	template <typename Name, typename StatusType, typename Base>
	class IReferenceCountedBaseImpl : public Base
	{
	public:
		typedef IReferenceCounted Declaration;

		IReferenceCountedBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<IReferenceCounted> > >
	class IReferenceCountedImpl : public IReferenceCountedBaseImpl<Name, StatusType, Base>
	{
	protected:
		IReferenceCountedImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IReferenceCountedImpl()
		{
		}

		virtual void addRef() = 0;
		virtual int release() = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IDisposableBaseImpl : public Base
	{
	public:
		typedef IDisposable Declaration;

		IDisposableBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->dispose = &Name::cloopdisposeDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopdisposeDispatcher(IDisposable* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::dispose();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<IDisposable> > >
	class IDisposableImpl : public IDisposableBaseImpl<Name, StatusType, Base>
	{
	protected:
		IDisposableImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IDisposableImpl()
		{
		}

		virtual void dispose() = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IStatusBaseImpl : public Base
	{
	public:
		typedef IStatus Declaration;

		IStatusBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->dispose = &Name::cloopdisposeDispatcher;
					this->init = &Name::cloopinitDispatcher;
					this->getState = &Name::cloopgetStateDispatcher;
					this->setErrors2 = &Name::cloopsetErrors2Dispatcher;
					this->setWarnings2 = &Name::cloopsetWarnings2Dispatcher;
					this->setErrors = &Name::cloopsetErrorsDispatcher;
					this->setWarnings = &Name::cloopsetWarningsDispatcher;
					this->getErrors = &Name::cloopgetErrorsDispatcher;
					this->getWarnings = &Name::cloopgetWarningsDispatcher;
					this->clone = &Name::cloopcloneDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopinitDispatcher(IStatus* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::init();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetStateDispatcher(const IStatus* self) throw()
		{
			try
			{
				return static_cast<const Name*>(self)->Name::getState();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static void CLOOP_CARG cloopsetErrors2Dispatcher(IStatus* self, unsigned length, const intptr_t* value) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setErrors2(length, value);
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static void CLOOP_CARG cloopsetWarnings2Dispatcher(IStatus* self, unsigned length, const intptr_t* value) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setWarnings2(length, value);
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static void CLOOP_CARG cloopsetErrorsDispatcher(IStatus* self, const intptr_t* value) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setErrors(value);
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static void CLOOP_CARG cloopsetWarningsDispatcher(IStatus* self, const intptr_t* value) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setWarnings(value);
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static const intptr_t* CLOOP_CARG cloopgetErrorsDispatcher(const IStatus* self) throw()
		{
			try
			{
				return static_cast<const Name*>(self)->Name::getErrors();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const intptr_t*>(0);
			}
		}

		static const intptr_t* CLOOP_CARG cloopgetWarningsDispatcher(const IStatus* self) throw()
		{
			try
			{
				return static_cast<const Name*>(self)->Name::getWarnings();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const intptr_t*>(0);
			}
		}

		static IStatus* CLOOP_CARG cloopcloneDispatcher(const IStatus* self) throw()
		{
			try
			{
				return static_cast<const Name*>(self)->Name::clone();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<IStatus*>(0);
			}
		}

		static void CLOOP_CARG cloopdisposeDispatcher(IDisposable* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::dispose();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IDisposableImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IStatus> > > > >
	class IStatusImpl : public IStatusBaseImpl<Name, StatusType, Base>
	{
	protected:
		IStatusImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IStatusImpl()
		{
		}

		virtual void init() = 0;
		virtual unsigned getState() const = 0;
		virtual void setErrors2(unsigned length, const intptr_t* value) = 0;
		virtual void setWarnings2(unsigned length, const intptr_t* value) = 0;
		virtual void setErrors(const intptr_t* value) = 0;
		virtual void setWarnings(const intptr_t* value) = 0;
		virtual const intptr_t* getErrors() const = 0;
		virtual const intptr_t* getWarnings() const = 0;
		virtual IStatus* clone() const = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IMasterBaseImpl : public Base
	{
	public:
		typedef IMaster Declaration;

		IMasterBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getStatus = &Name::cloopgetStatusDispatcher;
					this->getDispatcher = &Name::cloopgetDispatcherDispatcher;
					this->getPluginManager = &Name::cloopgetPluginManagerDispatcher;
					this->getTimerControl = &Name::cloopgetTimerControlDispatcher;
					this->getDtc = &Name::cloopgetDtcDispatcher;
					this->registerAttachment = &Name::cloopregisterAttachmentDispatcher;
					this->registerTransaction = &Name::cloopregisterTransactionDispatcher;
					this->getMetadataBuilder = &Name::cloopgetMetadataBuilderDispatcher;
					this->serverMode = &Name::cloopserverModeDispatcher;
					this->getUtilInterface = &Name::cloopgetUtilInterfaceDispatcher;
					this->getConfigManager = &Name::cloopgetConfigManagerDispatcher;
					this->getProcessExiting = &Name::cloopgetProcessExitingDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static IStatus* CLOOP_CARG cloopgetStatusDispatcher(IMaster* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getStatus();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<IStatus*>(0);
			}
		}

		static IProvider* CLOOP_CARG cloopgetDispatcherDispatcher(IMaster* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getDispatcher();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<IProvider*>(0);
			}
		}

		static IPluginManager* CLOOP_CARG cloopgetPluginManagerDispatcher(IMaster* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPluginManager();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<IPluginManager*>(0);
			}
		}

		static ITimerControl* CLOOP_CARG cloopgetTimerControlDispatcher(IMaster* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getTimerControl();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<ITimerControl*>(0);
			}
		}

		static IDtc* CLOOP_CARG cloopgetDtcDispatcher(IMaster* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getDtc();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<IDtc*>(0);
			}
		}

		static IAttachment* CLOOP_CARG cloopregisterAttachmentDispatcher(IMaster* self, IProvider* provider, IAttachment* attachment) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::registerAttachment(provider, attachment);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<IAttachment*>(0);
			}
		}

		static ITransaction* CLOOP_CARG cloopregisterTransactionDispatcher(IMaster* self, IAttachment* attachment, ITransaction* transaction) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::registerTransaction(attachment, transaction);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<ITransaction*>(0);
			}
		}

		static IMetadataBuilder* CLOOP_CARG cloopgetMetadataBuilderDispatcher(IMaster* self, IStatus* status, unsigned fieldCount) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getMetadataBuilder(&status2, fieldCount);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IMetadataBuilder*>(0);
			}
		}

		static int CLOOP_CARG cloopserverModeDispatcher(IMaster* self, int mode) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::serverMode(mode);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}

		static IUtil* CLOOP_CARG cloopgetUtilInterfaceDispatcher(IMaster* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getUtilInterface();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<IUtil*>(0);
			}
		}

		static IConfigManager* CLOOP_CARG cloopgetConfigManagerDispatcher(IMaster* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getConfigManager();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<IConfigManager*>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG cloopgetProcessExitingDispatcher(IMaster* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getProcessExiting();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<IMaster> > >
	class IMasterImpl : public IMasterBaseImpl<Name, StatusType, Base>
	{
	protected:
		IMasterImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IMasterImpl()
		{
		}

		virtual IStatus* getStatus() = 0;
		virtual IProvider* getDispatcher() = 0;
		virtual IPluginManager* getPluginManager() = 0;
		virtual ITimerControl* getTimerControl() = 0;
		virtual IDtc* getDtc() = 0;
		virtual IAttachment* registerAttachment(IProvider* provider, IAttachment* attachment) = 0;
		virtual ITransaction* registerTransaction(IAttachment* attachment, ITransaction* transaction) = 0;
		virtual IMetadataBuilder* getMetadataBuilder(StatusType* status, unsigned fieldCount) = 0;
		virtual int serverMode(int mode) = 0;
		virtual IUtil* getUtilInterface() = 0;
		virtual IConfigManager* getConfigManager() = 0;
		virtual FB_BOOLEAN getProcessExiting() = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IPluginBaseBaseImpl : public Base
	{
	public:
		typedef IPluginBase Declaration;

		IPluginBaseBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setOwner = &Name::cloopsetOwnerDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopsetOwnerDispatcher(IPluginBase* self, IReferenceCounted* r) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setOwner(r);
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static IReferenceCounted* CLOOP_CARG cloopgetOwnerDispatcher(IPluginBase* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOwner();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<IReferenceCounted*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IReferenceCountedImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IPluginBase> > > > >
	class IPluginBaseImpl : public IPluginBaseBaseImpl<Name, StatusType, Base>
	{
	protected:
		IPluginBaseImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IPluginBaseImpl()
		{
		}

		virtual void setOwner(IReferenceCounted* r) = 0;
		virtual IReferenceCounted* getOwner() = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IPluginSetBaseImpl : public Base
	{
	public:
		typedef IPluginSet Declaration;

		IPluginSetBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->getName = &Name::cloopgetNameDispatcher;
					this->getModuleName = &Name::cloopgetModuleNameDispatcher;
					this->getPlugin = &Name::cloopgetPluginDispatcher;
					this->next = &Name::cloopnextDispatcher;
					this->set = &Name::cloopsetDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetNameDispatcher(const IPluginSet* self) throw()
		{
			try
			{
				return static_cast<const Name*>(self)->Name::getName();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetModuleNameDispatcher(const IPluginSet* self) throw()
		{
			try
			{
				return static_cast<const Name*>(self)->Name::getModuleName();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static IPluginBase* CLOOP_CARG cloopgetPluginDispatcher(IPluginSet* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getPlugin(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IPluginBase*>(0);
			}
		}

		static void CLOOP_CARG cloopnextDispatcher(IPluginSet* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::next(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopsetDispatcher(IPluginSet* self, IStatus* status, const char* s) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::set(&status2, s);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IReferenceCountedImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IPluginSet> > > > >
	class IPluginSetImpl : public IPluginSetBaseImpl<Name, StatusType, Base>
	{
	protected:
		IPluginSetImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IPluginSetImpl()
		{
		}

		virtual const char* getName() const = 0;
		virtual const char* getModuleName() const = 0;
		virtual IPluginBase* getPlugin(StatusType* status) = 0;
		virtual void next(StatusType* status) = 0;
		virtual void set(StatusType* status, const char* s) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IConfigEntryBaseImpl : public Base
	{
	public:
		typedef IConfigEntry Declaration;

		IConfigEntryBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->getName = &Name::cloopgetNameDispatcher;
					this->getValue = &Name::cloopgetValueDispatcher;
					this->getIntValue = &Name::cloopgetIntValueDispatcher;
					this->getBoolValue = &Name::cloopgetBoolValueDispatcher;
					this->getSubConfig = &Name::cloopgetSubConfigDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetNameDispatcher(IConfigEntry* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getName();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetValueDispatcher(IConfigEntry* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getValue();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static ISC_INT64 CLOOP_CARG cloopgetIntValueDispatcher(IConfigEntry* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getIntValue();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<ISC_INT64>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG cloopgetBoolValueDispatcher(IConfigEntry* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getBoolValue();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static IConfig* CLOOP_CARG cloopgetSubConfigDispatcher(IConfigEntry* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getSubConfig(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IConfig*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IReferenceCountedImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IConfigEntry> > > > >
	class IConfigEntryImpl : public IConfigEntryBaseImpl<Name, StatusType, Base>
	{
	protected:
		IConfigEntryImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IConfigEntryImpl()
		{
		}

		virtual const char* getName() = 0;
		virtual const char* getValue() = 0;
		virtual ISC_INT64 getIntValue() = 0;
		virtual FB_BOOLEAN getBoolValue() = 0;
		virtual IConfig* getSubConfig(StatusType* status) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IConfigBaseImpl : public Base
	{
	public:
		typedef IConfig Declaration;

		IConfigBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->find = &Name::cloopfindDispatcher;
					this->findValue = &Name::cloopfindValueDispatcher;
					this->findPos = &Name::cloopfindPosDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static IConfigEntry* CLOOP_CARG cloopfindDispatcher(IConfig* self, IStatus* status, const char* name) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::find(&status2, name);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IConfigEntry*>(0);
			}
		}

		static IConfigEntry* CLOOP_CARG cloopfindValueDispatcher(IConfig* self, IStatus* status, const char* name, const char* value) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::findValue(&status2, name, value);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IConfigEntry*>(0);
			}
		}

		static IConfigEntry* CLOOP_CARG cloopfindPosDispatcher(IConfig* self, IStatus* status, const char* name, unsigned pos) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::findPos(&status2, name, pos);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IConfigEntry*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IReferenceCountedImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IConfig> > > > >
	class IConfigImpl : public IConfigBaseImpl<Name, StatusType, Base>
	{
	protected:
		IConfigImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IConfigImpl()
		{
		}

		virtual IConfigEntry* find(StatusType* status, const char* name) = 0;
		virtual IConfigEntry* findValue(StatusType* status, const char* name, const char* value) = 0;
		virtual IConfigEntry* findPos(StatusType* status, const char* name, unsigned pos) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IFirebirdConfBaseImpl : public Base
	{
	public:
		typedef IFirebirdConf Declaration;

		IFirebirdConfBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->getKey = &Name::cloopgetKeyDispatcher;
					this->asInteger = &Name::cloopasIntegerDispatcher;
					this->asString = &Name::cloopasStringDispatcher;
					this->asBoolean = &Name::cloopasBooleanDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static unsigned CLOOP_CARG cloopgetKeyDispatcher(IFirebirdConf* self, const char* name) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getKey(name);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static ISC_INT64 CLOOP_CARG cloopasIntegerDispatcher(IFirebirdConf* self, unsigned key) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::asInteger(key);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<ISC_INT64>(0);
			}
		}

		static const char* CLOOP_CARG cloopasStringDispatcher(IFirebirdConf* self, unsigned key) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::asString(key);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG cloopasBooleanDispatcher(IFirebirdConf* self, unsigned key) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::asBoolean(key);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IReferenceCountedImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IFirebirdConf> > > > >
	class IFirebirdConfImpl : public IFirebirdConfBaseImpl<Name, StatusType, Base>
	{
	protected:
		IFirebirdConfImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IFirebirdConfImpl()
		{
		}

		virtual unsigned getKey(const char* name) = 0;
		virtual ISC_INT64 asInteger(unsigned key) = 0;
		virtual const char* asString(unsigned key) = 0;
		virtual FB_BOOLEAN asBoolean(unsigned key) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IPluginConfigBaseImpl : public Base
	{
	public:
		typedef IPluginConfig Declaration;

		IPluginConfigBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->getConfigFileName = &Name::cloopgetConfigFileNameDispatcher;
					this->getDefaultConfig = &Name::cloopgetDefaultConfigDispatcher;
					this->getFirebirdConf = &Name::cloopgetFirebirdConfDispatcher;
					this->setReleaseDelay = &Name::cloopsetReleaseDelayDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetConfigFileNameDispatcher(IPluginConfig* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getConfigFileName();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static IConfig* CLOOP_CARG cloopgetDefaultConfigDispatcher(IPluginConfig* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getDefaultConfig(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IConfig*>(0);
			}
		}

		static IFirebirdConf* CLOOP_CARG cloopgetFirebirdConfDispatcher(IPluginConfig* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getFirebirdConf(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IFirebirdConf*>(0);
			}
		}

		static void CLOOP_CARG cloopsetReleaseDelayDispatcher(IPluginConfig* self, IStatus* status, ISC_UINT64 microSeconds) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::setReleaseDelay(&status2, microSeconds);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IReferenceCountedImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IPluginConfig> > > > >
	class IPluginConfigImpl : public IPluginConfigBaseImpl<Name, StatusType, Base>
	{
	protected:
		IPluginConfigImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IPluginConfigImpl()
		{
		}

		virtual const char* getConfigFileName() = 0;
		virtual IConfig* getDefaultConfig(StatusType* status) = 0;
		virtual IFirebirdConf* getFirebirdConf(StatusType* status) = 0;
		virtual void setReleaseDelay(StatusType* status, ISC_UINT64 microSeconds) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IPluginFactoryBaseImpl : public Base
	{
	public:
		typedef IPluginFactory Declaration;

		IPluginFactoryBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->createPlugin = &Name::cloopcreatePluginDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static IPluginBase* CLOOP_CARG cloopcreatePluginDispatcher(IPluginFactory* self, IStatus* status, IPluginConfig* factoryParameter) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::createPlugin(&status2, factoryParameter);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IPluginBase*>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<IPluginFactory> > >
	class IPluginFactoryImpl : public IPluginFactoryBaseImpl<Name, StatusType, Base>
	{
	protected:
		IPluginFactoryImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IPluginFactoryImpl()
		{
		}

		virtual IPluginBase* createPlugin(StatusType* status, IPluginConfig* factoryParameter) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IPluginModuleBaseImpl : public Base
	{
	public:
		typedef IPluginModule Declaration;

		IPluginModuleBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->doClean = &Name::cloopdoCleanDispatcher;
					this->threadDetach = &Name::cloopthreadDetachDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopdoCleanDispatcher(IPluginModule* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::doClean();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static void CLOOP_CARG cloopthreadDetachDispatcher(IPluginModule* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::threadDetach();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<IPluginModule> > >
	class IPluginModuleImpl : public IPluginModuleBaseImpl<Name, StatusType, Base>
	{
	protected:
		IPluginModuleImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IPluginModuleImpl()
		{
		}

		virtual void doClean() = 0;
		virtual void threadDetach() = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IPluginManagerBaseImpl : public Base
	{
	public:
		typedef IPluginManager Declaration;

		IPluginManagerBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->registerPluginFactory = &Name::cloopregisterPluginFactoryDispatcher;
					this->registerModule = &Name::cloopregisterModuleDispatcher;
					this->unregisterModule = &Name::cloopunregisterModuleDispatcher;
					this->getPlugins = &Name::cloopgetPluginsDispatcher;
					this->getConfig = &Name::cloopgetConfigDispatcher;
					this->releasePlugin = &Name::cloopreleasePluginDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopregisterPluginFactoryDispatcher(IPluginManager* self, unsigned pluginType, const char* defaultName, IPluginFactory* factory) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::registerPluginFactory(pluginType, defaultName, factory);
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static void CLOOP_CARG cloopregisterModuleDispatcher(IPluginManager* self, IPluginModule* cleanup) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::registerModule(cleanup);
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static void CLOOP_CARG cloopunregisterModuleDispatcher(IPluginManager* self, IPluginModule* cleanup) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::unregisterModule(cleanup);
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static IPluginSet* CLOOP_CARG cloopgetPluginsDispatcher(IPluginManager* self, IStatus* status, unsigned pluginType, const char* namesList, IFirebirdConf* firebirdConf) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getPlugins(&status2, pluginType, namesList, firebirdConf);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IPluginSet*>(0);
			}
		}

		static IConfig* CLOOP_CARG cloopgetConfigDispatcher(IPluginManager* self, IStatus* status, const char* filename) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getConfig(&status2, filename);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IConfig*>(0);
			}
		}

		static void CLOOP_CARG cloopreleasePluginDispatcher(IPluginManager* self, IPluginBase* plugin) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::releasePlugin(plugin);
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<IPluginManager> > >
	class IPluginManagerImpl : public IPluginManagerBaseImpl<Name, StatusType, Base>
	{
	protected:
		IPluginManagerImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IPluginManagerImpl()
		{
		}

		virtual void registerPluginFactory(unsigned pluginType, const char* defaultName, IPluginFactory* factory) = 0;
		virtual void registerModule(IPluginModule* cleanup) = 0;
		virtual void unregisterModule(IPluginModule* cleanup) = 0;
		virtual IPluginSet* getPlugins(StatusType* status, unsigned pluginType, const char* namesList, IFirebirdConf* firebirdConf) = 0;
		virtual IConfig* getConfig(StatusType* status, const char* filename) = 0;
		virtual void releasePlugin(IPluginBase* plugin) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class ICryptKeyBaseImpl : public Base
	{
	public:
		typedef ICryptKey Declaration;

		ICryptKeyBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->setSymmetric = &Name::cloopsetSymmetricDispatcher;
					this->setAsymmetric = &Name::cloopsetAsymmetricDispatcher;
					this->getEncryptKey = &Name::cloopgetEncryptKeyDispatcher;
					this->getDecryptKey = &Name::cloopgetDecryptKeyDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopsetSymmetricDispatcher(ICryptKey* self, IStatus* status, const char* type, unsigned keyLength, const void* key) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::setSymmetric(&status2, type, keyLength, key);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopsetAsymmetricDispatcher(ICryptKey* self, IStatus* status, const char* type, unsigned encryptKeyLength, const void* encryptKey, unsigned decryptKeyLength, const void* decryptKey) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::setAsymmetric(&status2, type, encryptKeyLength, encryptKey, decryptKeyLength, decryptKey);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static const void* CLOOP_CARG cloopgetEncryptKeyDispatcher(ICryptKey* self, unsigned* length) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getEncryptKey(length);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const void*>(0);
			}
		}

		static const void* CLOOP_CARG cloopgetDecryptKeyDispatcher(ICryptKey* self, unsigned* length) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getDecryptKey(length);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const void*>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<ICryptKey> > >
	class ICryptKeyImpl : public ICryptKeyBaseImpl<Name, StatusType, Base>
	{
	protected:
		ICryptKeyImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ICryptKeyImpl()
		{
		}

		virtual void setSymmetric(StatusType* status, const char* type, unsigned keyLength, const void* key) = 0;
		virtual void setAsymmetric(StatusType* status, const char* type, unsigned encryptKeyLength, const void* encryptKey, unsigned decryptKeyLength, const void* decryptKey) = 0;
		virtual const void* getEncryptKey(unsigned* length) = 0;
		virtual const void* getDecryptKey(unsigned* length) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IConfigManagerBaseImpl : public Base
	{
	public:
		typedef IConfigManager Declaration;

		IConfigManagerBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getDirectory = &Name::cloopgetDirectoryDispatcher;
					this->getFirebirdConf = &Name::cloopgetFirebirdConfDispatcher;
					this->getDatabaseConf = &Name::cloopgetDatabaseConfDispatcher;
					this->getPluginConfig = &Name::cloopgetPluginConfigDispatcher;
					this->getInstallDirectory = &Name::cloopgetInstallDirectoryDispatcher;
					this->getRootDirectory = &Name::cloopgetRootDirectoryDispatcher;
					this->getDefaultSecurityDb = &Name::cloopgetDefaultSecurityDbDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetDirectoryDispatcher(IConfigManager* self, unsigned code) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getDirectory(code);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static IFirebirdConf* CLOOP_CARG cloopgetFirebirdConfDispatcher(IConfigManager* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getFirebirdConf();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<IFirebirdConf*>(0);
			}
		}

		static IFirebirdConf* CLOOP_CARG cloopgetDatabaseConfDispatcher(IConfigManager* self, const char* dbName) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getDatabaseConf(dbName);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<IFirebirdConf*>(0);
			}
		}

		static IConfig* CLOOP_CARG cloopgetPluginConfigDispatcher(IConfigManager* self, const char* configuredPlugin) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPluginConfig(configuredPlugin);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<IConfig*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetInstallDirectoryDispatcher(IConfigManager* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getInstallDirectory();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRootDirectoryDispatcher(IConfigManager* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRootDirectory();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetDefaultSecurityDbDispatcher(IConfigManager* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getDefaultSecurityDb();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<IConfigManager> > >
	class IConfigManagerImpl : public IConfigManagerBaseImpl<Name, StatusType, Base>
	{
	protected:
		IConfigManagerImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IConfigManagerImpl()
		{
		}

		virtual const char* getDirectory(unsigned code) = 0;
		virtual IFirebirdConf* getFirebirdConf() = 0;
		virtual IFirebirdConf* getDatabaseConf(const char* dbName) = 0;
		virtual IConfig* getPluginConfig(const char* configuredPlugin) = 0;
		virtual const char* getInstallDirectory() = 0;
		virtual const char* getRootDirectory() = 0;
		virtual const char* getDefaultSecurityDb() = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IEventCallbackBaseImpl : public Base
	{
	public:
		typedef IEventCallback Declaration;

		IEventCallbackBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->eventCallbackFunction = &Name::cloopeventCallbackFunctionDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopeventCallbackFunctionDispatcher(IEventCallback* self, unsigned length, const unsigned char* events) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::eventCallbackFunction(length, events);
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IReferenceCountedImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IEventCallback> > > > >
	class IEventCallbackImpl : public IEventCallbackBaseImpl<Name, StatusType, Base>
	{
	protected:
		IEventCallbackImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IEventCallbackImpl()
		{
		}

		virtual void eventCallbackFunction(unsigned length, const unsigned char* events) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IBlobBaseImpl : public Base
	{
	public:
		typedef IBlob Declaration;

		IBlobBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->getInfo = &Name::cloopgetInfoDispatcher;
					this->getSegment = &Name::cloopgetSegmentDispatcher;
					this->putSegment = &Name::cloopputSegmentDispatcher;
					this->cancel = &Name::cloopcancelDispatcher;
					this->close = &Name::cloopcloseDispatcher;
					this->seek = &Name::cloopseekDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopgetInfoDispatcher(IBlob* self, IStatus* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::getInfo(&status2, itemsLength, items, bufferLength, buffer);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static int CLOOP_CARG cloopgetSegmentDispatcher(IBlob* self, IStatus* status, unsigned bufferLength, void* buffer, unsigned* segmentLength) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getSegment(&status2, bufferLength, buffer, segmentLength);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<int>(0);
			}
		}

		static void CLOOP_CARG cloopputSegmentDispatcher(IBlob* self, IStatus* status, unsigned length, const void* buffer) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::putSegment(&status2, length, buffer);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopcancelDispatcher(IBlob* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::cancel(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopcloseDispatcher(IBlob* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::close(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static int CLOOP_CARG cloopseekDispatcher(IBlob* self, IStatus* status, int mode, int offset) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::seek(&status2, mode, offset);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<int>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IReferenceCountedImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IBlob> > > > >
	class IBlobImpl : public IBlobBaseImpl<Name, StatusType, Base>
	{
	protected:
		IBlobImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IBlobImpl()
		{
		}

		virtual void getInfo(StatusType* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) = 0;
		virtual int getSegment(StatusType* status, unsigned bufferLength, void* buffer, unsigned* segmentLength) = 0;
		virtual void putSegment(StatusType* status, unsigned length, const void* buffer) = 0;
		virtual void cancel(StatusType* status) = 0;
		virtual void close(StatusType* status) = 0;
		virtual int seek(StatusType* status, int mode, int offset) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class ITransactionBaseImpl : public Base
	{
	public:
		typedef ITransaction Declaration;

		ITransactionBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->getInfo = &Name::cloopgetInfoDispatcher;
					this->prepare = &Name::cloopprepareDispatcher;
					this->commit = &Name::cloopcommitDispatcher;
					this->commitRetaining = &Name::cloopcommitRetainingDispatcher;
					this->rollback = &Name::clooprollbackDispatcher;
					this->rollbackRetaining = &Name::clooprollbackRetainingDispatcher;
					this->disconnect = &Name::cloopdisconnectDispatcher;
					this->join = &Name::cloopjoinDispatcher;
					this->validate = &Name::cloopvalidateDispatcher;
					this->enterDtc = &Name::cloopenterDtcDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopgetInfoDispatcher(ITransaction* self, IStatus* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::getInfo(&status2, itemsLength, items, bufferLength, buffer);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopprepareDispatcher(ITransaction* self, IStatus* status, unsigned msgLength, const unsigned char* message) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::prepare(&status2, msgLength, message);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopcommitDispatcher(ITransaction* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::commit(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopcommitRetainingDispatcher(ITransaction* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::commitRetaining(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG clooprollbackDispatcher(ITransaction* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::rollback(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG clooprollbackRetainingDispatcher(ITransaction* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::rollbackRetaining(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopdisconnectDispatcher(ITransaction* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::disconnect(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static ITransaction* CLOOP_CARG cloopjoinDispatcher(ITransaction* self, IStatus* status, ITransaction* transaction) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::join(&status2, transaction);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<ITransaction*>(0);
			}
		}

		static ITransaction* CLOOP_CARG cloopvalidateDispatcher(ITransaction* self, IStatus* status, IAttachment* attachment) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::validate(&status2, attachment);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<ITransaction*>(0);
			}
		}

		static ITransaction* CLOOP_CARG cloopenterDtcDispatcher(ITransaction* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::enterDtc(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<ITransaction*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IReferenceCountedImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<ITransaction> > > > >
	class ITransactionImpl : public ITransactionBaseImpl<Name, StatusType, Base>
	{
	protected:
		ITransactionImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITransactionImpl()
		{
		}

		virtual void getInfo(StatusType* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) = 0;
		virtual void prepare(StatusType* status, unsigned msgLength, const unsigned char* message) = 0;
		virtual void commit(StatusType* status) = 0;
		virtual void commitRetaining(StatusType* status) = 0;
		virtual void rollback(StatusType* status) = 0;
		virtual void rollbackRetaining(StatusType* status) = 0;
		virtual void disconnect(StatusType* status) = 0;
		virtual ITransaction* join(StatusType* status, ITransaction* transaction) = 0;
		virtual ITransaction* validate(StatusType* status, IAttachment* attachment) = 0;
		virtual ITransaction* enterDtc(StatusType* status) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IMessageMetadataBaseImpl : public Base
	{
	public:
		typedef IMessageMetadata Declaration;

		IMessageMetadataBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->getCount = &Name::cloopgetCountDispatcher;
					this->getField = &Name::cloopgetFieldDispatcher;
					this->getRelation = &Name::cloopgetRelationDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
					this->getAlias = &Name::cloopgetAliasDispatcher;
					this->getType = &Name::cloopgetTypeDispatcher;
					this->isNullable = &Name::cloopisNullableDispatcher;
					this->getSubType = &Name::cloopgetSubTypeDispatcher;
					this->getLength = &Name::cloopgetLengthDispatcher;
					this->getScale = &Name::cloopgetScaleDispatcher;
					this->getCharSet = &Name::cloopgetCharSetDispatcher;
					this->getOffset = &Name::cloopgetOffsetDispatcher;
					this->getNullOffset = &Name::cloopgetNullOffsetDispatcher;
					this->getBuilder = &Name::cloopgetBuilderDispatcher;
					this->getMessageLength = &Name::cloopgetMessageLengthDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static unsigned CLOOP_CARG cloopgetCountDispatcher(IMessageMetadata* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getCount(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<unsigned>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetFieldDispatcher(IMessageMetadata* self, IStatus* status, unsigned index) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getField(&status2, index);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRelationDispatcher(IMessageMetadata* self, IStatus* status, unsigned index) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getRelation(&status2, index);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetOwnerDispatcher(IMessageMetadata* self, IStatus* status, unsigned index) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getOwner(&status2, index);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetAliasDispatcher(IMessageMetadata* self, IStatus* status, unsigned index) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getAlias(&status2, index);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<const char*>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetTypeDispatcher(IMessageMetadata* self, IStatus* status, unsigned index) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getType(&status2, index);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<unsigned>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG cloopisNullableDispatcher(IMessageMetadata* self, IStatus* status, unsigned index) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::isNullable(&status2, index);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static int CLOOP_CARG cloopgetSubTypeDispatcher(IMessageMetadata* self, IStatus* status, unsigned index) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getSubType(&status2, index);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<int>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetLengthDispatcher(IMessageMetadata* self, IStatus* status, unsigned index) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getLength(&status2, index);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<unsigned>(0);
			}
		}

		static int CLOOP_CARG cloopgetScaleDispatcher(IMessageMetadata* self, IStatus* status, unsigned index) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getScale(&status2, index);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<int>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetCharSetDispatcher(IMessageMetadata* self, IStatus* status, unsigned index) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getCharSet(&status2, index);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<unsigned>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetOffsetDispatcher(IMessageMetadata* self, IStatus* status, unsigned index) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getOffset(&status2, index);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<unsigned>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetNullOffsetDispatcher(IMessageMetadata* self, IStatus* status, unsigned index) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getNullOffset(&status2, index);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<unsigned>(0);
			}
		}

		static IMetadataBuilder* CLOOP_CARG cloopgetBuilderDispatcher(IMessageMetadata* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getBuilder(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IMetadataBuilder*>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetMessageLengthDispatcher(IMessageMetadata* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getMessageLength(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<unsigned>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IReferenceCountedImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IMessageMetadata> > > > >
	class IMessageMetadataImpl : public IMessageMetadataBaseImpl<Name, StatusType, Base>
	{
	protected:
		IMessageMetadataImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IMessageMetadataImpl()
		{
		}

		virtual unsigned getCount(StatusType* status) = 0;
		virtual const char* getField(StatusType* status, unsigned index) = 0;
		virtual const char* getRelation(StatusType* status, unsigned index) = 0;
		virtual const char* getOwner(StatusType* status, unsigned index) = 0;
		virtual const char* getAlias(StatusType* status, unsigned index) = 0;
		virtual unsigned getType(StatusType* status, unsigned index) = 0;
		virtual FB_BOOLEAN isNullable(StatusType* status, unsigned index) = 0;
		virtual int getSubType(StatusType* status, unsigned index) = 0;
		virtual unsigned getLength(StatusType* status, unsigned index) = 0;
		virtual int getScale(StatusType* status, unsigned index) = 0;
		virtual unsigned getCharSet(StatusType* status, unsigned index) = 0;
		virtual unsigned getOffset(StatusType* status, unsigned index) = 0;
		virtual unsigned getNullOffset(StatusType* status, unsigned index) = 0;
		virtual IMetadataBuilder* getBuilder(StatusType* status) = 0;
		virtual unsigned getMessageLength(StatusType* status) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IMetadataBuilderBaseImpl : public Base
	{
	public:
		typedef IMetadataBuilder Declaration;

		IMetadataBuilderBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setType = &Name::cloopsetTypeDispatcher;
					this->setSubType = &Name::cloopsetSubTypeDispatcher;
					this->setLength = &Name::cloopsetLengthDispatcher;
					this->setCharSet = &Name::cloopsetCharSetDispatcher;
					this->setScale = &Name::cloopsetScaleDispatcher;
					this->truncate = &Name::clooptruncateDispatcher;
					this->moveNameToIndex = &Name::cloopmoveNameToIndexDispatcher;
					this->remove = &Name::cloopremoveDispatcher;
					this->addField = &Name::cloopaddFieldDispatcher;
					this->getMetadata = &Name::cloopgetMetadataDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopsetTypeDispatcher(IMetadataBuilder* self, IStatus* status, unsigned index, unsigned type) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::setType(&status2, index, type);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopsetSubTypeDispatcher(IMetadataBuilder* self, IStatus* status, unsigned index, int subType) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::setSubType(&status2, index, subType);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopsetLengthDispatcher(IMetadataBuilder* self, IStatus* status, unsigned index, unsigned length) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::setLength(&status2, index, length);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopsetCharSetDispatcher(IMetadataBuilder* self, IStatus* status, unsigned index, unsigned charSet) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::setCharSet(&status2, index, charSet);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopsetScaleDispatcher(IMetadataBuilder* self, IStatus* status, unsigned index, int scale) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::setScale(&status2, index, scale);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG clooptruncateDispatcher(IMetadataBuilder* self, IStatus* status, unsigned count) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::truncate(&status2, count);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopmoveNameToIndexDispatcher(IMetadataBuilder* self, IStatus* status, const char* name, unsigned index) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::moveNameToIndex(&status2, name, index);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopremoveDispatcher(IMetadataBuilder* self, IStatus* status, unsigned index) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::remove(&status2, index);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static unsigned CLOOP_CARG cloopaddFieldDispatcher(IMetadataBuilder* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::addField(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<unsigned>(0);
			}
		}

		static IMessageMetadata* CLOOP_CARG cloopgetMetadataDispatcher(IMetadataBuilder* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getMetadata(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IMessageMetadata*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IReferenceCountedImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IMetadataBuilder> > > > >
	class IMetadataBuilderImpl : public IMetadataBuilderBaseImpl<Name, StatusType, Base>
	{
	protected:
		IMetadataBuilderImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IMetadataBuilderImpl()
		{
		}

		virtual void setType(StatusType* status, unsigned index, unsigned type) = 0;
		virtual void setSubType(StatusType* status, unsigned index, int subType) = 0;
		virtual void setLength(StatusType* status, unsigned index, unsigned length) = 0;
		virtual void setCharSet(StatusType* status, unsigned index, unsigned charSet) = 0;
		virtual void setScale(StatusType* status, unsigned index, int scale) = 0;
		virtual void truncate(StatusType* status, unsigned count) = 0;
		virtual void moveNameToIndex(StatusType* status, const char* name, unsigned index) = 0;
		virtual void remove(StatusType* status, unsigned index) = 0;
		virtual unsigned addField(StatusType* status) = 0;
		virtual IMessageMetadata* getMetadata(StatusType* status) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IResultSetBaseImpl : public Base
	{
	public:
		typedef IResultSet Declaration;

		IResultSetBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->fetchNext = &Name::cloopfetchNextDispatcher;
					this->fetchPrior = &Name::cloopfetchPriorDispatcher;
					this->fetchFirst = &Name::cloopfetchFirstDispatcher;
					this->fetchLast = &Name::cloopfetchLastDispatcher;
					this->fetchAbsolute = &Name::cloopfetchAbsoluteDispatcher;
					this->fetchRelative = &Name::cloopfetchRelativeDispatcher;
					this->isEof = &Name::cloopisEofDispatcher;
					this->isBof = &Name::cloopisBofDispatcher;
					this->getMetadata = &Name::cloopgetMetadataDispatcher;
					this->close = &Name::cloopcloseDispatcher;
					this->setDelayedOutputFormat = &Name::cloopsetDelayedOutputFormatDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static int CLOOP_CARG cloopfetchNextDispatcher(IResultSet* self, IStatus* status, void* message) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::fetchNext(&status2, message);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<int>(0);
			}
		}

		static int CLOOP_CARG cloopfetchPriorDispatcher(IResultSet* self, IStatus* status, void* message) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::fetchPrior(&status2, message);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<int>(0);
			}
		}

		static int CLOOP_CARG cloopfetchFirstDispatcher(IResultSet* self, IStatus* status, void* message) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::fetchFirst(&status2, message);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<int>(0);
			}
		}

		static int CLOOP_CARG cloopfetchLastDispatcher(IResultSet* self, IStatus* status, void* message) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::fetchLast(&status2, message);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<int>(0);
			}
		}

		static int CLOOP_CARG cloopfetchAbsoluteDispatcher(IResultSet* self, IStatus* status, int position, void* message) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::fetchAbsolute(&status2, position, message);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<int>(0);
			}
		}

		static int CLOOP_CARG cloopfetchRelativeDispatcher(IResultSet* self, IStatus* status, int offset, void* message) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::fetchRelative(&status2, offset, message);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<int>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG cloopisEofDispatcher(IResultSet* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::isEof(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG cloopisBofDispatcher(IResultSet* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::isBof(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static IMessageMetadata* CLOOP_CARG cloopgetMetadataDispatcher(IResultSet* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getMetadata(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IMessageMetadata*>(0);
			}
		}

		static void CLOOP_CARG cloopcloseDispatcher(IResultSet* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::close(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopsetDelayedOutputFormatDispatcher(IResultSet* self, IStatus* status, IMessageMetadata* format) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::setDelayedOutputFormat(&status2, format);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IReferenceCountedImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IResultSet> > > > >
	class IResultSetImpl : public IResultSetBaseImpl<Name, StatusType, Base>
	{
	protected:
		IResultSetImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IResultSetImpl()
		{
		}

		virtual int fetchNext(StatusType* status, void* message) = 0;
		virtual int fetchPrior(StatusType* status, void* message) = 0;
		virtual int fetchFirst(StatusType* status, void* message) = 0;
		virtual int fetchLast(StatusType* status, void* message) = 0;
		virtual int fetchAbsolute(StatusType* status, int position, void* message) = 0;
		virtual int fetchRelative(StatusType* status, int offset, void* message) = 0;
		virtual FB_BOOLEAN isEof(StatusType* status) = 0;
		virtual FB_BOOLEAN isBof(StatusType* status) = 0;
		virtual IMessageMetadata* getMetadata(StatusType* status) = 0;
		virtual void close(StatusType* status) = 0;
		virtual void setDelayedOutputFormat(StatusType* status, IMessageMetadata* format) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IStatementBaseImpl : public Base
	{
	public:
		typedef IStatement Declaration;

		IStatementBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->getInfo = &Name::cloopgetInfoDispatcher;
					this->getType = &Name::cloopgetTypeDispatcher;
					this->getPlan = &Name::cloopgetPlanDispatcher;
					this->getAffectedRecords = &Name::cloopgetAffectedRecordsDispatcher;
					this->getInputMetadata = &Name::cloopgetInputMetadataDispatcher;
					this->getOutputMetadata = &Name::cloopgetOutputMetadataDispatcher;
					this->execute = &Name::cloopexecuteDispatcher;
					this->openCursor = &Name::cloopopenCursorDispatcher;
					this->setCursorName = &Name::cloopsetCursorNameDispatcher;
					this->free = &Name::cloopfreeDispatcher;
					this->getFlags = &Name::cloopgetFlagsDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopgetInfoDispatcher(IStatement* self, IStatus* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::getInfo(&status2, itemsLength, items, bufferLength, buffer);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static unsigned CLOOP_CARG cloopgetTypeDispatcher(IStatement* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getType(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<unsigned>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetPlanDispatcher(IStatement* self, IStatus* status, FB_BOOLEAN detailed) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getPlan(&status2, detailed);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<const char*>(0);
			}
		}

		static ISC_UINT64 CLOOP_CARG cloopgetAffectedRecordsDispatcher(IStatement* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getAffectedRecords(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<ISC_UINT64>(0);
			}
		}

		static IMessageMetadata* CLOOP_CARG cloopgetInputMetadataDispatcher(IStatement* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getInputMetadata(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IMessageMetadata*>(0);
			}
		}

		static IMessageMetadata* CLOOP_CARG cloopgetOutputMetadataDispatcher(IStatement* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getOutputMetadata(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IMessageMetadata*>(0);
			}
		}

		static ITransaction* CLOOP_CARG cloopexecuteDispatcher(IStatement* self, IStatus* status, ITransaction* transaction, IMessageMetadata* inMetadata, void* inBuffer, IMessageMetadata* outMetadata, void* outBuffer) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::execute(&status2, transaction, inMetadata, inBuffer, outMetadata, outBuffer);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<ITransaction*>(0);
			}
		}

		static IResultSet* CLOOP_CARG cloopopenCursorDispatcher(IStatement* self, IStatus* status, ITransaction* transaction, IMessageMetadata* inMetadata, void* inBuffer, IMessageMetadata* outMetadata, unsigned flags) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::openCursor(&status2, transaction, inMetadata, inBuffer, outMetadata, flags);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IResultSet*>(0);
			}
		}

		static void CLOOP_CARG cloopsetCursorNameDispatcher(IStatement* self, IStatus* status, const char* name) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::setCursorName(&status2, name);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopfreeDispatcher(IStatement* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::free(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static unsigned CLOOP_CARG cloopgetFlagsDispatcher(IStatement* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getFlags(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<unsigned>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IReferenceCountedImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IStatement> > > > >
	class IStatementImpl : public IStatementBaseImpl<Name, StatusType, Base>
	{
	protected:
		IStatementImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IStatementImpl()
		{
		}

		virtual void getInfo(StatusType* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) = 0;
		virtual unsigned getType(StatusType* status) = 0;
		virtual const char* getPlan(StatusType* status, FB_BOOLEAN detailed) = 0;
		virtual ISC_UINT64 getAffectedRecords(StatusType* status) = 0;
		virtual IMessageMetadata* getInputMetadata(StatusType* status) = 0;
		virtual IMessageMetadata* getOutputMetadata(StatusType* status) = 0;
		virtual ITransaction* execute(StatusType* status, ITransaction* transaction, IMessageMetadata* inMetadata, void* inBuffer, IMessageMetadata* outMetadata, void* outBuffer) = 0;
		virtual IResultSet* openCursor(StatusType* status, ITransaction* transaction, IMessageMetadata* inMetadata, void* inBuffer, IMessageMetadata* outMetadata, unsigned flags) = 0;
		virtual void setCursorName(StatusType* status, const char* name) = 0;
		virtual void free(StatusType* status) = 0;
		virtual unsigned getFlags(StatusType* status) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IRequestBaseImpl : public Base
	{
	public:
		typedef IRequest Declaration;

		IRequestBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->receive = &Name::cloopreceiveDispatcher;
					this->send = &Name::cloopsendDispatcher;
					this->getInfo = &Name::cloopgetInfoDispatcher;
					this->start = &Name::cloopstartDispatcher;
					this->startAndSend = &Name::cloopstartAndSendDispatcher;
					this->unwind = &Name::cloopunwindDispatcher;
					this->free = &Name::cloopfreeDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopreceiveDispatcher(IRequest* self, IStatus* status, int level, unsigned msgType, unsigned length, unsigned char* message) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::receive(&status2, level, msgType, length, message);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopsendDispatcher(IRequest* self, IStatus* status, int level, unsigned msgType, unsigned length, const unsigned char* message) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::send(&status2, level, msgType, length, message);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopgetInfoDispatcher(IRequest* self, IStatus* status, int level, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::getInfo(&status2, level, itemsLength, items, bufferLength, buffer);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopstartDispatcher(IRequest* self, IStatus* status, ITransaction* tra, int level) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::start(&status2, tra, level);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopstartAndSendDispatcher(IRequest* self, IStatus* status, ITransaction* tra, int level, unsigned msgType, unsigned length, const unsigned char* message) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::startAndSend(&status2, tra, level, msgType, length, message);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopunwindDispatcher(IRequest* self, IStatus* status, int level) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::unwind(&status2, level);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopfreeDispatcher(IRequest* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::free(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IReferenceCountedImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IRequest> > > > >
	class IRequestImpl : public IRequestBaseImpl<Name, StatusType, Base>
	{
	protected:
		IRequestImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IRequestImpl()
		{
		}

		virtual void receive(StatusType* status, int level, unsigned msgType, unsigned length, unsigned char* message) = 0;
		virtual void send(StatusType* status, int level, unsigned msgType, unsigned length, const unsigned char* message) = 0;
		virtual void getInfo(StatusType* status, int level, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) = 0;
		virtual void start(StatusType* status, ITransaction* tra, int level) = 0;
		virtual void startAndSend(StatusType* status, ITransaction* tra, int level, unsigned msgType, unsigned length, const unsigned char* message) = 0;
		virtual void unwind(StatusType* status, int level) = 0;
		virtual void free(StatusType* status) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IEventsBaseImpl : public Base
	{
	public:
		typedef IEvents Declaration;

		IEventsBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->cancel = &Name::cloopcancelDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopcancelDispatcher(IEvents* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::cancel(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IReferenceCountedImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IEvents> > > > >
	class IEventsImpl : public IEventsBaseImpl<Name, StatusType, Base>
	{
	protected:
		IEventsImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IEventsImpl()
		{
		}

		virtual void cancel(StatusType* status) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IAttachmentBaseImpl : public Base
	{
	public:
		typedef IAttachment Declaration;

		IAttachmentBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->getInfo = &Name::cloopgetInfoDispatcher;
					this->startTransaction = &Name::cloopstartTransactionDispatcher;
					this->reconnectTransaction = &Name::cloopreconnectTransactionDispatcher;
					this->compileRequest = &Name::cloopcompileRequestDispatcher;
					this->transactRequest = &Name::clooptransactRequestDispatcher;
					this->createBlob = &Name::cloopcreateBlobDispatcher;
					this->openBlob = &Name::cloopopenBlobDispatcher;
					this->getSlice = &Name::cloopgetSliceDispatcher;
					this->putSlice = &Name::cloopputSliceDispatcher;
					this->executeDyn = &Name::cloopexecuteDynDispatcher;
					this->prepare = &Name::cloopprepareDispatcher;
					this->execute = &Name::cloopexecuteDispatcher;
					this->openCursor = &Name::cloopopenCursorDispatcher;
					this->queEvents = &Name::cloopqueEventsDispatcher;
					this->cancelOperation = &Name::cloopcancelOperationDispatcher;
					this->ping = &Name::clooppingDispatcher;
					this->detach = &Name::cloopdetachDispatcher;
					this->dropDatabase = &Name::cloopdropDatabaseDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopgetInfoDispatcher(IAttachment* self, IStatus* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::getInfo(&status2, itemsLength, items, bufferLength, buffer);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static ITransaction* CLOOP_CARG cloopstartTransactionDispatcher(IAttachment* self, IStatus* status, unsigned tpbLength, const unsigned char* tpb) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::startTransaction(&status2, tpbLength, tpb);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<ITransaction*>(0);
			}
		}

		static ITransaction* CLOOP_CARG cloopreconnectTransactionDispatcher(IAttachment* self, IStatus* status, unsigned length, const unsigned char* id) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::reconnectTransaction(&status2, length, id);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<ITransaction*>(0);
			}
		}

		static IRequest* CLOOP_CARG cloopcompileRequestDispatcher(IAttachment* self, IStatus* status, unsigned blrLength, const unsigned char* blr) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::compileRequest(&status2, blrLength, blr);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IRequest*>(0);
			}
		}

		static void CLOOP_CARG clooptransactRequestDispatcher(IAttachment* self, IStatus* status, ITransaction* transaction, unsigned blrLength, const unsigned char* blr, unsigned inMsgLength, const unsigned char* inMsg, unsigned outMsgLength, unsigned char* outMsg) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::transactRequest(&status2, transaction, blrLength, blr, inMsgLength, inMsg, outMsgLength, outMsg);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static IBlob* CLOOP_CARG cloopcreateBlobDispatcher(IAttachment* self, IStatus* status, ITransaction* transaction, ISC_QUAD* id, unsigned bpbLength, const unsigned char* bpb) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::createBlob(&status2, transaction, id, bpbLength, bpb);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IBlob*>(0);
			}
		}

		static IBlob* CLOOP_CARG cloopopenBlobDispatcher(IAttachment* self, IStatus* status, ITransaction* transaction, ISC_QUAD* id, unsigned bpbLength, const unsigned char* bpb) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::openBlob(&status2, transaction, id, bpbLength, bpb);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IBlob*>(0);
			}
		}

		static int CLOOP_CARG cloopgetSliceDispatcher(IAttachment* self, IStatus* status, ITransaction* transaction, ISC_QUAD* id, unsigned sdlLength, const unsigned char* sdl, unsigned paramLength, const unsigned char* param, int sliceLength, unsigned char* slice) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getSlice(&status2, transaction, id, sdlLength, sdl, paramLength, param, sliceLength, slice);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<int>(0);
			}
		}

		static void CLOOP_CARG cloopputSliceDispatcher(IAttachment* self, IStatus* status, ITransaction* transaction, ISC_QUAD* id, unsigned sdlLength, const unsigned char* sdl, unsigned paramLength, const unsigned char* param, int sliceLength, unsigned char* slice) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::putSlice(&status2, transaction, id, sdlLength, sdl, paramLength, param, sliceLength, slice);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopexecuteDynDispatcher(IAttachment* self, IStatus* status, ITransaction* transaction, unsigned length, const unsigned char* dyn) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::executeDyn(&status2, transaction, length, dyn);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static IStatement* CLOOP_CARG cloopprepareDispatcher(IAttachment* self, IStatus* status, ITransaction* tra, unsigned stmtLength, const char* sqlStmt, unsigned dialect, unsigned flags) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::prepare(&status2, tra, stmtLength, sqlStmt, dialect, flags);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IStatement*>(0);
			}
		}

		static ITransaction* CLOOP_CARG cloopexecuteDispatcher(IAttachment* self, IStatus* status, ITransaction* transaction, unsigned stmtLength, const char* sqlStmt, unsigned dialect, IMessageMetadata* inMetadata, void* inBuffer, IMessageMetadata* outMetadata, void* outBuffer) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::execute(&status2, transaction, stmtLength, sqlStmt, dialect, inMetadata, inBuffer, outMetadata, outBuffer);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<ITransaction*>(0);
			}
		}

		static IResultSet* CLOOP_CARG cloopopenCursorDispatcher(IAttachment* self, IStatus* status, ITransaction* transaction, unsigned stmtLength, const char* sqlStmt, unsigned dialect, IMessageMetadata* inMetadata, void* inBuffer, IMessageMetadata* outMetadata, const char* cursorName, unsigned cursorFlags) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::openCursor(&status2, transaction, stmtLength, sqlStmt, dialect, inMetadata, inBuffer, outMetadata, cursorName, cursorFlags);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IResultSet*>(0);
			}
		}

		static IEvents* CLOOP_CARG cloopqueEventsDispatcher(IAttachment* self, IStatus* status, IEventCallback* callback, unsigned length, const unsigned char* events) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::queEvents(&status2, callback, length, events);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IEvents*>(0);
			}
		}

		static void CLOOP_CARG cloopcancelOperationDispatcher(IAttachment* self, IStatus* status, int option) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::cancelOperation(&status2, option);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG clooppingDispatcher(IAttachment* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::ping(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopdetachDispatcher(IAttachment* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::detach(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopdropDatabaseDispatcher(IAttachment* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::dropDatabase(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IReferenceCountedImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IAttachment> > > > >
	class IAttachmentImpl : public IAttachmentBaseImpl<Name, StatusType, Base>
	{
	protected:
		IAttachmentImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IAttachmentImpl()
		{
		}

		virtual void getInfo(StatusType* status, unsigned itemsLength, const unsigned char* items, unsigned bufferLength, unsigned char* buffer) = 0;
		virtual ITransaction* startTransaction(StatusType* status, unsigned tpbLength, const unsigned char* tpb) = 0;
		virtual ITransaction* reconnectTransaction(StatusType* status, unsigned length, const unsigned char* id) = 0;
		virtual IRequest* compileRequest(StatusType* status, unsigned blrLength, const unsigned char* blr) = 0;
		virtual void transactRequest(StatusType* status, ITransaction* transaction, unsigned blrLength, const unsigned char* blr, unsigned inMsgLength, const unsigned char* inMsg, unsigned outMsgLength, unsigned char* outMsg) = 0;
		virtual IBlob* createBlob(StatusType* status, ITransaction* transaction, ISC_QUAD* id, unsigned bpbLength, const unsigned char* bpb) = 0;
		virtual IBlob* openBlob(StatusType* status, ITransaction* transaction, ISC_QUAD* id, unsigned bpbLength, const unsigned char* bpb) = 0;
		virtual int getSlice(StatusType* status, ITransaction* transaction, ISC_QUAD* id, unsigned sdlLength, const unsigned char* sdl, unsigned paramLength, const unsigned char* param, int sliceLength, unsigned char* slice) = 0;
		virtual void putSlice(StatusType* status, ITransaction* transaction, ISC_QUAD* id, unsigned sdlLength, const unsigned char* sdl, unsigned paramLength, const unsigned char* param, int sliceLength, unsigned char* slice) = 0;
		virtual void executeDyn(StatusType* status, ITransaction* transaction, unsigned length, const unsigned char* dyn) = 0;
		virtual IStatement* prepare(StatusType* status, ITransaction* tra, unsigned stmtLength, const char* sqlStmt, unsigned dialect, unsigned flags) = 0;
		virtual ITransaction* execute(StatusType* status, ITransaction* transaction, unsigned stmtLength, const char* sqlStmt, unsigned dialect, IMessageMetadata* inMetadata, void* inBuffer, IMessageMetadata* outMetadata, void* outBuffer) = 0;
		virtual IResultSet* openCursor(StatusType* status, ITransaction* transaction, unsigned stmtLength, const char* sqlStmt, unsigned dialect, IMessageMetadata* inMetadata, void* inBuffer, IMessageMetadata* outMetadata, const char* cursorName, unsigned cursorFlags) = 0;
		virtual IEvents* queEvents(StatusType* status, IEventCallback* callback, unsigned length, const unsigned char* events) = 0;
		virtual void cancelOperation(StatusType* status, int option) = 0;
		virtual void ping(StatusType* status) = 0;
		virtual void detach(StatusType* status) = 0;
		virtual void dropDatabase(StatusType* status) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IServiceBaseImpl : public Base
	{
	public:
		typedef IService Declaration;

		IServiceBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->detach = &Name::cloopdetachDispatcher;
					this->query = &Name::cloopqueryDispatcher;
					this->start = &Name::cloopstartDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopdetachDispatcher(IService* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::detach(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopqueryDispatcher(IService* self, IStatus* status, unsigned sendLength, const unsigned char* sendItems, unsigned receiveLength, const unsigned char* receiveItems, unsigned bufferLength, unsigned char* buffer) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::query(&status2, sendLength, sendItems, receiveLength, receiveItems, bufferLength, buffer);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopstartDispatcher(IService* self, IStatus* status, unsigned spbLength, const unsigned char* spb) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::start(&status2, spbLength, spb);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IReferenceCountedImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IService> > > > >
	class IServiceImpl : public IServiceBaseImpl<Name, StatusType, Base>
	{
	protected:
		IServiceImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IServiceImpl()
		{
		}

		virtual void detach(StatusType* status) = 0;
		virtual void query(StatusType* status, unsigned sendLength, const unsigned char* sendItems, unsigned receiveLength, const unsigned char* receiveItems, unsigned bufferLength, unsigned char* buffer) = 0;
		virtual void start(StatusType* status, unsigned spbLength, const unsigned char* spb) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IProviderBaseImpl : public Base
	{
	public:
		typedef IProvider Declaration;

		IProviderBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setOwner = &Name::cloopsetOwnerDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
					this->attachDatabase = &Name::cloopattachDatabaseDispatcher;
					this->createDatabase = &Name::cloopcreateDatabaseDispatcher;
					this->attachServiceManager = &Name::cloopattachServiceManagerDispatcher;
					this->shutdown = &Name::cloopshutdownDispatcher;
					this->setDbCryptCallback = &Name::cloopsetDbCryptCallbackDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static IAttachment* CLOOP_CARG cloopattachDatabaseDispatcher(IProvider* self, IStatus* status, const char* fileName, unsigned dpbLength, const unsigned char* dpb) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::attachDatabase(&status2, fileName, dpbLength, dpb);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IAttachment*>(0);
			}
		}

		static IAttachment* CLOOP_CARG cloopcreateDatabaseDispatcher(IProvider* self, IStatus* status, const char* fileName, unsigned dpbLength, const unsigned char* dpb) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::createDatabase(&status2, fileName, dpbLength, dpb);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IAttachment*>(0);
			}
		}

		static IService* CLOOP_CARG cloopattachServiceManagerDispatcher(IProvider* self, IStatus* status, const char* service, unsigned spbLength, const unsigned char* spb) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::attachServiceManager(&status2, service, spbLength, spb);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IService*>(0);
			}
		}

		static void CLOOP_CARG cloopshutdownDispatcher(IProvider* self, IStatus* status, unsigned timeout, const int reason) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::shutdown(&status2, timeout, reason);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopsetDbCryptCallbackDispatcher(IProvider* self, IStatus* status, ICryptKeyCallback* cryptCallback) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::setDbCryptCallback(&status2, cryptCallback);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopsetOwnerDispatcher(IPluginBase* self, IReferenceCounted* r) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setOwner(r);
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static IReferenceCounted* CLOOP_CARG cloopgetOwnerDispatcher(IPluginBase* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOwner();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<IReferenceCounted*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IPluginBaseImpl<Name, StatusType, Inherit<IReferenceCountedImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IProvider> > > > > > >
	class IProviderImpl : public IProviderBaseImpl<Name, StatusType, Base>
	{
	protected:
		IProviderImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IProviderImpl()
		{
		}

		virtual IAttachment* attachDatabase(StatusType* status, const char* fileName, unsigned dpbLength, const unsigned char* dpb) = 0;
		virtual IAttachment* createDatabase(StatusType* status, const char* fileName, unsigned dpbLength, const unsigned char* dpb) = 0;
		virtual IService* attachServiceManager(StatusType* status, const char* service, unsigned spbLength, const unsigned char* spb) = 0;
		virtual void shutdown(StatusType* status, unsigned timeout, const int reason) = 0;
		virtual void setDbCryptCallback(StatusType* status, ICryptKeyCallback* cryptCallback) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IDtcStartBaseImpl : public Base
	{
	public:
		typedef IDtcStart Declaration;

		IDtcStartBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->dispose = &Name::cloopdisposeDispatcher;
					this->addAttachment = &Name::cloopaddAttachmentDispatcher;
					this->addWithTpb = &Name::cloopaddWithTpbDispatcher;
					this->start = &Name::cloopstartDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopaddAttachmentDispatcher(IDtcStart* self, IStatus* status, IAttachment* att) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::addAttachment(&status2, att);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopaddWithTpbDispatcher(IDtcStart* self, IStatus* status, IAttachment* att, unsigned length, const unsigned char* tpb) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::addWithTpb(&status2, att, length, tpb);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static ITransaction* CLOOP_CARG cloopstartDispatcher(IDtcStart* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::start(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<ITransaction*>(0);
			}
		}

		static void CLOOP_CARG cloopdisposeDispatcher(IDisposable* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::dispose();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IDisposableImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IDtcStart> > > > >
	class IDtcStartImpl : public IDtcStartBaseImpl<Name, StatusType, Base>
	{
	protected:
		IDtcStartImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IDtcStartImpl()
		{
		}

		virtual void addAttachment(StatusType* status, IAttachment* att) = 0;
		virtual void addWithTpb(StatusType* status, IAttachment* att, unsigned length, const unsigned char* tpb) = 0;
		virtual ITransaction* start(StatusType* status) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IDtcBaseImpl : public Base
	{
	public:
		typedef IDtc Declaration;

		IDtcBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->join = &Name::cloopjoinDispatcher;
					this->startBuilder = &Name::cloopstartBuilderDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static ITransaction* CLOOP_CARG cloopjoinDispatcher(IDtc* self, IStatus* status, ITransaction* one, ITransaction* two) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::join(&status2, one, two);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<ITransaction*>(0);
			}
		}

		static IDtcStart* CLOOP_CARG cloopstartBuilderDispatcher(IDtc* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::startBuilder(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IDtcStart*>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<IDtc> > >
	class IDtcImpl : public IDtcBaseImpl<Name, StatusType, Base>
	{
	protected:
		IDtcImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IDtcImpl()
		{
		}

		virtual ITransaction* join(StatusType* status, ITransaction* one, ITransaction* two) = 0;
		virtual IDtcStart* startBuilder(StatusType* status) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IAuthBaseImpl : public Base
	{
	public:
		typedef IAuth Declaration;

		IAuthBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setOwner = &Name::cloopsetOwnerDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopsetOwnerDispatcher(IPluginBase* self, IReferenceCounted* r) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setOwner(r);
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static IReferenceCounted* CLOOP_CARG cloopgetOwnerDispatcher(IPluginBase* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOwner();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<IReferenceCounted*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IPluginBaseImpl<Name, StatusType, Inherit<IReferenceCountedImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IAuth> > > > > > >
	class IAuthImpl : public IAuthBaseImpl<Name, StatusType, Base>
	{
	protected:
		IAuthImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IAuthImpl()
		{
		}

	};

	template <typename Name, typename StatusType, typename Base>
	class IWriterBaseImpl : public Base
	{
	public:
		typedef IWriter Declaration;

		IWriterBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->reset = &Name::cloopresetDispatcher;
					this->add = &Name::cloopaddDispatcher;
					this->setType = &Name::cloopsetTypeDispatcher;
					this->setDb = &Name::cloopsetDbDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopresetDispatcher(IWriter* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::reset();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static void CLOOP_CARG cloopaddDispatcher(IWriter* self, IStatus* status, const char* name) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::add(&status2, name);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopsetTypeDispatcher(IWriter* self, IStatus* status, const char* value) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::setType(&status2, value);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopsetDbDispatcher(IWriter* self, IStatus* status, const char* value) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::setDb(&status2, value);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<IWriter> > >
	class IWriterImpl : public IWriterBaseImpl<Name, StatusType, Base>
	{
	protected:
		IWriterImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IWriterImpl()
		{
		}

		virtual void reset() = 0;
		virtual void add(StatusType* status, const char* name) = 0;
		virtual void setType(StatusType* status, const char* value) = 0;
		virtual void setDb(StatusType* status, const char* value) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IServerBlockBaseImpl : public Base
	{
	public:
		typedef IServerBlock Declaration;

		IServerBlockBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getLogin = &Name::cloopgetLoginDispatcher;
					this->getData = &Name::cloopgetDataDispatcher;
					this->putData = &Name::cloopputDataDispatcher;
					this->newKey = &Name::cloopnewKeyDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetLoginDispatcher(IServerBlock* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getLogin();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const unsigned char* CLOOP_CARG cloopgetDataDispatcher(IServerBlock* self, unsigned* length) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getData(length);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const unsigned char*>(0);
			}
		}

		static void CLOOP_CARG cloopputDataDispatcher(IServerBlock* self, IStatus* status, unsigned length, const void* data) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::putData(&status2, length, data);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static ICryptKey* CLOOP_CARG cloopnewKeyDispatcher(IServerBlock* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::newKey(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<ICryptKey*>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<IServerBlock> > >
	class IServerBlockImpl : public IServerBlockBaseImpl<Name, StatusType, Base>
	{
	protected:
		IServerBlockImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IServerBlockImpl()
		{
		}

		virtual const char* getLogin() = 0;
		virtual const unsigned char* getData(unsigned* length) = 0;
		virtual void putData(StatusType* status, unsigned length, const void* data) = 0;
		virtual ICryptKey* newKey(StatusType* status) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IClientBlockBaseImpl : public Base
	{
	public:
		typedef IClientBlock Declaration;

		IClientBlockBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->getLogin = &Name::cloopgetLoginDispatcher;
					this->getPassword = &Name::cloopgetPasswordDispatcher;
					this->getData = &Name::cloopgetDataDispatcher;
					this->putData = &Name::cloopputDataDispatcher;
					this->newKey = &Name::cloopnewKeyDispatcher;
					this->getAuthBlock = &Name::cloopgetAuthBlockDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetLoginDispatcher(IClientBlock* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getLogin();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetPasswordDispatcher(IClientBlock* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPassword();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const unsigned char* CLOOP_CARG cloopgetDataDispatcher(IClientBlock* self, unsigned* length) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getData(length);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const unsigned char*>(0);
			}
		}

		static void CLOOP_CARG cloopputDataDispatcher(IClientBlock* self, IStatus* status, unsigned length, const void* data) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::putData(&status2, length, data);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static ICryptKey* CLOOP_CARG cloopnewKeyDispatcher(IClientBlock* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::newKey(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<ICryptKey*>(0);
			}
		}

		static IAuthBlock* CLOOP_CARG cloopgetAuthBlockDispatcher(IClientBlock* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getAuthBlock(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IAuthBlock*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IReferenceCountedImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IClientBlock> > > > >
	class IClientBlockImpl : public IClientBlockBaseImpl<Name, StatusType, Base>
	{
	protected:
		IClientBlockImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IClientBlockImpl()
		{
		}

		virtual const char* getLogin() = 0;
		virtual const char* getPassword() = 0;
		virtual const unsigned char* getData(unsigned* length) = 0;
		virtual void putData(StatusType* status, unsigned length, const void* data) = 0;
		virtual ICryptKey* newKey(StatusType* status) = 0;
		virtual IAuthBlock* getAuthBlock(StatusType* status) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IServerBaseImpl : public Base
	{
	public:
		typedef IServer Declaration;

		IServerBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setOwner = &Name::cloopsetOwnerDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
					this->authenticate = &Name::cloopauthenticateDispatcher;
					this->setDbCryptCallback = &Name::cloopsetDbCryptCallbackDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static int CLOOP_CARG cloopauthenticateDispatcher(IServer* self, IStatus* status, IServerBlock* sBlock, IWriter* writerInterface) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::authenticate(&status2, sBlock, writerInterface);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<int>(0);
			}
		}

		static void CLOOP_CARG cloopsetDbCryptCallbackDispatcher(IServer* self, IStatus* status, ICryptKeyCallback* cryptCallback) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::setDbCryptCallback(&status2, cryptCallback);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopsetOwnerDispatcher(IPluginBase* self, IReferenceCounted* r) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setOwner(r);
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static IReferenceCounted* CLOOP_CARG cloopgetOwnerDispatcher(IPluginBase* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOwner();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<IReferenceCounted*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IAuthImpl<Name, StatusType, Inherit<IPluginBaseImpl<Name, StatusType, Inherit<IReferenceCountedImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IServer> > > > > > > > >
	class IServerImpl : public IServerBaseImpl<Name, StatusType, Base>
	{
	protected:
		IServerImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IServerImpl()
		{
		}

		virtual int authenticate(StatusType* status, IServerBlock* sBlock, IWriter* writerInterface) = 0;
		virtual void setDbCryptCallback(StatusType* status, ICryptKeyCallback* cryptCallback) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IClientBaseImpl : public Base
	{
	public:
		typedef IClient Declaration;

		IClientBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setOwner = &Name::cloopsetOwnerDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
					this->authenticate = &Name::cloopauthenticateDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static int CLOOP_CARG cloopauthenticateDispatcher(IClient* self, IStatus* status, IClientBlock* cBlock) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::authenticate(&status2, cBlock);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<int>(0);
			}
		}

		static void CLOOP_CARG cloopsetOwnerDispatcher(IPluginBase* self, IReferenceCounted* r) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setOwner(r);
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static IReferenceCounted* CLOOP_CARG cloopgetOwnerDispatcher(IPluginBase* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOwner();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<IReferenceCounted*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IAuthImpl<Name, StatusType, Inherit<IPluginBaseImpl<Name, StatusType, Inherit<IReferenceCountedImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IClient> > > > > > > > >
	class IClientImpl : public IClientBaseImpl<Name, StatusType, Base>
	{
	protected:
		IClientImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IClientImpl()
		{
		}

		virtual int authenticate(StatusType* status, IClientBlock* cBlock) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IUserFieldBaseImpl : public Base
	{
	public:
		typedef IUserField Declaration;

		IUserFieldBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->entered = &Name::cloopenteredDispatcher;
					this->specified = &Name::cloopspecifiedDispatcher;
					this->setEntered = &Name::cloopsetEnteredDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static int CLOOP_CARG cloopenteredDispatcher(IUserField* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::entered();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}

		static int CLOOP_CARG cloopspecifiedDispatcher(IUserField* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::specified();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}

		static void CLOOP_CARG cloopsetEnteredDispatcher(IUserField* self, IStatus* status, int newValue) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::setEntered(&status2, newValue);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<IUserField> > >
	class IUserFieldImpl : public IUserFieldBaseImpl<Name, StatusType, Base>
	{
	protected:
		IUserFieldImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IUserFieldImpl()
		{
		}

		virtual int entered() = 0;
		virtual int specified() = 0;
		virtual void setEntered(StatusType* status, int newValue) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class ICharUserFieldBaseImpl : public Base
	{
	public:
		typedef ICharUserField Declaration;

		ICharUserFieldBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->entered = &Name::cloopenteredDispatcher;
					this->specified = &Name::cloopspecifiedDispatcher;
					this->setEntered = &Name::cloopsetEnteredDispatcher;
					this->get = &Name::cloopgetDispatcher;
					this->set = &Name::cloopsetDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetDispatcher(ICharUserField* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::get();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static void CLOOP_CARG cloopsetDispatcher(ICharUserField* self, IStatus* status, const char* newValue) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::set(&status2, newValue);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static int CLOOP_CARG cloopenteredDispatcher(IUserField* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::entered();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}

		static int CLOOP_CARG cloopspecifiedDispatcher(IUserField* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::specified();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}

		static void CLOOP_CARG cloopsetEnteredDispatcher(IUserField* self, IStatus* status, int newValue) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::setEntered(&status2, newValue);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IUserFieldImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<ICharUserField> > > > >
	class ICharUserFieldImpl : public ICharUserFieldBaseImpl<Name, StatusType, Base>
	{
	protected:
		ICharUserFieldImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ICharUserFieldImpl()
		{
		}

		virtual const char* get() = 0;
		virtual void set(StatusType* status, const char* newValue) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IIntUserFieldBaseImpl : public Base
	{
	public:
		typedef IIntUserField Declaration;

		IIntUserFieldBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->entered = &Name::cloopenteredDispatcher;
					this->specified = &Name::cloopspecifiedDispatcher;
					this->setEntered = &Name::cloopsetEnteredDispatcher;
					this->get = &Name::cloopgetDispatcher;
					this->set = &Name::cloopsetDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static int CLOOP_CARG cloopgetDispatcher(IIntUserField* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::get();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}

		static void CLOOP_CARG cloopsetDispatcher(IIntUserField* self, IStatus* status, int newValue) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::set(&status2, newValue);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static int CLOOP_CARG cloopenteredDispatcher(IUserField* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::entered();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}

		static int CLOOP_CARG cloopspecifiedDispatcher(IUserField* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::specified();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}

		static void CLOOP_CARG cloopsetEnteredDispatcher(IUserField* self, IStatus* status, int newValue) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::setEntered(&status2, newValue);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IUserFieldImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IIntUserField> > > > >
	class IIntUserFieldImpl : public IIntUserFieldBaseImpl<Name, StatusType, Base>
	{
	protected:
		IIntUserFieldImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IIntUserFieldImpl()
		{
		}

		virtual int get() = 0;
		virtual void set(StatusType* status, int newValue) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IUserBaseImpl : public Base
	{
	public:
		typedef IUser Declaration;

		IUserBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->operation = &Name::cloopoperationDispatcher;
					this->userName = &Name::cloopuserNameDispatcher;
					this->password = &Name::clooppasswordDispatcher;
					this->firstName = &Name::cloopfirstNameDispatcher;
					this->lastName = &Name::clooplastNameDispatcher;
					this->middleName = &Name::cloopmiddleNameDispatcher;
					this->comment = &Name::cloopcommentDispatcher;
					this->attributes = &Name::cloopattributesDispatcher;
					this->active = &Name::cloopactiveDispatcher;
					this->admin = &Name::cloopadminDispatcher;
					this->clear = &Name::cloopclearDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static unsigned CLOOP_CARG cloopoperationDispatcher(IUser* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::operation();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static ICharUserField* CLOOP_CARG cloopuserNameDispatcher(IUser* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::userName();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<ICharUserField*>(0);
			}
		}

		static ICharUserField* CLOOP_CARG clooppasswordDispatcher(IUser* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::password();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<ICharUserField*>(0);
			}
		}

		static ICharUserField* CLOOP_CARG cloopfirstNameDispatcher(IUser* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::firstName();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<ICharUserField*>(0);
			}
		}

		static ICharUserField* CLOOP_CARG clooplastNameDispatcher(IUser* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::lastName();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<ICharUserField*>(0);
			}
		}

		static ICharUserField* CLOOP_CARG cloopmiddleNameDispatcher(IUser* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::middleName();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<ICharUserField*>(0);
			}
		}

		static ICharUserField* CLOOP_CARG cloopcommentDispatcher(IUser* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::comment();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<ICharUserField*>(0);
			}
		}

		static ICharUserField* CLOOP_CARG cloopattributesDispatcher(IUser* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::attributes();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<ICharUserField*>(0);
			}
		}

		static IIntUserField* CLOOP_CARG cloopactiveDispatcher(IUser* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::active();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<IIntUserField*>(0);
			}
		}

		static IIntUserField* CLOOP_CARG cloopadminDispatcher(IUser* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::admin();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<IIntUserField*>(0);
			}
		}

		static void CLOOP_CARG cloopclearDispatcher(IUser* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::clear(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<IUser> > >
	class IUserImpl : public IUserBaseImpl<Name, StatusType, Base>
	{
	protected:
		IUserImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IUserImpl()
		{
		}

		virtual unsigned operation() = 0;
		virtual ICharUserField* userName() = 0;
		virtual ICharUserField* password() = 0;
		virtual ICharUserField* firstName() = 0;
		virtual ICharUserField* lastName() = 0;
		virtual ICharUserField* middleName() = 0;
		virtual ICharUserField* comment() = 0;
		virtual ICharUserField* attributes() = 0;
		virtual IIntUserField* active() = 0;
		virtual IIntUserField* admin() = 0;
		virtual void clear(StatusType* status) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IListUsersBaseImpl : public Base
	{
	public:
		typedef IListUsers Declaration;

		IListUsersBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->list = &Name::clooplistDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG clooplistDispatcher(IListUsers* self, IStatus* status, IUser* user) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::list(&status2, user);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<IListUsers> > >
	class IListUsersImpl : public IListUsersBaseImpl<Name, StatusType, Base>
	{
	protected:
		IListUsersImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IListUsersImpl()
		{
		}

		virtual void list(StatusType* status, IUser* user) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class ILogonInfoBaseImpl : public Base
	{
	public:
		typedef ILogonInfo Declaration;

		ILogonInfoBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->name = &Name::cloopnameDispatcher;
					this->role = &Name::clooproleDispatcher;
					this->networkProtocol = &Name::cloopnetworkProtocolDispatcher;
					this->remoteAddress = &Name::cloopremoteAddressDispatcher;
					this->authBlock = &Name::cloopauthBlockDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopnameDispatcher(ILogonInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::name();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG clooproleDispatcher(ILogonInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::role();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopnetworkProtocolDispatcher(ILogonInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::networkProtocol();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopremoteAddressDispatcher(ILogonInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::remoteAddress();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const unsigned char* CLOOP_CARG cloopauthBlockDispatcher(ILogonInfo* self, unsigned* length) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::authBlock(length);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const unsigned char*>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<ILogonInfo> > >
	class ILogonInfoImpl : public ILogonInfoBaseImpl<Name, StatusType, Base>
	{
	protected:
		ILogonInfoImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ILogonInfoImpl()
		{
		}

		virtual const char* name() = 0;
		virtual const char* role() = 0;
		virtual const char* networkProtocol() = 0;
		virtual const char* remoteAddress() = 0;
		virtual const unsigned char* authBlock(unsigned* length) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IManagementBaseImpl : public Base
	{
	public:
		typedef IManagement Declaration;

		IManagementBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setOwner = &Name::cloopsetOwnerDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
					this->start = &Name::cloopstartDispatcher;
					this->execute = &Name::cloopexecuteDispatcher;
					this->commit = &Name::cloopcommitDispatcher;
					this->rollback = &Name::clooprollbackDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopstartDispatcher(IManagement* self, IStatus* status, ILogonInfo* logonInfo) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::start(&status2, logonInfo);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static int CLOOP_CARG cloopexecuteDispatcher(IManagement* self, IStatus* status, IUser* user, IListUsers* callback) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::execute(&status2, user, callback);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<int>(0);
			}
		}

		static void CLOOP_CARG cloopcommitDispatcher(IManagement* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::commit(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG clooprollbackDispatcher(IManagement* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::rollback(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopsetOwnerDispatcher(IPluginBase* self, IReferenceCounted* r) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setOwner(r);
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static IReferenceCounted* CLOOP_CARG cloopgetOwnerDispatcher(IPluginBase* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOwner();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<IReferenceCounted*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IPluginBaseImpl<Name, StatusType, Inherit<IReferenceCountedImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IManagement> > > > > > >
	class IManagementImpl : public IManagementBaseImpl<Name, StatusType, Base>
	{
	protected:
		IManagementImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IManagementImpl()
		{
		}

		virtual void start(StatusType* status, ILogonInfo* logonInfo) = 0;
		virtual int execute(StatusType* status, IUser* user, IListUsers* callback) = 0;
		virtual void commit(StatusType* status) = 0;
		virtual void rollback(StatusType* status) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IAuthBlockBaseImpl : public Base
	{
	public:
		typedef IAuthBlock Declaration;

		IAuthBlockBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getType = &Name::cloopgetTypeDispatcher;
					this->getName = &Name::cloopgetNameDispatcher;
					this->getPlugin = &Name::cloopgetPluginDispatcher;
					this->getSecurityDb = &Name::cloopgetSecurityDbDispatcher;
					this->getOriginalPlugin = &Name::cloopgetOriginalPluginDispatcher;
					this->next = &Name::cloopnextDispatcher;
					this->first = &Name::cloopfirstDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetTypeDispatcher(IAuthBlock* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getType();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetNameDispatcher(IAuthBlock* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getName();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetPluginDispatcher(IAuthBlock* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPlugin();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetSecurityDbDispatcher(IAuthBlock* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getSecurityDb();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetOriginalPluginDispatcher(IAuthBlock* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOriginalPlugin();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG cloopnextDispatcher(IAuthBlock* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::next(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG cloopfirstDispatcher(IAuthBlock* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::first(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<FB_BOOLEAN>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<IAuthBlock> > >
	class IAuthBlockImpl : public IAuthBlockBaseImpl<Name, StatusType, Base>
	{
	protected:
		IAuthBlockImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IAuthBlockImpl()
		{
		}

		virtual const char* getType() = 0;
		virtual const char* getName() = 0;
		virtual const char* getPlugin() = 0;
		virtual const char* getSecurityDb() = 0;
		virtual const char* getOriginalPlugin() = 0;
		virtual FB_BOOLEAN next(StatusType* status) = 0;
		virtual FB_BOOLEAN first(StatusType* status) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IWireCryptPluginBaseImpl : public Base
	{
	public:
		typedef IWireCryptPlugin Declaration;

		IWireCryptPluginBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setOwner = &Name::cloopsetOwnerDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
					this->getKnownTypes = &Name::cloopgetKnownTypesDispatcher;
					this->setKey = &Name::cloopsetKeyDispatcher;
					this->encrypt = &Name::cloopencryptDispatcher;
					this->decrypt = &Name::cloopdecryptDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetKnownTypesDispatcher(IWireCryptPlugin* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getKnownTypes(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<const char*>(0);
			}
		}

		static void CLOOP_CARG cloopsetKeyDispatcher(IWireCryptPlugin* self, IStatus* status, ICryptKey* key) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::setKey(&status2, key);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopencryptDispatcher(IWireCryptPlugin* self, IStatus* status, unsigned length, const void* from, void* to) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::encrypt(&status2, length, from, to);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopdecryptDispatcher(IWireCryptPlugin* self, IStatus* status, unsigned length, const void* from, void* to) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::decrypt(&status2, length, from, to);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopsetOwnerDispatcher(IPluginBase* self, IReferenceCounted* r) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setOwner(r);
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static IReferenceCounted* CLOOP_CARG cloopgetOwnerDispatcher(IPluginBase* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOwner();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<IReferenceCounted*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IPluginBaseImpl<Name, StatusType, Inherit<IReferenceCountedImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IWireCryptPlugin> > > > > > >
	class IWireCryptPluginImpl : public IWireCryptPluginBaseImpl<Name, StatusType, Base>
	{
	protected:
		IWireCryptPluginImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IWireCryptPluginImpl()
		{
		}

		virtual const char* getKnownTypes(StatusType* status) = 0;
		virtual void setKey(StatusType* status, ICryptKey* key) = 0;
		virtual void encrypt(StatusType* status, unsigned length, const void* from, void* to) = 0;
		virtual void decrypt(StatusType* status, unsigned length, const void* from, void* to) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class ICryptKeyCallbackBaseImpl : public Base
	{
	public:
		typedef ICryptKeyCallback Declaration;

		ICryptKeyCallbackBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->callback = &Name::cloopcallbackDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static unsigned CLOOP_CARG cloopcallbackDispatcher(ICryptKeyCallback* self, unsigned dataLength, const void* data, unsigned bufferLength, void* buffer) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::callback(dataLength, data, bufferLength, buffer);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<unsigned>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<ICryptKeyCallback> > >
	class ICryptKeyCallbackImpl : public ICryptKeyCallbackBaseImpl<Name, StatusType, Base>
	{
	protected:
		ICryptKeyCallbackImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ICryptKeyCallbackImpl()
		{
		}

		virtual unsigned callback(unsigned dataLength, const void* data, unsigned bufferLength, void* buffer) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IKeyHolderPluginBaseImpl : public Base
	{
	public:
		typedef IKeyHolderPlugin Declaration;

		IKeyHolderPluginBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setOwner = &Name::cloopsetOwnerDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
					this->keyCallback = &Name::cloopkeyCallbackDispatcher;
					this->keyHandle = &Name::cloopkeyHandleDispatcher;
					this->useOnlyOwnKeys = &Name::cloopuseOnlyOwnKeysDispatcher;
					this->chainHandle = &Name::cloopchainHandleDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static int CLOOP_CARG cloopkeyCallbackDispatcher(IKeyHolderPlugin* self, IStatus* status, ICryptKeyCallback* callback) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::keyCallback(&status2, callback);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<int>(0);
			}
		}

		static ICryptKeyCallback* CLOOP_CARG cloopkeyHandleDispatcher(IKeyHolderPlugin* self, IStatus* status, const char* keyName) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::keyHandle(&status2, keyName);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<ICryptKeyCallback*>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG cloopuseOnlyOwnKeysDispatcher(IKeyHolderPlugin* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::useOnlyOwnKeys(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static ICryptKeyCallback* CLOOP_CARG cloopchainHandleDispatcher(IKeyHolderPlugin* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::chainHandle(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<ICryptKeyCallback*>(0);
			}
		}

		static void CLOOP_CARG cloopsetOwnerDispatcher(IPluginBase* self, IReferenceCounted* r) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setOwner(r);
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static IReferenceCounted* CLOOP_CARG cloopgetOwnerDispatcher(IPluginBase* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOwner();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<IReferenceCounted*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IPluginBaseImpl<Name, StatusType, Inherit<IReferenceCountedImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IKeyHolderPlugin> > > > > > >
	class IKeyHolderPluginImpl : public IKeyHolderPluginBaseImpl<Name, StatusType, Base>
	{
	protected:
		IKeyHolderPluginImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IKeyHolderPluginImpl()
		{
		}

		virtual int keyCallback(StatusType* status, ICryptKeyCallback* callback) = 0;
		virtual ICryptKeyCallback* keyHandle(StatusType* status, const char* keyName) = 0;
		virtual FB_BOOLEAN useOnlyOwnKeys(StatusType* status) = 0;
		virtual ICryptKeyCallback* chainHandle(StatusType* status) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IDbCryptInfoBaseImpl : public Base
	{
	public:
		typedef IDbCryptInfo Declaration;

		IDbCryptInfoBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->getDatabaseFullPath = &Name::cloopgetDatabaseFullPathDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetDatabaseFullPathDispatcher(IDbCryptInfo* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getDatabaseFullPath(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<const char*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IReferenceCountedImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IDbCryptInfo> > > > >
	class IDbCryptInfoImpl : public IDbCryptInfoBaseImpl<Name, StatusType, Base>
	{
	protected:
		IDbCryptInfoImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IDbCryptInfoImpl()
		{
		}

		virtual const char* getDatabaseFullPath(StatusType* status) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IDbCryptPluginBaseImpl : public Base
	{
	public:
		typedef IDbCryptPlugin Declaration;

		IDbCryptPluginBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setOwner = &Name::cloopsetOwnerDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
					this->setKey = &Name::cloopsetKeyDispatcher;
					this->encrypt = &Name::cloopencryptDispatcher;
					this->decrypt = &Name::cloopdecryptDispatcher;
					this->setInfo = &Name::cloopsetInfoDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopsetKeyDispatcher(IDbCryptPlugin* self, IStatus* status, unsigned length, IKeyHolderPlugin** sources, const char* keyName) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::setKey(&status2, length, sources, keyName);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopencryptDispatcher(IDbCryptPlugin* self, IStatus* status, unsigned length, const void* from, void* to) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::encrypt(&status2, length, from, to);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopdecryptDispatcher(IDbCryptPlugin* self, IStatus* status, unsigned length, const void* from, void* to) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::decrypt(&status2, length, from, to);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopsetInfoDispatcher(IDbCryptPlugin* self, IStatus* status, IDbCryptInfo* info) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::setInfo(&status2, info);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopsetOwnerDispatcher(IPluginBase* self, IReferenceCounted* r) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setOwner(r);
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static IReferenceCounted* CLOOP_CARG cloopgetOwnerDispatcher(IPluginBase* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOwner();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<IReferenceCounted*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IPluginBaseImpl<Name, StatusType, Inherit<IReferenceCountedImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IDbCryptPlugin> > > > > > >
	class IDbCryptPluginImpl : public IDbCryptPluginBaseImpl<Name, StatusType, Base>
	{
	protected:
		IDbCryptPluginImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IDbCryptPluginImpl()
		{
		}

		virtual void setKey(StatusType* status, unsigned length, IKeyHolderPlugin** sources, const char* keyName) = 0;
		virtual void encrypt(StatusType* status, unsigned length, const void* from, void* to) = 0;
		virtual void decrypt(StatusType* status, unsigned length, const void* from, void* to) = 0;
		virtual void setInfo(StatusType* status, IDbCryptInfo* info) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IExternalContextBaseImpl : public Base
	{
	public:
		typedef IExternalContext Declaration;

		IExternalContextBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getMaster = &Name::cloopgetMasterDispatcher;
					this->getEngine = &Name::cloopgetEngineDispatcher;
					this->getAttachment = &Name::cloopgetAttachmentDispatcher;
					this->getTransaction = &Name::cloopgetTransactionDispatcher;
					this->getUserName = &Name::cloopgetUserNameDispatcher;
					this->getDatabaseName = &Name::cloopgetDatabaseNameDispatcher;
					this->getClientCharSet = &Name::cloopgetClientCharSetDispatcher;
					this->obtainInfoCode = &Name::cloopobtainInfoCodeDispatcher;
					this->getInfo = &Name::cloopgetInfoDispatcher;
					this->setInfo = &Name::cloopsetInfoDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static IMaster* CLOOP_CARG cloopgetMasterDispatcher(IExternalContext* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getMaster();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<IMaster*>(0);
			}
		}

		static IExternalEngine* CLOOP_CARG cloopgetEngineDispatcher(IExternalContext* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getEngine(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IExternalEngine*>(0);
			}
		}

		static IAttachment* CLOOP_CARG cloopgetAttachmentDispatcher(IExternalContext* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getAttachment(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IAttachment*>(0);
			}
		}

		static ITransaction* CLOOP_CARG cloopgetTransactionDispatcher(IExternalContext* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getTransaction(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<ITransaction*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetUserNameDispatcher(IExternalContext* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getUserName();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetDatabaseNameDispatcher(IExternalContext* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getDatabaseName();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetClientCharSetDispatcher(IExternalContext* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getClientCharSet();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static int CLOOP_CARG cloopobtainInfoCodeDispatcher(IExternalContext* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::obtainInfoCode();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}

		static void* CLOOP_CARG cloopgetInfoDispatcher(IExternalContext* self, int code) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getInfo(code);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<void*>(0);
			}
		}

		static void* CLOOP_CARG cloopsetInfoDispatcher(IExternalContext* self, int code, void* value) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::setInfo(code, value);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<void*>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<IExternalContext> > >
	class IExternalContextImpl : public IExternalContextBaseImpl<Name, StatusType, Base>
	{
	protected:
		IExternalContextImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IExternalContextImpl()
		{
		}

		virtual IMaster* getMaster() = 0;
		virtual IExternalEngine* getEngine(StatusType* status) = 0;
		virtual IAttachment* getAttachment(StatusType* status) = 0;
		virtual ITransaction* getTransaction(StatusType* status) = 0;
		virtual const char* getUserName() = 0;
		virtual const char* getDatabaseName() = 0;
		virtual const char* getClientCharSet() = 0;
		virtual int obtainInfoCode() = 0;
		virtual void* getInfo(int code) = 0;
		virtual void* setInfo(int code, void* value) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IExternalResultSetBaseImpl : public Base
	{
	public:
		typedef IExternalResultSet Declaration;

		IExternalResultSetBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->dispose = &Name::cloopdisposeDispatcher;
					this->fetch = &Name::cloopfetchDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static FB_BOOLEAN CLOOP_CARG cloopfetchDispatcher(IExternalResultSet* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::fetch(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static void CLOOP_CARG cloopdisposeDispatcher(IDisposable* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::dispose();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IDisposableImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IExternalResultSet> > > > >
	class IExternalResultSetImpl : public IExternalResultSetBaseImpl<Name, StatusType, Base>
	{
	protected:
		IExternalResultSetImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IExternalResultSetImpl()
		{
		}

		virtual FB_BOOLEAN fetch(StatusType* status) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IExternalFunctionBaseImpl : public Base
	{
	public:
		typedef IExternalFunction Declaration;

		IExternalFunctionBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->dispose = &Name::cloopdisposeDispatcher;
					this->getCharSet = &Name::cloopgetCharSetDispatcher;
					this->execute = &Name::cloopexecuteDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopgetCharSetDispatcher(IExternalFunction* self, IStatus* status, IExternalContext* context, char* name, unsigned nameSize) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::getCharSet(&status2, context, name, nameSize);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopexecuteDispatcher(IExternalFunction* self, IStatus* status, IExternalContext* context, void* inMsg, void* outMsg) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::execute(&status2, context, inMsg, outMsg);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopdisposeDispatcher(IDisposable* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::dispose();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IDisposableImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IExternalFunction> > > > >
	class IExternalFunctionImpl : public IExternalFunctionBaseImpl<Name, StatusType, Base>
	{
	protected:
		IExternalFunctionImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IExternalFunctionImpl()
		{
		}

		virtual void getCharSet(StatusType* status, IExternalContext* context, char* name, unsigned nameSize) = 0;
		virtual void execute(StatusType* status, IExternalContext* context, void* inMsg, void* outMsg) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IExternalProcedureBaseImpl : public Base
	{
	public:
		typedef IExternalProcedure Declaration;

		IExternalProcedureBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->dispose = &Name::cloopdisposeDispatcher;
					this->getCharSet = &Name::cloopgetCharSetDispatcher;
					this->open = &Name::cloopopenDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopgetCharSetDispatcher(IExternalProcedure* self, IStatus* status, IExternalContext* context, char* name, unsigned nameSize) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::getCharSet(&status2, context, name, nameSize);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static IExternalResultSet* CLOOP_CARG cloopopenDispatcher(IExternalProcedure* self, IStatus* status, IExternalContext* context, void* inMsg, void* outMsg) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::open(&status2, context, inMsg, outMsg);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IExternalResultSet*>(0);
			}
		}

		static void CLOOP_CARG cloopdisposeDispatcher(IDisposable* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::dispose();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IDisposableImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IExternalProcedure> > > > >
	class IExternalProcedureImpl : public IExternalProcedureBaseImpl<Name, StatusType, Base>
	{
	protected:
		IExternalProcedureImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IExternalProcedureImpl()
		{
		}

		virtual void getCharSet(StatusType* status, IExternalContext* context, char* name, unsigned nameSize) = 0;
		virtual IExternalResultSet* open(StatusType* status, IExternalContext* context, void* inMsg, void* outMsg) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IExternalTriggerBaseImpl : public Base
	{
	public:
		typedef IExternalTrigger Declaration;

		IExternalTriggerBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->dispose = &Name::cloopdisposeDispatcher;
					this->getCharSet = &Name::cloopgetCharSetDispatcher;
					this->execute = &Name::cloopexecuteDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopgetCharSetDispatcher(IExternalTrigger* self, IStatus* status, IExternalContext* context, char* name, unsigned nameSize) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::getCharSet(&status2, context, name, nameSize);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopexecuteDispatcher(IExternalTrigger* self, IStatus* status, IExternalContext* context, unsigned action, void* oldMsg, void* newMsg) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::execute(&status2, context, action, oldMsg, newMsg);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopdisposeDispatcher(IDisposable* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::dispose();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IDisposableImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IExternalTrigger> > > > >
	class IExternalTriggerImpl : public IExternalTriggerBaseImpl<Name, StatusType, Base>
	{
	protected:
		IExternalTriggerImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IExternalTriggerImpl()
		{
		}

		virtual void getCharSet(StatusType* status, IExternalContext* context, char* name, unsigned nameSize) = 0;
		virtual void execute(StatusType* status, IExternalContext* context, unsigned action, void* oldMsg, void* newMsg) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IRoutineMetadataBaseImpl : public Base
	{
	public:
		typedef IRoutineMetadata Declaration;

		IRoutineMetadataBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getPackage = &Name::cloopgetPackageDispatcher;
					this->getName = &Name::cloopgetNameDispatcher;
					this->getEntryPoint = &Name::cloopgetEntryPointDispatcher;
					this->getBody = &Name::cloopgetBodyDispatcher;
					this->getInputMetadata = &Name::cloopgetInputMetadataDispatcher;
					this->getOutputMetadata = &Name::cloopgetOutputMetadataDispatcher;
					this->getTriggerMetadata = &Name::cloopgetTriggerMetadataDispatcher;
					this->getTriggerTable = &Name::cloopgetTriggerTableDispatcher;
					this->getTriggerType = &Name::cloopgetTriggerTypeDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetPackageDispatcher(const IRoutineMetadata* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<const Name*>(self)->Name::getPackage(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetNameDispatcher(const IRoutineMetadata* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<const Name*>(self)->Name::getName(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetEntryPointDispatcher(const IRoutineMetadata* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<const Name*>(self)->Name::getEntryPoint(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetBodyDispatcher(const IRoutineMetadata* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<const Name*>(self)->Name::getBody(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<const char*>(0);
			}
		}

		static IMessageMetadata* CLOOP_CARG cloopgetInputMetadataDispatcher(const IRoutineMetadata* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<const Name*>(self)->Name::getInputMetadata(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IMessageMetadata*>(0);
			}
		}

		static IMessageMetadata* CLOOP_CARG cloopgetOutputMetadataDispatcher(const IRoutineMetadata* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<const Name*>(self)->Name::getOutputMetadata(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IMessageMetadata*>(0);
			}
		}

		static IMessageMetadata* CLOOP_CARG cloopgetTriggerMetadataDispatcher(const IRoutineMetadata* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<const Name*>(self)->Name::getTriggerMetadata(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IMessageMetadata*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetTriggerTableDispatcher(const IRoutineMetadata* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<const Name*>(self)->Name::getTriggerTable(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<const char*>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetTriggerTypeDispatcher(const IRoutineMetadata* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<const Name*>(self)->Name::getTriggerType(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<unsigned>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<IRoutineMetadata> > >
	class IRoutineMetadataImpl : public IRoutineMetadataBaseImpl<Name, StatusType, Base>
	{
	protected:
		IRoutineMetadataImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IRoutineMetadataImpl()
		{
		}

		virtual const char* getPackage(StatusType* status) const = 0;
		virtual const char* getName(StatusType* status) const = 0;
		virtual const char* getEntryPoint(StatusType* status) const = 0;
		virtual const char* getBody(StatusType* status) const = 0;
		virtual IMessageMetadata* getInputMetadata(StatusType* status) const = 0;
		virtual IMessageMetadata* getOutputMetadata(StatusType* status) const = 0;
		virtual IMessageMetadata* getTriggerMetadata(StatusType* status) const = 0;
		virtual const char* getTriggerTable(StatusType* status) const = 0;
		virtual unsigned getTriggerType(StatusType* status) const = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IExternalEngineBaseImpl : public Base
	{
	public:
		typedef IExternalEngine Declaration;

		IExternalEngineBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setOwner = &Name::cloopsetOwnerDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
					this->open = &Name::cloopopenDispatcher;
					this->openAttachment = &Name::cloopopenAttachmentDispatcher;
					this->closeAttachment = &Name::cloopcloseAttachmentDispatcher;
					this->makeFunction = &Name::cloopmakeFunctionDispatcher;
					this->makeProcedure = &Name::cloopmakeProcedureDispatcher;
					this->makeTrigger = &Name::cloopmakeTriggerDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopopenDispatcher(IExternalEngine* self, IStatus* status, IExternalContext* context, char* charSet, unsigned charSetSize) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::open(&status2, context, charSet, charSetSize);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopopenAttachmentDispatcher(IExternalEngine* self, IStatus* status, IExternalContext* context) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::openAttachment(&status2, context);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopcloseAttachmentDispatcher(IExternalEngine* self, IStatus* status, IExternalContext* context) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::closeAttachment(&status2, context);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static IExternalFunction* CLOOP_CARG cloopmakeFunctionDispatcher(IExternalEngine* self, IStatus* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* inBuilder, IMetadataBuilder* outBuilder) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::makeFunction(&status2, context, metadata, inBuilder, outBuilder);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IExternalFunction*>(0);
			}
		}

		static IExternalProcedure* CLOOP_CARG cloopmakeProcedureDispatcher(IExternalEngine* self, IStatus* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* inBuilder, IMetadataBuilder* outBuilder) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::makeProcedure(&status2, context, metadata, inBuilder, outBuilder);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IExternalProcedure*>(0);
			}
		}

		static IExternalTrigger* CLOOP_CARG cloopmakeTriggerDispatcher(IExternalEngine* self, IStatus* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* fieldsBuilder) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::makeTrigger(&status2, context, metadata, fieldsBuilder);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IExternalTrigger*>(0);
			}
		}

		static void CLOOP_CARG cloopsetOwnerDispatcher(IPluginBase* self, IReferenceCounted* r) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setOwner(r);
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static IReferenceCounted* CLOOP_CARG cloopgetOwnerDispatcher(IPluginBase* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOwner();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<IReferenceCounted*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IPluginBaseImpl<Name, StatusType, Inherit<IReferenceCountedImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IExternalEngine> > > > > > >
	class IExternalEngineImpl : public IExternalEngineBaseImpl<Name, StatusType, Base>
	{
	protected:
		IExternalEngineImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IExternalEngineImpl()
		{
		}

		virtual void open(StatusType* status, IExternalContext* context, char* charSet, unsigned charSetSize) = 0;
		virtual void openAttachment(StatusType* status, IExternalContext* context) = 0;
		virtual void closeAttachment(StatusType* status, IExternalContext* context) = 0;
		virtual IExternalFunction* makeFunction(StatusType* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* inBuilder, IMetadataBuilder* outBuilder) = 0;
		virtual IExternalProcedure* makeProcedure(StatusType* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* inBuilder, IMetadataBuilder* outBuilder) = 0;
		virtual IExternalTrigger* makeTrigger(StatusType* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* fieldsBuilder) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class ITimerBaseImpl : public Base
	{
	public:
		typedef ITimer Declaration;

		ITimerBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->handler = &Name::cloophandlerDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloophandlerDispatcher(ITimer* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::handler();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IReferenceCountedImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<ITimer> > > > >
	class ITimerImpl : public ITimerBaseImpl<Name, StatusType, Base>
	{
	protected:
		ITimerImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITimerImpl()
		{
		}

		virtual void handler() = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class ITimerControlBaseImpl : public Base
	{
	public:
		typedef ITimerControl Declaration;

		ITimerControlBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->start = &Name::cloopstartDispatcher;
					this->stop = &Name::cloopstopDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopstartDispatcher(ITimerControl* self, IStatus* status, ITimer* timer, ISC_UINT64 microSeconds) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::start(&status2, timer, microSeconds);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopstopDispatcher(ITimerControl* self, IStatus* status, ITimer* timer) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::stop(&status2, timer);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<ITimerControl> > >
	class ITimerControlImpl : public ITimerControlBaseImpl<Name, StatusType, Base>
	{
	protected:
		ITimerControlImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITimerControlImpl()
		{
		}

		virtual void start(StatusType* status, ITimer* timer, ISC_UINT64 microSeconds) = 0;
		virtual void stop(StatusType* status, ITimer* timer) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IVersionCallbackBaseImpl : public Base
	{
	public:
		typedef IVersionCallback Declaration;

		IVersionCallbackBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->callback = &Name::cloopcallbackDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopcallbackDispatcher(IVersionCallback* self, IStatus* status, const char* text) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::callback(&status2, text);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<IVersionCallback> > >
	class IVersionCallbackImpl : public IVersionCallbackBaseImpl<Name, StatusType, Base>
	{
	protected:
		IVersionCallbackImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IVersionCallbackImpl()
		{
		}

		virtual void callback(StatusType* status, const char* text) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IUtilBaseImpl : public Base
	{
	public:
		typedef IUtil Declaration;

		IUtilBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getFbVersion = &Name::cloopgetFbVersionDispatcher;
					this->loadBlob = &Name::clooploadBlobDispatcher;
					this->dumpBlob = &Name::cloopdumpBlobDispatcher;
					this->getPerfCounters = &Name::cloopgetPerfCountersDispatcher;
					this->executeCreateDatabase = &Name::cloopexecuteCreateDatabaseDispatcher;
					this->decodeDate = &Name::cloopdecodeDateDispatcher;
					this->decodeTime = &Name::cloopdecodeTimeDispatcher;
					this->encodeDate = &Name::cloopencodeDateDispatcher;
					this->encodeTime = &Name::cloopencodeTimeDispatcher;
					this->formatStatus = &Name::cloopformatStatusDispatcher;
					this->getClientVersion = &Name::cloopgetClientVersionDispatcher;
					this->getXpbBuilder = &Name::cloopgetXpbBuilderDispatcher;
					this->setOffsets = &Name::cloopsetOffsetsDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopgetFbVersionDispatcher(IUtil* self, IStatus* status, IAttachment* att, IVersionCallback* callback) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::getFbVersion(&status2, att, callback);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG clooploadBlobDispatcher(IUtil* self, IStatus* status, ISC_QUAD* blobId, IAttachment* att, ITransaction* tra, const char* file, FB_BOOLEAN txt) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::loadBlob(&status2, blobId, att, tra, file, txt);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopdumpBlobDispatcher(IUtil* self, IStatus* status, ISC_QUAD* blobId, IAttachment* att, ITransaction* tra, const char* file, FB_BOOLEAN txt) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::dumpBlob(&status2, blobId, att, tra, file, txt);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopgetPerfCountersDispatcher(IUtil* self, IStatus* status, IAttachment* att, const char* countersSet, ISC_INT64* counters) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::getPerfCounters(&status2, att, countersSet, counters);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static IAttachment* CLOOP_CARG cloopexecuteCreateDatabaseDispatcher(IUtil* self, IStatus* status, unsigned stmtLength, const char* creatDBstatement, unsigned dialect, FB_BOOLEAN* stmtIsCreateDb) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::executeCreateDatabase(&status2, stmtLength, creatDBstatement, dialect, stmtIsCreateDb);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IAttachment*>(0);
			}
		}

		static void CLOOP_CARG cloopdecodeDateDispatcher(IUtil* self, ISC_DATE date, unsigned* year, unsigned* month, unsigned* day) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::decodeDate(date, year, month, day);
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static void CLOOP_CARG cloopdecodeTimeDispatcher(IUtil* self, ISC_TIME time, unsigned* hours, unsigned* minutes, unsigned* seconds, unsigned* fractions) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::decodeTime(time, hours, minutes, seconds, fractions);
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static ISC_DATE CLOOP_CARG cloopencodeDateDispatcher(IUtil* self, unsigned year, unsigned month, unsigned day) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::encodeDate(year, month, day);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<ISC_DATE>(0);
			}
		}

		static ISC_TIME CLOOP_CARG cloopencodeTimeDispatcher(IUtil* self, unsigned hours, unsigned minutes, unsigned seconds, unsigned fractions) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::encodeTime(hours, minutes, seconds, fractions);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<ISC_TIME>(0);
			}
		}

		static unsigned CLOOP_CARG cloopformatStatusDispatcher(IUtil* self, char* buffer, unsigned bufferSize, IStatus* status) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::formatStatus(buffer, bufferSize, status);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetClientVersionDispatcher(IUtil* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getClientVersion();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static IXpbBuilder* CLOOP_CARG cloopgetXpbBuilderDispatcher(IUtil* self, IStatus* status, unsigned kind, const unsigned char* buf, unsigned len) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getXpbBuilder(&status2, kind, buf, len);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IXpbBuilder*>(0);
			}
		}

		static unsigned CLOOP_CARG cloopsetOffsetsDispatcher(IUtil* self, IStatus* status, IMessageMetadata* metadata, IOffsetsCallback* callback) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::setOffsets(&status2, metadata, callback);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<unsigned>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<IUtil> > >
	class IUtilImpl : public IUtilBaseImpl<Name, StatusType, Base>
	{
	protected:
		IUtilImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IUtilImpl()
		{
		}

		virtual void getFbVersion(StatusType* status, IAttachment* att, IVersionCallback* callback) = 0;
		virtual void loadBlob(StatusType* status, ISC_QUAD* blobId, IAttachment* att, ITransaction* tra, const char* file, FB_BOOLEAN txt) = 0;
		virtual void dumpBlob(StatusType* status, ISC_QUAD* blobId, IAttachment* att, ITransaction* tra, const char* file, FB_BOOLEAN txt) = 0;
		virtual void getPerfCounters(StatusType* status, IAttachment* att, const char* countersSet, ISC_INT64* counters) = 0;
		virtual IAttachment* executeCreateDatabase(StatusType* status, unsigned stmtLength, const char* creatDBstatement, unsigned dialect, FB_BOOLEAN* stmtIsCreateDb) = 0;
		virtual void decodeDate(ISC_DATE date, unsigned* year, unsigned* month, unsigned* day) = 0;
		virtual void decodeTime(ISC_TIME time, unsigned* hours, unsigned* minutes, unsigned* seconds, unsigned* fractions) = 0;
		virtual ISC_DATE encodeDate(unsigned year, unsigned month, unsigned day) = 0;
		virtual ISC_TIME encodeTime(unsigned hours, unsigned minutes, unsigned seconds, unsigned fractions) = 0;
		virtual unsigned formatStatus(char* buffer, unsigned bufferSize, IStatus* status) = 0;
		virtual unsigned getClientVersion() = 0;
		virtual IXpbBuilder* getXpbBuilder(StatusType* status, unsigned kind, const unsigned char* buf, unsigned len) = 0;
		virtual unsigned setOffsets(StatusType* status, IMessageMetadata* metadata, IOffsetsCallback* callback) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IOffsetsCallbackBaseImpl : public Base
	{
	public:
		typedef IOffsetsCallback Declaration;

		IOffsetsCallbackBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->setOffset = &Name::cloopsetOffsetDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopsetOffsetDispatcher(IOffsetsCallback* self, IStatus* status, unsigned index, unsigned offset, unsigned nullOffset) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::setOffset(&status2, index, offset, nullOffset);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<IOffsetsCallback> > >
	class IOffsetsCallbackImpl : public IOffsetsCallbackBaseImpl<Name, StatusType, Base>
	{
	protected:
		IOffsetsCallbackImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IOffsetsCallbackImpl()
		{
		}

		virtual void setOffset(StatusType* status, unsigned index, unsigned offset, unsigned nullOffset) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IXpbBuilderBaseImpl : public Base
	{
	public:
		typedef IXpbBuilder Declaration;

		IXpbBuilderBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->dispose = &Name::cloopdisposeDispatcher;
					this->clear = &Name::cloopclearDispatcher;
					this->removeCurrent = &Name::cloopremoveCurrentDispatcher;
					this->insertInt = &Name::cloopinsertIntDispatcher;
					this->insertBigInt = &Name::cloopinsertBigIntDispatcher;
					this->insertBytes = &Name::cloopinsertBytesDispatcher;
					this->insertString = &Name::cloopinsertStringDispatcher;
					this->insertTag = &Name::cloopinsertTagDispatcher;
					this->isEof = &Name::cloopisEofDispatcher;
					this->moveNext = &Name::cloopmoveNextDispatcher;
					this->rewind = &Name::clooprewindDispatcher;
					this->findFirst = &Name::cloopfindFirstDispatcher;
					this->findNext = &Name::cloopfindNextDispatcher;
					this->getTag = &Name::cloopgetTagDispatcher;
					this->getLength = &Name::cloopgetLengthDispatcher;
					this->getInt = &Name::cloopgetIntDispatcher;
					this->getBigInt = &Name::cloopgetBigIntDispatcher;
					this->getString = &Name::cloopgetStringDispatcher;
					this->getBytes = &Name::cloopgetBytesDispatcher;
					this->getBufferLength = &Name::cloopgetBufferLengthDispatcher;
					this->getBuffer = &Name::cloopgetBufferDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopclearDispatcher(IXpbBuilder* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::clear(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopremoveCurrentDispatcher(IXpbBuilder* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::removeCurrent(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopinsertIntDispatcher(IXpbBuilder* self, IStatus* status, unsigned char tag, int value) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::insertInt(&status2, tag, value);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopinsertBigIntDispatcher(IXpbBuilder* self, IStatus* status, unsigned char tag, ISC_INT64 value) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::insertBigInt(&status2, tag, value);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopinsertBytesDispatcher(IXpbBuilder* self, IStatus* status, unsigned char tag, const void* bytes, unsigned length) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::insertBytes(&status2, tag, bytes, length);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopinsertStringDispatcher(IXpbBuilder* self, IStatus* status, unsigned char tag, const char* str) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::insertString(&status2, tag, str);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopinsertTagDispatcher(IXpbBuilder* self, IStatus* status, unsigned char tag) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::insertTag(&status2, tag);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static FB_BOOLEAN CLOOP_CARG cloopisEofDispatcher(IXpbBuilder* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::isEof(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static void CLOOP_CARG cloopmoveNextDispatcher(IXpbBuilder* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::moveNext(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG clooprewindDispatcher(IXpbBuilder* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::rewind(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static FB_BOOLEAN CLOOP_CARG cloopfindFirstDispatcher(IXpbBuilder* self, IStatus* status, unsigned char tag) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::findFirst(&status2, tag);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG cloopfindNextDispatcher(IXpbBuilder* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::findNext(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static unsigned char CLOOP_CARG cloopgetTagDispatcher(IXpbBuilder* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getTag(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<unsigned char>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetLengthDispatcher(IXpbBuilder* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getLength(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<unsigned>(0);
			}
		}

		static int CLOOP_CARG cloopgetIntDispatcher(IXpbBuilder* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getInt(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<int>(0);
			}
		}

		static ISC_INT64 CLOOP_CARG cloopgetBigIntDispatcher(IXpbBuilder* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getBigInt(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<ISC_INT64>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetStringDispatcher(IXpbBuilder* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getString(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<const char*>(0);
			}
		}

		static const unsigned char* CLOOP_CARG cloopgetBytesDispatcher(IXpbBuilder* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getBytes(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<const unsigned char*>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetBufferLengthDispatcher(IXpbBuilder* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getBufferLength(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<unsigned>(0);
			}
		}

		static const unsigned char* CLOOP_CARG cloopgetBufferDispatcher(IXpbBuilder* self, IStatus* status) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getBuffer(&status2);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<const unsigned char*>(0);
			}
		}

		static void CLOOP_CARG cloopdisposeDispatcher(IDisposable* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::dispose();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IDisposableImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IXpbBuilder> > > > >
	class IXpbBuilderImpl : public IXpbBuilderBaseImpl<Name, StatusType, Base>
	{
	protected:
		IXpbBuilderImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IXpbBuilderImpl()
		{
		}

		virtual void clear(StatusType* status) = 0;
		virtual void removeCurrent(StatusType* status) = 0;
		virtual void insertInt(StatusType* status, unsigned char tag, int value) = 0;
		virtual void insertBigInt(StatusType* status, unsigned char tag, ISC_INT64 value) = 0;
		virtual void insertBytes(StatusType* status, unsigned char tag, const void* bytes, unsigned length) = 0;
		virtual void insertString(StatusType* status, unsigned char tag, const char* str) = 0;
		virtual void insertTag(StatusType* status, unsigned char tag) = 0;
		virtual FB_BOOLEAN isEof(StatusType* status) = 0;
		virtual void moveNext(StatusType* status) = 0;
		virtual void rewind(StatusType* status) = 0;
		virtual FB_BOOLEAN findFirst(StatusType* status, unsigned char tag) = 0;
		virtual FB_BOOLEAN findNext(StatusType* status) = 0;
		virtual unsigned char getTag(StatusType* status) = 0;
		virtual unsigned getLength(StatusType* status) = 0;
		virtual int getInt(StatusType* status) = 0;
		virtual ISC_INT64 getBigInt(StatusType* status) = 0;
		virtual const char* getString(StatusType* status) = 0;
		virtual const unsigned char* getBytes(StatusType* status) = 0;
		virtual unsigned getBufferLength(StatusType* status) = 0;
		virtual const unsigned char* getBuffer(StatusType* status) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class ITraceConnectionBaseImpl : public Base
	{
	public:
		typedef ITraceConnection Declaration;

		ITraceConnectionBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getKind = &Name::cloopgetKindDispatcher;
					this->getProcessID = &Name::cloopgetProcessIDDispatcher;
					this->getUserName = &Name::cloopgetUserNameDispatcher;
					this->getRoleName = &Name::cloopgetRoleNameDispatcher;
					this->getCharSet = &Name::cloopgetCharSetDispatcher;
					this->getRemoteProtocol = &Name::cloopgetRemoteProtocolDispatcher;
					this->getRemoteAddress = &Name::cloopgetRemoteAddressDispatcher;
					this->getRemoteProcessID = &Name::cloopgetRemoteProcessIDDispatcher;
					this->getRemoteProcessName = &Name::cloopgetRemoteProcessNameDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static unsigned CLOOP_CARG cloopgetKindDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getKind();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static int CLOOP_CARG cloopgetProcessIDDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getProcessID();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetUserNameDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getUserName();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRoleNameDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRoleName();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetCharSetDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getCharSet();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRemoteProtocolDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteProtocol();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRemoteAddressDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteAddress();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static int CLOOP_CARG cloopgetRemoteProcessIDDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteProcessID();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRemoteProcessNameDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteProcessName();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<ITraceConnection> > >
	class ITraceConnectionImpl : public ITraceConnectionBaseImpl<Name, StatusType, Base>
	{
	protected:
		ITraceConnectionImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceConnectionImpl()
		{
		}

		virtual unsigned getKind() = 0;
		virtual int getProcessID() = 0;
		virtual const char* getUserName() = 0;
		virtual const char* getRoleName() = 0;
		virtual const char* getCharSet() = 0;
		virtual const char* getRemoteProtocol() = 0;
		virtual const char* getRemoteAddress() = 0;
		virtual int getRemoteProcessID() = 0;
		virtual const char* getRemoteProcessName() = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class ITraceDatabaseConnectionBaseImpl : public Base
	{
	public:
		typedef ITraceDatabaseConnection Declaration;

		ITraceDatabaseConnectionBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getKind = &Name::cloopgetKindDispatcher;
					this->getProcessID = &Name::cloopgetProcessIDDispatcher;
					this->getUserName = &Name::cloopgetUserNameDispatcher;
					this->getRoleName = &Name::cloopgetRoleNameDispatcher;
					this->getCharSet = &Name::cloopgetCharSetDispatcher;
					this->getRemoteProtocol = &Name::cloopgetRemoteProtocolDispatcher;
					this->getRemoteAddress = &Name::cloopgetRemoteAddressDispatcher;
					this->getRemoteProcessID = &Name::cloopgetRemoteProcessIDDispatcher;
					this->getRemoteProcessName = &Name::cloopgetRemoteProcessNameDispatcher;
					this->getConnectionID = &Name::cloopgetConnectionIDDispatcher;
					this->getDatabaseName = &Name::cloopgetDatabaseNameDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static ISC_INT64 CLOOP_CARG cloopgetConnectionIDDispatcher(ITraceDatabaseConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getConnectionID();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<ISC_INT64>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetDatabaseNameDispatcher(ITraceDatabaseConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getDatabaseName();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetKindDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getKind();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static int CLOOP_CARG cloopgetProcessIDDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getProcessID();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetUserNameDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getUserName();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRoleNameDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRoleName();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetCharSetDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getCharSet();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRemoteProtocolDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteProtocol();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRemoteAddressDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteAddress();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static int CLOOP_CARG cloopgetRemoteProcessIDDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteProcessID();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRemoteProcessNameDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteProcessName();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = ITraceConnectionImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<ITraceDatabaseConnection> > > > >
	class ITraceDatabaseConnectionImpl : public ITraceDatabaseConnectionBaseImpl<Name, StatusType, Base>
	{
	protected:
		ITraceDatabaseConnectionImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceDatabaseConnectionImpl()
		{
		}

		virtual ISC_INT64 getConnectionID() = 0;
		virtual const char* getDatabaseName() = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class ITraceTransactionBaseImpl : public Base
	{
	public:
		typedef ITraceTransaction Declaration;

		ITraceTransactionBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getTransactionID = &Name::cloopgetTransactionIDDispatcher;
					this->getReadOnly = &Name::cloopgetReadOnlyDispatcher;
					this->getWait = &Name::cloopgetWaitDispatcher;
					this->getIsolation = &Name::cloopgetIsolationDispatcher;
					this->getPerf = &Name::cloopgetPerfDispatcher;
					this->getInitialID = &Name::cloopgetInitialIDDispatcher;
					this->getPreviousID = &Name::cloopgetPreviousIDDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static ISC_INT64 CLOOP_CARG cloopgetTransactionIDDispatcher(ITraceTransaction* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getTransactionID();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<ISC_INT64>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG cloopgetReadOnlyDispatcher(ITraceTransaction* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getReadOnly();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static int CLOOP_CARG cloopgetWaitDispatcher(ITraceTransaction* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getWait();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetIsolationDispatcher(ITraceTransaction* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getIsolation();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static PerformanceInfo* CLOOP_CARG cloopgetPerfDispatcher(ITraceTransaction* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPerf();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<PerformanceInfo*>(0);
			}
		}

		static ISC_INT64 CLOOP_CARG cloopgetInitialIDDispatcher(ITraceTransaction* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getInitialID();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<ISC_INT64>(0);
			}
		}

		static ISC_INT64 CLOOP_CARG cloopgetPreviousIDDispatcher(ITraceTransaction* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPreviousID();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<ISC_INT64>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<ITraceTransaction> > >
	class ITraceTransactionImpl : public ITraceTransactionBaseImpl<Name, StatusType, Base>
	{
	protected:
		ITraceTransactionImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceTransactionImpl()
		{
		}

		virtual ISC_INT64 getTransactionID() = 0;
		virtual FB_BOOLEAN getReadOnly() = 0;
		virtual int getWait() = 0;
		virtual unsigned getIsolation() = 0;
		virtual PerformanceInfo* getPerf() = 0;
		virtual ISC_INT64 getInitialID() = 0;
		virtual ISC_INT64 getPreviousID() = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class ITraceParamsBaseImpl : public Base
	{
	public:
		typedef ITraceParams Declaration;

		ITraceParamsBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getCount = &Name::cloopgetCountDispatcher;
					this->getParam = &Name::cloopgetParamDispatcher;
					this->getTextUTF8 = &Name::cloopgetTextUTF8Dispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static unsigned CLOOP_CARG cloopgetCountDispatcher(ITraceParams* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getCount();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static const dsc* CLOOP_CARG cloopgetParamDispatcher(ITraceParams* self, unsigned idx) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getParam(idx);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const dsc*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetTextUTF8Dispatcher(ITraceParams* self, IStatus* status, unsigned idx) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::getTextUTF8(&status2, idx);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<const char*>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<ITraceParams> > >
	class ITraceParamsImpl : public ITraceParamsBaseImpl<Name, StatusType, Base>
	{
	protected:
		ITraceParamsImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceParamsImpl()
		{
		}

		virtual unsigned getCount() = 0;
		virtual const dsc* getParam(unsigned idx) = 0;
		virtual const char* getTextUTF8(StatusType* status, unsigned idx) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class ITraceStatementBaseImpl : public Base
	{
	public:
		typedef ITraceStatement Declaration;

		ITraceStatementBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getStmtID = &Name::cloopgetStmtIDDispatcher;
					this->getPerf = &Name::cloopgetPerfDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static ISC_INT64 CLOOP_CARG cloopgetStmtIDDispatcher(ITraceStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getStmtID();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<ISC_INT64>(0);
			}
		}

		static PerformanceInfo* CLOOP_CARG cloopgetPerfDispatcher(ITraceStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPerf();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<PerformanceInfo*>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<ITraceStatement> > >
	class ITraceStatementImpl : public ITraceStatementBaseImpl<Name, StatusType, Base>
	{
	protected:
		ITraceStatementImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceStatementImpl()
		{
		}

		virtual ISC_INT64 getStmtID() = 0;
		virtual PerformanceInfo* getPerf() = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class ITraceSQLStatementBaseImpl : public Base
	{
	public:
		typedef ITraceSQLStatement Declaration;

		ITraceSQLStatementBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getStmtID = &Name::cloopgetStmtIDDispatcher;
					this->getPerf = &Name::cloopgetPerfDispatcher;
					this->getText = &Name::cloopgetTextDispatcher;
					this->getPlan = &Name::cloopgetPlanDispatcher;
					this->getInputs = &Name::cloopgetInputsDispatcher;
					this->getTextUTF8 = &Name::cloopgetTextUTF8Dispatcher;
					this->getExplainedPlan = &Name::cloopgetExplainedPlanDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetTextDispatcher(ITraceSQLStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getText();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetPlanDispatcher(ITraceSQLStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPlan();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static ITraceParams* CLOOP_CARG cloopgetInputsDispatcher(ITraceSQLStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getInputs();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<ITraceParams*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetTextUTF8Dispatcher(ITraceSQLStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getTextUTF8();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetExplainedPlanDispatcher(ITraceSQLStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getExplainedPlan();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static ISC_INT64 CLOOP_CARG cloopgetStmtIDDispatcher(ITraceStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getStmtID();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<ISC_INT64>(0);
			}
		}

		static PerformanceInfo* CLOOP_CARG cloopgetPerfDispatcher(ITraceStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPerf();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<PerformanceInfo*>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = ITraceStatementImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<ITraceSQLStatement> > > > >
	class ITraceSQLStatementImpl : public ITraceSQLStatementBaseImpl<Name, StatusType, Base>
	{
	protected:
		ITraceSQLStatementImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceSQLStatementImpl()
		{
		}

		virtual const char* getText() = 0;
		virtual const char* getPlan() = 0;
		virtual ITraceParams* getInputs() = 0;
		virtual const char* getTextUTF8() = 0;
		virtual const char* getExplainedPlan() = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class ITraceBLRStatementBaseImpl : public Base
	{
	public:
		typedef ITraceBLRStatement Declaration;

		ITraceBLRStatementBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getStmtID = &Name::cloopgetStmtIDDispatcher;
					this->getPerf = &Name::cloopgetPerfDispatcher;
					this->getData = &Name::cloopgetDataDispatcher;
					this->getDataLength = &Name::cloopgetDataLengthDispatcher;
					this->getText = &Name::cloopgetTextDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const unsigned char* CLOOP_CARG cloopgetDataDispatcher(ITraceBLRStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getData();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const unsigned char*>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetDataLengthDispatcher(ITraceBLRStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getDataLength();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetTextDispatcher(ITraceBLRStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getText();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static ISC_INT64 CLOOP_CARG cloopgetStmtIDDispatcher(ITraceStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getStmtID();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<ISC_INT64>(0);
			}
		}

		static PerformanceInfo* CLOOP_CARG cloopgetPerfDispatcher(ITraceStatement* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPerf();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<PerformanceInfo*>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = ITraceStatementImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<ITraceBLRStatement> > > > >
	class ITraceBLRStatementImpl : public ITraceBLRStatementBaseImpl<Name, StatusType, Base>
	{
	protected:
		ITraceBLRStatementImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceBLRStatementImpl()
		{
		}

		virtual const unsigned char* getData() = 0;
		virtual unsigned getDataLength() = 0;
		virtual const char* getText() = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class ITraceDYNRequestBaseImpl : public Base
	{
	public:
		typedef ITraceDYNRequest Declaration;

		ITraceDYNRequestBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getData = &Name::cloopgetDataDispatcher;
					this->getDataLength = &Name::cloopgetDataLengthDispatcher;
					this->getText = &Name::cloopgetTextDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const unsigned char* CLOOP_CARG cloopgetDataDispatcher(ITraceDYNRequest* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getData();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const unsigned char*>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetDataLengthDispatcher(ITraceDYNRequest* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getDataLength();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetTextDispatcher(ITraceDYNRequest* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getText();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<ITraceDYNRequest> > >
	class ITraceDYNRequestImpl : public ITraceDYNRequestBaseImpl<Name, StatusType, Base>
	{
	protected:
		ITraceDYNRequestImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceDYNRequestImpl()
		{
		}

		virtual const unsigned char* getData() = 0;
		virtual unsigned getDataLength() = 0;
		virtual const char* getText() = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class ITraceContextVariableBaseImpl : public Base
	{
	public:
		typedef ITraceContextVariable Declaration;

		ITraceContextVariableBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getNameSpace = &Name::cloopgetNameSpaceDispatcher;
					this->getVarName = &Name::cloopgetVarNameDispatcher;
					this->getVarValue = &Name::cloopgetVarValueDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetNameSpaceDispatcher(ITraceContextVariable* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getNameSpace();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetVarNameDispatcher(ITraceContextVariable* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getVarName();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetVarValueDispatcher(ITraceContextVariable* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getVarValue();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<ITraceContextVariable> > >
	class ITraceContextVariableImpl : public ITraceContextVariableBaseImpl<Name, StatusType, Base>
	{
	protected:
		ITraceContextVariableImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceContextVariableImpl()
		{
		}

		virtual const char* getNameSpace() = 0;
		virtual const char* getVarName() = 0;
		virtual const char* getVarValue() = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class ITraceProcedureBaseImpl : public Base
	{
	public:
		typedef ITraceProcedure Declaration;

		ITraceProcedureBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getProcName = &Name::cloopgetProcNameDispatcher;
					this->getInputs = &Name::cloopgetInputsDispatcher;
					this->getPerf = &Name::cloopgetPerfDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetProcNameDispatcher(ITraceProcedure* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getProcName();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static ITraceParams* CLOOP_CARG cloopgetInputsDispatcher(ITraceProcedure* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getInputs();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<ITraceParams*>(0);
			}
		}

		static PerformanceInfo* CLOOP_CARG cloopgetPerfDispatcher(ITraceProcedure* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPerf();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<PerformanceInfo*>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<ITraceProcedure> > >
	class ITraceProcedureImpl : public ITraceProcedureBaseImpl<Name, StatusType, Base>
	{
	protected:
		ITraceProcedureImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceProcedureImpl()
		{
		}

		virtual const char* getProcName() = 0;
		virtual ITraceParams* getInputs() = 0;
		virtual PerformanceInfo* getPerf() = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class ITraceFunctionBaseImpl : public Base
	{
	public:
		typedef ITraceFunction Declaration;

		ITraceFunctionBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getFuncName = &Name::cloopgetFuncNameDispatcher;
					this->getInputs = &Name::cloopgetInputsDispatcher;
					this->getResult = &Name::cloopgetResultDispatcher;
					this->getPerf = &Name::cloopgetPerfDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetFuncNameDispatcher(ITraceFunction* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getFuncName();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static ITraceParams* CLOOP_CARG cloopgetInputsDispatcher(ITraceFunction* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getInputs();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<ITraceParams*>(0);
			}
		}

		static ITraceParams* CLOOP_CARG cloopgetResultDispatcher(ITraceFunction* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getResult();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<ITraceParams*>(0);
			}
		}

		static PerformanceInfo* CLOOP_CARG cloopgetPerfDispatcher(ITraceFunction* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPerf();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<PerformanceInfo*>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<ITraceFunction> > >
	class ITraceFunctionImpl : public ITraceFunctionBaseImpl<Name, StatusType, Base>
	{
	protected:
		ITraceFunctionImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceFunctionImpl()
		{
		}

		virtual const char* getFuncName() = 0;
		virtual ITraceParams* getInputs() = 0;
		virtual ITraceParams* getResult() = 0;
		virtual PerformanceInfo* getPerf() = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class ITraceTriggerBaseImpl : public Base
	{
	public:
		typedef ITraceTrigger Declaration;

		ITraceTriggerBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getTriggerName = &Name::cloopgetTriggerNameDispatcher;
					this->getRelationName = &Name::cloopgetRelationNameDispatcher;
					this->getAction = &Name::cloopgetActionDispatcher;
					this->getWhich = &Name::cloopgetWhichDispatcher;
					this->getPerf = &Name::cloopgetPerfDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetTriggerNameDispatcher(ITraceTrigger* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getTriggerName();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRelationNameDispatcher(ITraceTrigger* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRelationName();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static int CLOOP_CARG cloopgetActionDispatcher(ITraceTrigger* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getAction();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}

		static int CLOOP_CARG cloopgetWhichDispatcher(ITraceTrigger* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getWhich();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}

		static PerformanceInfo* CLOOP_CARG cloopgetPerfDispatcher(ITraceTrigger* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPerf();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<PerformanceInfo*>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<ITraceTrigger> > >
	class ITraceTriggerImpl : public ITraceTriggerBaseImpl<Name, StatusType, Base>
	{
	protected:
		ITraceTriggerImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceTriggerImpl()
		{
		}

		virtual const char* getTriggerName() = 0;
		virtual const char* getRelationName() = 0;
		virtual int getAction() = 0;
		virtual int getWhich() = 0;
		virtual PerformanceInfo* getPerf() = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class ITraceServiceConnectionBaseImpl : public Base
	{
	public:
		typedef ITraceServiceConnection Declaration;

		ITraceServiceConnectionBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getKind = &Name::cloopgetKindDispatcher;
					this->getProcessID = &Name::cloopgetProcessIDDispatcher;
					this->getUserName = &Name::cloopgetUserNameDispatcher;
					this->getRoleName = &Name::cloopgetRoleNameDispatcher;
					this->getCharSet = &Name::cloopgetCharSetDispatcher;
					this->getRemoteProtocol = &Name::cloopgetRemoteProtocolDispatcher;
					this->getRemoteAddress = &Name::cloopgetRemoteAddressDispatcher;
					this->getRemoteProcessID = &Name::cloopgetRemoteProcessIDDispatcher;
					this->getRemoteProcessName = &Name::cloopgetRemoteProcessNameDispatcher;
					this->getServiceID = &Name::cloopgetServiceIDDispatcher;
					this->getServiceMgr = &Name::cloopgetServiceMgrDispatcher;
					this->getServiceName = &Name::cloopgetServiceNameDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void* CLOOP_CARG cloopgetServiceIDDispatcher(ITraceServiceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getServiceID();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<void*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetServiceMgrDispatcher(ITraceServiceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getServiceMgr();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetServiceNameDispatcher(ITraceServiceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getServiceName();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static unsigned CLOOP_CARG cloopgetKindDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getKind();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static int CLOOP_CARG cloopgetProcessIDDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getProcessID();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetUserNameDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getUserName();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRoleNameDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRoleName();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetCharSetDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getCharSet();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRemoteProtocolDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteProtocol();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRemoteAddressDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteAddress();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static int CLOOP_CARG cloopgetRemoteProcessIDDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteProcessID();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetRemoteProcessNameDispatcher(ITraceConnection* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getRemoteProcessName();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = ITraceConnectionImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<ITraceServiceConnection> > > > >
	class ITraceServiceConnectionImpl : public ITraceServiceConnectionBaseImpl<Name, StatusType, Base>
	{
	protected:
		ITraceServiceConnectionImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceServiceConnectionImpl()
		{
		}

		virtual void* getServiceID() = 0;
		virtual const char* getServiceMgr() = 0;
		virtual const char* getServiceName() = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class ITraceStatusVectorBaseImpl : public Base
	{
	public:
		typedef ITraceStatusVector Declaration;

		ITraceStatusVectorBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->hasError = &Name::cloophasErrorDispatcher;
					this->hasWarning = &Name::cloophasWarningDispatcher;
					this->getStatus = &Name::cloopgetStatusDispatcher;
					this->getText = &Name::cloopgetTextDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static FB_BOOLEAN CLOOP_CARG cloophasErrorDispatcher(ITraceStatusVector* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::hasError();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG cloophasWarningDispatcher(ITraceStatusVector* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::hasWarning();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static IStatus* CLOOP_CARG cloopgetStatusDispatcher(ITraceStatusVector* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getStatus();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<IStatus*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetTextDispatcher(ITraceStatusVector* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getText();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<ITraceStatusVector> > >
	class ITraceStatusVectorImpl : public ITraceStatusVectorBaseImpl<Name, StatusType, Base>
	{
	protected:
		ITraceStatusVectorImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceStatusVectorImpl()
		{
		}

		virtual FB_BOOLEAN hasError() = 0;
		virtual FB_BOOLEAN hasWarning() = 0;
		virtual IStatus* getStatus() = 0;
		virtual const char* getText() = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class ITraceSweepInfoBaseImpl : public Base
	{
	public:
		typedef ITraceSweepInfo Declaration;

		ITraceSweepInfoBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getOIT = &Name::cloopgetOITDispatcher;
					this->getOST = &Name::cloopgetOSTDispatcher;
					this->getOAT = &Name::cloopgetOATDispatcher;
					this->getNext = &Name::cloopgetNextDispatcher;
					this->getPerf = &Name::cloopgetPerfDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static ISC_INT64 CLOOP_CARG cloopgetOITDispatcher(ITraceSweepInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOIT();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<ISC_INT64>(0);
			}
		}

		static ISC_INT64 CLOOP_CARG cloopgetOSTDispatcher(ITraceSweepInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOST();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<ISC_INT64>(0);
			}
		}

		static ISC_INT64 CLOOP_CARG cloopgetOATDispatcher(ITraceSweepInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOAT();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<ISC_INT64>(0);
			}
		}

		static ISC_INT64 CLOOP_CARG cloopgetNextDispatcher(ITraceSweepInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getNext();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<ISC_INT64>(0);
			}
		}

		static PerformanceInfo* CLOOP_CARG cloopgetPerfDispatcher(ITraceSweepInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getPerf();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<PerformanceInfo*>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<ITraceSweepInfo> > >
	class ITraceSweepInfoImpl : public ITraceSweepInfoBaseImpl<Name, StatusType, Base>
	{
	protected:
		ITraceSweepInfoImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceSweepInfoImpl()
		{
		}

		virtual ISC_INT64 getOIT() = 0;
		virtual ISC_INT64 getOST() = 0;
		virtual ISC_INT64 getOAT() = 0;
		virtual ISC_INT64 getNext() = 0;
		virtual PerformanceInfo* getPerf() = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class ITraceLogWriterBaseImpl : public Base
	{
	public:
		typedef ITraceLogWriter Declaration;

		ITraceLogWriterBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->write = &Name::cloopwriteDispatcher;
					this->write_s = &Name::cloopwrite_sDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static unsigned CLOOP_CARG cloopwriteDispatcher(ITraceLogWriter* self, const void* buf, unsigned size) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::write(buf, size);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<unsigned>(0);
			}
		}

		static unsigned CLOOP_CARG cloopwrite_sDispatcher(ITraceLogWriter* self, IStatus* status, const void* buf, unsigned size) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::write_s(&status2, buf, size);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<unsigned>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IReferenceCountedImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<ITraceLogWriter> > > > >
	class ITraceLogWriterImpl : public ITraceLogWriterBaseImpl<Name, StatusType, Base>
	{
	protected:
		ITraceLogWriterImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceLogWriterImpl()
		{
		}

		virtual unsigned write(const void* buf, unsigned size) = 0;
		virtual unsigned write_s(StatusType* status, const void* buf, unsigned size) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class ITraceInitInfoBaseImpl : public Base
	{
	public:
		typedef ITraceInitInfo Declaration;

		ITraceInitInfoBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getConfigText = &Name::cloopgetConfigTextDispatcher;
					this->getTraceSessionID = &Name::cloopgetTraceSessionIDDispatcher;
					this->getTraceSessionName = &Name::cloopgetTraceSessionNameDispatcher;
					this->getFirebirdRootDirectory = &Name::cloopgetFirebirdRootDirectoryDispatcher;
					this->getDatabaseName = &Name::cloopgetDatabaseNameDispatcher;
					this->getConnection = &Name::cloopgetConnectionDispatcher;
					this->getLogWriter = &Name::cloopgetLogWriterDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG cloopgetConfigTextDispatcher(ITraceInitInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getConfigText();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static int CLOOP_CARG cloopgetTraceSessionIDDispatcher(ITraceInitInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getTraceSessionID();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetTraceSessionNameDispatcher(ITraceInitInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getTraceSessionName();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetFirebirdRootDirectoryDispatcher(ITraceInitInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getFirebirdRootDirectory();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static const char* CLOOP_CARG cloopgetDatabaseNameDispatcher(ITraceInitInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getDatabaseName();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static ITraceDatabaseConnection* CLOOP_CARG cloopgetConnectionDispatcher(ITraceInitInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getConnection();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<ITraceDatabaseConnection*>(0);
			}
		}

		static ITraceLogWriter* CLOOP_CARG cloopgetLogWriterDispatcher(ITraceInitInfo* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getLogWriter();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<ITraceLogWriter*>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<ITraceInitInfo> > >
	class ITraceInitInfoImpl : public ITraceInitInfoBaseImpl<Name, StatusType, Base>
	{
	protected:
		ITraceInitInfoImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceInitInfoImpl()
		{
		}

		virtual const char* getConfigText() = 0;
		virtual int getTraceSessionID() = 0;
		virtual const char* getTraceSessionName() = 0;
		virtual const char* getFirebirdRootDirectory() = 0;
		virtual const char* getDatabaseName() = 0;
		virtual ITraceDatabaseConnection* getConnection() = 0;
		virtual ITraceLogWriter* getLogWriter() = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class ITracePluginBaseImpl : public Base
	{
	public:
		typedef ITracePlugin Declaration;

		ITracePluginBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->trace_get_error = &Name::clooptrace_get_errorDispatcher;
					this->trace_attach = &Name::clooptrace_attachDispatcher;
					this->trace_detach = &Name::clooptrace_detachDispatcher;
					this->trace_transaction_start = &Name::clooptrace_transaction_startDispatcher;
					this->trace_transaction_end = &Name::clooptrace_transaction_endDispatcher;
					this->trace_proc_execute = &Name::clooptrace_proc_executeDispatcher;
					this->trace_trigger_execute = &Name::clooptrace_trigger_executeDispatcher;
					this->trace_set_context = &Name::clooptrace_set_contextDispatcher;
					this->trace_dsql_prepare = &Name::clooptrace_dsql_prepareDispatcher;
					this->trace_dsql_free = &Name::clooptrace_dsql_freeDispatcher;
					this->trace_dsql_execute = &Name::clooptrace_dsql_executeDispatcher;
					this->trace_blr_compile = &Name::clooptrace_blr_compileDispatcher;
					this->trace_blr_execute = &Name::clooptrace_blr_executeDispatcher;
					this->trace_dyn_execute = &Name::clooptrace_dyn_executeDispatcher;
					this->trace_service_attach = &Name::clooptrace_service_attachDispatcher;
					this->trace_service_start = &Name::clooptrace_service_startDispatcher;
					this->trace_service_query = &Name::clooptrace_service_queryDispatcher;
					this->trace_service_detach = &Name::clooptrace_service_detachDispatcher;
					this->trace_event_error = &Name::clooptrace_event_errorDispatcher;
					this->trace_event_sweep = &Name::clooptrace_event_sweepDispatcher;
					this->trace_func_execute = &Name::clooptrace_func_executeDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static const char* CLOOP_CARG clooptrace_get_errorDispatcher(ITracePlugin* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_get_error();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<const char*>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_attachDispatcher(ITracePlugin* self, ITraceDatabaseConnection* connection, FB_BOOLEAN create_db, unsigned att_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_attach(connection, create_db, att_result);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_detachDispatcher(ITracePlugin* self, ITraceDatabaseConnection* connection, FB_BOOLEAN drop_db) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_detach(connection, drop_db);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_transaction_startDispatcher(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, unsigned tpb_length, const unsigned char* tpb, unsigned tra_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_transaction_start(connection, transaction, tpb_length, tpb, tra_result);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_transaction_endDispatcher(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, FB_BOOLEAN commit, FB_BOOLEAN retain_context, unsigned tra_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_transaction_end(connection, transaction, commit, retain_context, tra_result);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_proc_executeDispatcher(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceProcedure* procedure, FB_BOOLEAN started, unsigned proc_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_proc_execute(connection, transaction, procedure, started, proc_result);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_trigger_executeDispatcher(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceTrigger* trigger, FB_BOOLEAN started, unsigned trig_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_trigger_execute(connection, transaction, trigger, started, trig_result);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_set_contextDispatcher(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceContextVariable* variable) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_set_context(connection, transaction, variable);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_dsql_prepareDispatcher(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceSQLStatement* statement, ISC_INT64 time_millis, unsigned req_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_dsql_prepare(connection, transaction, statement, time_millis, req_result);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_dsql_freeDispatcher(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceSQLStatement* statement, unsigned option) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_dsql_free(connection, statement, option);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_dsql_executeDispatcher(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceSQLStatement* statement, FB_BOOLEAN started, unsigned req_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_dsql_execute(connection, transaction, statement, started, req_result);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_blr_compileDispatcher(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceBLRStatement* statement, ISC_INT64 time_millis, unsigned req_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_blr_compile(connection, transaction, statement, time_millis, req_result);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_blr_executeDispatcher(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceBLRStatement* statement, unsigned req_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_blr_execute(connection, transaction, statement, req_result);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_dyn_executeDispatcher(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceDYNRequest* request, ISC_INT64 time_millis, unsigned req_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_dyn_execute(connection, transaction, request, time_millis, req_result);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_service_attachDispatcher(ITracePlugin* self, ITraceServiceConnection* service, unsigned att_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_service_attach(service, att_result);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_service_startDispatcher(ITracePlugin* self, ITraceServiceConnection* service, unsigned switches_length, const char* switches, unsigned start_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_service_start(service, switches_length, switches, start_result);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_service_queryDispatcher(ITracePlugin* self, ITraceServiceConnection* service, unsigned send_item_length, const unsigned char* send_items, unsigned recv_item_length, const unsigned char* recv_items, unsigned query_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_service_query(service, send_item_length, send_items, recv_item_length, recv_items, query_result);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_service_detachDispatcher(ITracePlugin* self, ITraceServiceConnection* service, unsigned detach_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_service_detach(service, detach_result);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_event_errorDispatcher(ITracePlugin* self, ITraceConnection* connection, ITraceStatusVector* status, const char* function) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_event_error(connection, status, function);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_event_sweepDispatcher(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceSweepInfo* sweep, unsigned sweep_state) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_event_sweep(connection, sweep, sweep_state);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static FB_BOOLEAN CLOOP_CARG clooptrace_func_executeDispatcher(ITracePlugin* self, ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceFunction* function, FB_BOOLEAN started, unsigned func_result) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_func_execute(connection, transaction, function, started, func_result);
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<FB_BOOLEAN>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IReferenceCountedImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<ITracePlugin> > > > >
	class ITracePluginImpl : public ITracePluginBaseImpl<Name, StatusType, Base>
	{
	protected:
		ITracePluginImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITracePluginImpl()
		{
		}

		virtual const char* trace_get_error() = 0;
		virtual FB_BOOLEAN trace_attach(ITraceDatabaseConnection* connection, FB_BOOLEAN create_db, unsigned att_result) = 0;
		virtual FB_BOOLEAN trace_detach(ITraceDatabaseConnection* connection, FB_BOOLEAN drop_db) = 0;
		virtual FB_BOOLEAN trace_transaction_start(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, unsigned tpb_length, const unsigned char* tpb, unsigned tra_result) = 0;
		virtual FB_BOOLEAN trace_transaction_end(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, FB_BOOLEAN commit, FB_BOOLEAN retain_context, unsigned tra_result) = 0;
		virtual FB_BOOLEAN trace_proc_execute(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceProcedure* procedure, FB_BOOLEAN started, unsigned proc_result) = 0;
		virtual FB_BOOLEAN trace_trigger_execute(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceTrigger* trigger, FB_BOOLEAN started, unsigned trig_result) = 0;
		virtual FB_BOOLEAN trace_set_context(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceContextVariable* variable) = 0;
		virtual FB_BOOLEAN trace_dsql_prepare(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceSQLStatement* statement, ISC_INT64 time_millis, unsigned req_result) = 0;
		virtual FB_BOOLEAN trace_dsql_free(ITraceDatabaseConnection* connection, ITraceSQLStatement* statement, unsigned option) = 0;
		virtual FB_BOOLEAN trace_dsql_execute(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceSQLStatement* statement, FB_BOOLEAN started, unsigned req_result) = 0;
		virtual FB_BOOLEAN trace_blr_compile(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceBLRStatement* statement, ISC_INT64 time_millis, unsigned req_result) = 0;
		virtual FB_BOOLEAN trace_blr_execute(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceBLRStatement* statement, unsigned req_result) = 0;
		virtual FB_BOOLEAN trace_dyn_execute(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceDYNRequest* request, ISC_INT64 time_millis, unsigned req_result) = 0;
		virtual FB_BOOLEAN trace_service_attach(ITraceServiceConnection* service, unsigned att_result) = 0;
		virtual FB_BOOLEAN trace_service_start(ITraceServiceConnection* service, unsigned switches_length, const char* switches, unsigned start_result) = 0;
		virtual FB_BOOLEAN trace_service_query(ITraceServiceConnection* service, unsigned send_item_length, const unsigned char* send_items, unsigned recv_item_length, const unsigned char* recv_items, unsigned query_result) = 0;
		virtual FB_BOOLEAN trace_service_detach(ITraceServiceConnection* service, unsigned detach_result) = 0;
		virtual FB_BOOLEAN trace_event_error(ITraceConnection* connection, ITraceStatusVector* status, const char* function) = 0;
		virtual FB_BOOLEAN trace_event_sweep(ITraceDatabaseConnection* connection, ITraceSweepInfo* sweep, unsigned sweep_state) = 0;
		virtual FB_BOOLEAN trace_func_execute(ITraceDatabaseConnection* connection, ITraceTransaction* transaction, ITraceFunction* function, FB_BOOLEAN started, unsigned func_result) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class ITraceFactoryBaseImpl : public Base
	{
	public:
		typedef ITraceFactory Declaration;

		ITraceFactoryBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->addRef = &Name::cloopaddRefDispatcher;
					this->release = &Name::cloopreleaseDispatcher;
					this->setOwner = &Name::cloopsetOwnerDispatcher;
					this->getOwner = &Name::cloopgetOwnerDispatcher;
					this->trace_needs = &Name::clooptrace_needsDispatcher;
					this->trace_create = &Name::clooptrace_createDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static ISC_UINT64 CLOOP_CARG clooptrace_needsDispatcher(ITraceFactory* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::trace_needs();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<ISC_UINT64>(0);
			}
		}

		static ITracePlugin* CLOOP_CARG clooptrace_createDispatcher(ITraceFactory* self, IStatus* status, ITraceInitInfo* init_info) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::trace_create(&status2, init_info);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<ITracePlugin*>(0);
			}
		}

		static void CLOOP_CARG cloopsetOwnerDispatcher(IPluginBase* self, IReferenceCounted* r) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::setOwner(r);
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static IReferenceCounted* CLOOP_CARG cloopgetOwnerDispatcher(IPluginBase* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getOwner();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<IReferenceCounted*>(0);
			}
		}

		static void CLOOP_CARG cloopaddRefDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::addRef();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}

		static int CLOOP_CARG cloopreleaseDispatcher(IReferenceCounted* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::release();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<int>(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IPluginBaseImpl<Name, StatusType, Inherit<IReferenceCountedImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<ITraceFactory> > > > > > >
	class ITraceFactoryImpl : public ITraceFactoryBaseImpl<Name, StatusType, Base>
	{
	protected:
		ITraceFactoryImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~ITraceFactoryImpl()
		{
		}

		virtual ISC_UINT64 trace_needs() = 0;
		virtual ITracePlugin* trace_create(StatusType* status, ITraceInitInfo* init_info) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IUdrFunctionFactoryBaseImpl : public Base
	{
	public:
		typedef IUdrFunctionFactory Declaration;

		IUdrFunctionFactoryBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->dispose = &Name::cloopdisposeDispatcher;
					this->setup = &Name::cloopsetupDispatcher;
					this->newItem = &Name::cloopnewItemDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopsetupDispatcher(IUdrFunctionFactory* self, IStatus* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* inBuilder, IMetadataBuilder* outBuilder) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::setup(&status2, context, metadata, inBuilder, outBuilder);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static IExternalFunction* CLOOP_CARG cloopnewItemDispatcher(IUdrFunctionFactory* self, IStatus* status, IExternalContext* context, IRoutineMetadata* metadata) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::newItem(&status2, context, metadata);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IExternalFunction*>(0);
			}
		}

		static void CLOOP_CARG cloopdisposeDispatcher(IDisposable* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::dispose();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IDisposableImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IUdrFunctionFactory> > > > >
	class IUdrFunctionFactoryImpl : public IUdrFunctionFactoryBaseImpl<Name, StatusType, Base>
	{
	protected:
		IUdrFunctionFactoryImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IUdrFunctionFactoryImpl()
		{
		}

		virtual void setup(StatusType* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* inBuilder, IMetadataBuilder* outBuilder) = 0;
		virtual IExternalFunction* newItem(StatusType* status, IExternalContext* context, IRoutineMetadata* metadata) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IUdrProcedureFactoryBaseImpl : public Base
	{
	public:
		typedef IUdrProcedureFactory Declaration;

		IUdrProcedureFactoryBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->dispose = &Name::cloopdisposeDispatcher;
					this->setup = &Name::cloopsetupDispatcher;
					this->newItem = &Name::cloopnewItemDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopsetupDispatcher(IUdrProcedureFactory* self, IStatus* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* inBuilder, IMetadataBuilder* outBuilder) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::setup(&status2, context, metadata, inBuilder, outBuilder);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static IExternalProcedure* CLOOP_CARG cloopnewItemDispatcher(IUdrProcedureFactory* self, IStatus* status, IExternalContext* context, IRoutineMetadata* metadata) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::newItem(&status2, context, metadata);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IExternalProcedure*>(0);
			}
		}

		static void CLOOP_CARG cloopdisposeDispatcher(IDisposable* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::dispose();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IDisposableImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IUdrProcedureFactory> > > > >
	class IUdrProcedureFactoryImpl : public IUdrProcedureFactoryBaseImpl<Name, StatusType, Base>
	{
	protected:
		IUdrProcedureFactoryImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IUdrProcedureFactoryImpl()
		{
		}

		virtual void setup(StatusType* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* inBuilder, IMetadataBuilder* outBuilder) = 0;
		virtual IExternalProcedure* newItem(StatusType* status, IExternalContext* context, IRoutineMetadata* metadata) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IUdrTriggerFactoryBaseImpl : public Base
	{
	public:
		typedef IUdrTriggerFactory Declaration;

		IUdrTriggerFactoryBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->dispose = &Name::cloopdisposeDispatcher;
					this->setup = &Name::cloopsetupDispatcher;
					this->newItem = &Name::cloopnewItemDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static void CLOOP_CARG cloopsetupDispatcher(IUdrTriggerFactory* self, IStatus* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* fieldsBuilder) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::setup(&status2, context, metadata, fieldsBuilder);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static IExternalTrigger* CLOOP_CARG cloopnewItemDispatcher(IUdrTriggerFactory* self, IStatus* status, IExternalContext* context, IRoutineMetadata* metadata) throw()
		{
			StatusType status2(status);

			try
			{
				return static_cast<Name*>(self)->Name::newItem(&status2, context, metadata);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
				return static_cast<IExternalTrigger*>(0);
			}
		}

		static void CLOOP_CARG cloopdisposeDispatcher(IDisposable* self) throw()
		{
			try
			{
				static_cast<Name*>(self)->Name::dispose();
			}
			catch (...)
			{
				StatusType::catchException(0);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IDisposableImpl<Name, StatusType, Inherit<IVersionedImpl<Name, StatusType, Inherit<IUdrTriggerFactory> > > > >
	class IUdrTriggerFactoryImpl : public IUdrTriggerFactoryBaseImpl<Name, StatusType, Base>
	{
	protected:
		IUdrTriggerFactoryImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IUdrTriggerFactoryImpl()
		{
		}

		virtual void setup(StatusType* status, IExternalContext* context, IRoutineMetadata* metadata, IMetadataBuilder* fieldsBuilder) = 0;
		virtual IExternalTrigger* newItem(StatusType* status, IExternalContext* context, IRoutineMetadata* metadata) = 0;
	};

	template <typename Name, typename StatusType, typename Base>
	class IUdrPluginBaseImpl : public Base
	{
	public:
		typedef IUdrPlugin Declaration;

		IUdrPluginBaseImpl(DoNotInherit = DoNotInherit())
		{
			static struct VTableImpl : Base::VTable
			{
				VTableImpl()
				{
					this->version = Base::VERSION;
					this->getMaster = &Name::cloopgetMasterDispatcher;
					this->registerFunction = &Name::cloopregisterFunctionDispatcher;
					this->registerProcedure = &Name::cloopregisterProcedureDispatcher;
					this->registerTrigger = &Name::cloopregisterTriggerDispatcher;
				}
			} vTable;

			this->cloopVTable = &vTable;
		}

		static IMaster* CLOOP_CARG cloopgetMasterDispatcher(IUdrPlugin* self) throw()
		{
			try
			{
				return static_cast<Name*>(self)->Name::getMaster();
			}
			catch (...)
			{
				StatusType::catchException(0);
				return static_cast<IMaster*>(0);
			}
		}

		static void CLOOP_CARG cloopregisterFunctionDispatcher(IUdrPlugin* self, IStatus* status, const char* name, IUdrFunctionFactory* factory) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::registerFunction(&status2, name, factory);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopregisterProcedureDispatcher(IUdrPlugin* self, IStatus* status, const char* name, IUdrProcedureFactory* factory) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::registerProcedure(&status2, name, factory);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}

		static void CLOOP_CARG cloopregisterTriggerDispatcher(IUdrPlugin* self, IStatus* status, const char* name, IUdrTriggerFactory* factory) throw()
		{
			StatusType status2(status);

			try
			{
				static_cast<Name*>(self)->Name::registerTrigger(&status2, name, factory);
			}
			catch (...)
			{
				StatusType::catchException(&status2);
			}
		}
	};

	template <typename Name, typename StatusType, typename Base = IVersionedImpl<Name, StatusType, Inherit<IUdrPlugin> > >
	class IUdrPluginImpl : public IUdrPluginBaseImpl<Name, StatusType, Base>
	{
	protected:
		IUdrPluginImpl(DoNotInherit = DoNotInherit())
		{
		}

	public:
		virtual ~IUdrPluginImpl()
		{
		}

		virtual IMaster* getMaster() = 0;
		virtual void registerFunction(StatusType* status, const char* name, IUdrFunctionFactory* factory) = 0;
		virtual void registerProcedure(StatusType* status, const char* name, IUdrProcedureFactory* factory) = 0;
		virtual void registerTrigger(StatusType* status, const char* name, IUdrTriggerFactory* factory) = 0;
	};
};


#endif	// IDL_FB_INTERFACES_H
